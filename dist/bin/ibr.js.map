{"version":3,"sources":["../../src/schemas.ts","../../src/types.ts","../../src/auth.ts","../../src/semantic/landmarks.ts","../../src/semantic/page-intent.ts","../../src/capture.ts","../../src/compare.ts","../../src/git-context.ts","../../src/session.ts","../../src/semantic/state-detector.ts","../../src/semantic/output.ts","../../src/semantic/index.ts","../../src/flows/types.ts","../../src/flows/search.ts","../../src/flows/search-validation.ts","../../src/consistency.ts","../../src/crawl.ts","../../src/integration.ts","../../src/performance.ts","../../src/interactivity.ts","../../src/api-timing.ts","../../src/memory.ts","../../src/rules/presets/minimal.ts","../../src/rules/engine.ts","../../src/extract.ts","../../src/framework-parser.ts","../../src/context-loader.ts","../../src/rules/dynamic-rules.ts","../../src/browser-server.ts","../../src/live-session.ts","../../src/screenshot-manager.ts","../../src/bin/ibr.ts","../../src/index.ts","../../src/report.ts","../../src/flows/login.ts","../../src/flows/index.ts","../../src/flows/form.ts","../../src/cleanup.ts","../../src/operation-tracker.ts","../../src/responsive.ts","../../src/decision-tracker.ts","../../src/context/types.ts","../../src/context/compact.ts"],"sourcesContent":["import { z } from 'zod';\n\n/**\n * Viewport configuration for screenshot capture\n * Supports predefined names or custom dimensions\n */\nexport const ViewportSchema = z.object({\n  name: z.string().min(1).max(50),\n  width: z.number().min(320).max(3840),\n  height: z.number().min(480).max(2160),\n});\n\n/**\n * Predefined viewport configurations\n */\nexport const VIEWPORTS = {\n  desktop: { name: 'desktop', width: 1920, height: 1080 },\n  'desktop-lg': { name: 'desktop-lg', width: 2560, height: 1440 },\n  'desktop-sm': { name: 'desktop-sm', width: 1440, height: 900 },\n  laptop: { name: 'laptop', width: 1366, height: 768 },\n  tablet: { name: 'tablet', width: 768, height: 1024 },\n  'tablet-landscape': { name: 'tablet-landscape', width: 1024, height: 768 },\n  mobile: { name: 'mobile', width: 375, height: 667 },\n  'mobile-lg': { name: 'mobile-lg', width: 414, height: 896 },\n  'iphone-14': { name: 'iphone-14', width: 390, height: 844 },\n  'iphone-14-pro-max': { name: 'iphone-14-pro-max', width: 430, height: 932 },\n} as const;\n\n/**\n * Main configuration for InterfaceBuiltRight\n */\nexport const ConfigSchema = z.object({\n  baseUrl: z.string().url('Must be a valid URL'),\n  outputDir: z.string().default('./.ibr'),\n  viewport: ViewportSchema.default(VIEWPORTS.desktop),\n  viewports: z.array(ViewportSchema).optional(), // Multi-viewport support\n  threshold: z.number().min(0).max(100).default(1.0),\n  fullPage: z.boolean().default(true),\n  waitForNetworkIdle: z.boolean().default(true),\n  timeout: z.number().min(1000).max(120000).default(30000),\n});\n\n/**\n * Session query options\n */\nexport const SessionQuerySchema = z.object({\n  route: z.string().optional(),\n  url: z.string().optional(),\n  status: z.enum(['baseline', 'compared', 'pending']).optional(),\n  name: z.string().optional(),\n  createdAfter: z.date().optional(),\n  createdBefore: z.date().optional(),\n  viewport: z.string().optional(),\n  limit: z.number().min(1).max(100).default(50),\n});\n\n/**\n * Comparison result from pixelmatch\n */\nexport const ComparisonResultSchema = z.object({\n  match: z.boolean(),\n  diffPercent: z.number(),\n  diffPixels: z.number(),\n  totalPixels: z.number(),\n  threshold: z.number(),\n});\n\n/**\n * Changed region detected in comparison\n */\nexport const ChangedRegionSchema = z.object({\n  location: z.enum(['top', 'bottom', 'left', 'right', 'center', 'full']),\n  bounds: z.object({\n    x: z.number(),\n    y: z.number(),\n    width: z.number(),\n    height: z.number(),\n  }),\n  description: z.string(),\n  severity: z.enum(['expected', 'unexpected', 'critical']),\n});\n\n/**\n * Analysis verdict types\n */\nexport const VerdictSchema = z.enum([\n  'MATCH',\n  'EXPECTED_CHANGE',\n  'UNEXPECTED_CHANGE',\n  'LAYOUT_BROKEN',\n]);\n\n/**\n * Analysis result\n */\nexport const AnalysisSchema = z.object({\n  verdict: VerdictSchema,\n  summary: z.string(),\n  changedRegions: z.array(ChangedRegionSchema),\n  unexpectedChanges: z.array(ChangedRegionSchema),\n  recommendation: z.string().nullable(),\n});\n\n/**\n * Session status\n */\nexport const SessionStatusSchema = z.enum(['baseline', 'compared', 'pending']);\n\n/**\n * Element bounds (moved up for LandmarkElementSchema dependency)\n */\nexport const BoundsSchema = z.object({\n  x: z.number(),\n  y: z.number(),\n  width: z.number(),\n  height: z.number(),\n});\n\n/**\n * Landmark element detected on page\n */\nexport const LandmarkElementSchema = z.object({\n  name: z.string(),           // e.g., 'logo', 'header', 'nav'\n  selector: z.string(),       // CSS selector used to find it\n  found: z.boolean(),\n  bounds: BoundsSchema.optional(),\n});\n\n/**\n * Visual session\n */\nexport const SessionSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  url: z.string().url(),\n  viewport: ViewportSchema,\n  status: SessionStatusSchema,\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  comparison: ComparisonResultSchema.optional(),\n  analysis: AnalysisSchema.optional(),\n  // Landmark elements detected at baseline capture\n  landmarkElements: z.array(LandmarkElementSchema).optional(),\n  // Page intent detected at baseline\n  pageIntent: z.string().optional(),\n});\n\n/**\n * Full comparison report\n */\nexport const ComparisonReportSchema = z.object({\n  sessionId: z.string(),\n  sessionName: z.string(),\n  url: z.string(),\n  timestamp: z.string().datetime(),\n  viewport: ViewportSchema,\n  comparison: ComparisonResultSchema,\n  analysis: AnalysisSchema,\n  files: z.object({\n    baseline: z.string(),\n    current: z.string(),\n    diff: z.string(),\n  }),\n  webViewUrl: z.string().optional(),\n});\n\n/**\n * Element interactivity detection\n */\nexport const InteractiveStateSchema = z.object({\n  hasOnClick: z.boolean(),\n  hasHref: z.boolean(),\n  isDisabled: z.boolean(),\n  tabIndex: z.number(),\n  cursor: z.string(),\n  // Framework-specific detection\n  hasReactHandler: z.boolean().optional(),\n  hasVueHandler: z.boolean().optional(),\n  hasAngularHandler: z.boolean().optional(),\n});\n\n/**\n * Accessibility attributes\n */\nexport const A11yAttributesSchema = z.object({\n  role: z.string().nullable(),\n  ariaLabel: z.string().nullable(),\n  ariaDescribedBy: z.string().nullable(),\n  ariaHidden: z.boolean().optional(),\n});\n\n/**\n * Enhanced element with interactivity and accessibility\n */\nexport const EnhancedElementSchema = z.object({\n  // Identity\n  selector: z.string(),\n  tagName: z.string(),\n  id: z.string().optional(),\n  className: z.string().optional(),\n  text: z.string().optional(),\n\n  // Position\n  bounds: BoundsSchema,\n\n  // Styles (subset)\n  computedStyles: z.record(z.string(), z.string()).optional(),\n\n  // Interactivity\n  interactive: InteractiveStateSchema,\n\n  // Accessibility\n  a11y: A11yAttributesSchema,\n\n  // Source hints for debugging\n  sourceHint: z.object({\n    dataTestId: z.string().nullable(),\n  }).optional(),\n});\n\n/**\n * Element issue detected during audit\n */\nexport const ElementIssueSchema = z.object({\n  type: z.enum([\n    'NO_HANDLER',           // Interactive-looking but no handler\n    'PLACEHOLDER_LINK',     // href=\"#\" without handler\n    'TOUCH_TARGET_SMALL',   // < 44px on mobile\n    'MISSING_ARIA_LABEL',   // Interactive without label\n    'DISABLED_NO_VISUAL',   // Disabled but no visual indication\n  ]),\n  severity: z.enum(['error', 'warning', 'info']),\n  message: z.string(),\n});\n\n/**\n * Audit result for a captured page\n */\nexport const AuditResultSchema = z.object({\n  totalElements: z.number(),\n  interactiveCount: z.number(),\n  withHandlers: z.number(),\n  withoutHandlers: z.number(),\n  issues: z.array(ElementIssueSchema),\n});\n\n// Type exports - auto-generated from schemas\nexport type Viewport = z.infer<typeof ViewportSchema>;\nexport type Config = z.infer<typeof ConfigSchema>;\nexport type SessionQuery = z.infer<typeof SessionQuerySchema>;\nexport type ComparisonResult = z.infer<typeof ComparisonResultSchema>;\nexport type ChangedRegion = z.infer<typeof ChangedRegionSchema>;\nexport type Verdict = z.infer<typeof VerdictSchema>;\nexport type Analysis = z.infer<typeof AnalysisSchema>;\nexport type SessionStatus = z.infer<typeof SessionStatusSchema>;\nexport type LandmarkElement = z.infer<typeof LandmarkElementSchema>;\nexport type Session = z.infer<typeof SessionSchema>;\nexport type ComparisonReport = z.infer<typeof ComparisonReportSchema>;\nexport type InteractiveState = z.infer<typeof InteractiveStateSchema>;\nexport type A11yAttributes = z.infer<typeof A11yAttributesSchema>;\nexport type Bounds = z.infer<typeof BoundsSchema>;\nexport type EnhancedElement = z.infer<typeof EnhancedElementSchema>;\nexport type ElementIssue = z.infer<typeof ElementIssueSchema>;\nexport type AuditResult = z.infer<typeof AuditResultSchema>;\n\n/**\n * Rule severity levels\n */\nexport const RuleSeveritySchema = z.enum(['off', 'warn', 'error']);\n\n/**\n * Individual rule setting\n */\nexport const RuleSettingSchema = z.union([\n  RuleSeveritySchema,\n  z.tuple([RuleSeveritySchema, z.record(z.string(), z.unknown())]),\n]);\n\n/**\n * Rules configuration (user's .ibr/rules.json)\n */\nexport const RulesConfigSchema = z.object({\n  extends: z.array(z.string()).optional(),\n  rules: z.record(z.string(), RuleSettingSchema).optional(),\n});\n\n/**\n * Violation detected by a rule\n */\nexport const ViolationSchema = z.object({\n  ruleId: z.string(),\n  ruleName: z.string(),\n  severity: z.enum(['warn', 'error']),\n  message: z.string(),\n  element: z.string().optional(),  // Selector of violating element\n  bounds: BoundsSchema.optional(),\n  fix: z.string().optional(),       // Suggested fix\n});\n\n/**\n * Full audit report with rule violations\n */\nexport const RuleAuditResultSchema = z.object({\n  url: z.string(),\n  timestamp: z.string(),\n  elementsScanned: z.number(),\n  violations: z.array(ViolationSchema),\n  summary: z.object({\n    errors: z.number(),\n    warnings: z.number(),\n    passed: z.number(),\n  }),\n});\n\n// Rule-related type exports\nexport type RuleSeverity = z.infer<typeof RuleSeveritySchema>;\nexport type RuleSetting = z.infer<typeof RuleSettingSchema>;\nexport type RulesConfig = z.infer<typeof RulesConfigSchema>;\nexport type Violation = z.infer<typeof ViolationSchema>;\nexport type RuleAuditResult = z.infer<typeof RuleAuditResultSchema>;\n\n// ============================================================================\n// MEMORY SYSTEM SCHEMAS\n// ============================================================================\n\n/**\n * Source of a UI/UX preference\n */\nexport const MemorySourceSchema = z.enum(['user', 'learned', 'framework']);\n\n/**\n * Preference categories\n */\nexport const PreferenceCategorySchema = z.enum([\n  'color',\n  'layout',\n  'typography',\n  'navigation',\n  'component',\n  'spacing',\n  'interaction',\n  'content',\n]);\n\n/**\n * Expectation operator for comparing values\n */\nexport const ExpectationOperatorSchema = z.enum(['equals', 'contains', 'matches', 'gte', 'lte']);\n\n/**\n * A single UI/UX expectation\n */\nexport const ExpectationSchema = z.object({\n  property: z.string(),\n  operator: ExpectationOperatorSchema,\n  value: z.string(),\n});\n\n/**\n * Full preference with history\n */\nexport const PreferenceSchema = z.object({\n  id: z.string(),\n  description: z.string(),\n  category: PreferenceCategorySchema,\n  source: MemorySourceSchema,\n  route: z.string().optional(),\n  componentType: z.string().optional(),\n  expectation: ExpectationSchema,\n  confidence: z.number().min(0).max(1).default(1.0),\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  sessionIds: z.array(z.string()).optional(),\n});\n\n/**\n * Observation extracted from a session\n */\nexport const ObservationSchema = z.object({\n  description: z.string(),\n  category: PreferenceCategorySchema,\n  property: z.string(),\n  value: z.string(),\n});\n\n/**\n * Learned expectation from an approved session\n */\nexport const LearnedExpectationSchema = z.object({\n  id: z.string(),\n  sessionId: z.string(),\n  route: z.string(),\n  observations: z.array(ObservationSchema),\n  approved: z.boolean(),\n  createdAt: z.string().datetime(),\n});\n\n/**\n * Compact preference pointer for summary\n */\nexport const ActivePreferenceSchema = z.object({\n  id: z.string(),\n  description: z.string(),\n  category: PreferenceCategorySchema,\n  route: z.string().optional(),\n  componentType: z.string().optional(),\n  property: z.string(),\n  operator: ExpectationOperatorSchema,\n  value: z.string(),\n  confidence: z.number(),\n});\n\n/**\n * Memory summary - always-loaded compact file\n */\nexport const MemorySummarySchema = z.object({\n  version: z.literal(1),\n  updatedAt: z.string().datetime(),\n  stats: z.object({\n    totalPreferences: z.number(),\n    totalLearned: z.number(),\n    byCategory: z.record(z.string(), z.number()),\n    bySource: z.record(z.string(), z.number()),\n  }),\n  activePreferences: z.array(ActivePreferenceSchema),\n});\n\n// Memory type exports\nexport type MemorySource = z.infer<typeof MemorySourceSchema>;\nexport type PreferenceCategory = z.infer<typeof PreferenceCategorySchema>;\nexport type ExpectationOperator = z.infer<typeof ExpectationOperatorSchema>;\nexport type Expectation = z.infer<typeof ExpectationSchema>;\nexport type Preference = z.infer<typeof PreferenceSchema>;\nexport type Observation = z.infer<typeof ObservationSchema>;\nexport type LearnedExpectation = z.infer<typeof LearnedExpectationSchema>;\nexport type ActivePreference = z.infer<typeof ActivePreferenceSchema>;\nexport type MemorySummary = z.infer<typeof MemorySummarySchema>;\n","import type {\n  Config,\n  Session,\n  ComparisonResult,\n  ComparisonReport,\n  Viewport,\n  Analysis,\n} from './schemas.js';\n\n/**\n * Options for starting a visual session\n */\nexport interface StartSessionOptions {\n  name?: string;\n  viewport?: Viewport;\n  fullPage?: boolean;\n  /** CSS selector to capture specific element instead of full page */\n  selector?: string;\n  /** CSS selector to wait for before capturing screenshot */\n  waitFor?: string;\n}\n\n/**\n * Result from starting a session\n */\nexport interface StartSessionResult {\n  sessionId: string;\n  baseline: string;\n  session: Session;\n}\n\n/**\n * Options for masking dynamic content during capture\n */\nexport interface MaskOptions {\n  /** CSS selectors of elements to hide (set visibility: hidden) */\n  selectors?: string[];\n  /** Text patterns to mask (replaced with placeholder) */\n  textPatterns?: Array<string | RegExp>;\n  /** Hide common dynamic elements automatically (timestamps, spinners, etc.) */\n  hideDynamicContent?: boolean;\n  /** Disable all animations and transitions (default: true) */\n  hideAnimations?: boolean;\n  /** Replace masked text with this placeholder (default: '‚ñà‚ñà‚ñà') */\n  placeholder?: string;\n}\n\n/**\n * Default selectors for common dynamic content\n */\nexport const DEFAULT_DYNAMIC_SELECTORS = [\n  // Timestamps and dates\n  '[data-testid*=\"timestamp\"]',\n  '[data-testid*=\"date\"]',\n  '[data-testid*=\"time\"]',\n  '[class*=\"timestamp\"]',\n  '[class*=\"relative-time\"]',\n  '[class*=\"timeago\"]',\n  'time[datetime]',\n  // Loading indicators\n  '[class*=\"loading\"]',\n  '[class*=\"spinner\"]',\n  '[class*=\"skeleton\"]',\n  '[class*=\"shimmer\"]',\n  '[role=\"progressbar\"]',\n  // Live counters\n  '[class*=\"live-count\"]',\n  '[class*=\"viewer-count\"]',\n  '[class*=\"online-count\"]',\n  // Avatars with random colors\n  '[class*=\"avatar\"][style*=\"background\"]',\n  // Random IDs displayed\n  '[data-testid*=\"session-id\"]',\n  '[class*=\"request-id\"]',\n];\n\n/**\n * Options for capturing a screenshot\n */\nexport interface CaptureOptions {\n  url: string;\n  outputPath: string;\n  viewport?: Viewport;\n  fullPage?: boolean;\n  waitForNetworkIdle?: boolean;\n  timeout?: number;\n  /** CSS selector to capture specific element instead of full page */\n  selector?: string;\n  /** CSS selector to wait for before capturing screenshot */\n  waitFor?: string;\n  /** Options for masking dynamic content */\n  mask?: MaskOptions;\n}\n\n/**\n * Options for comparing images\n */\nexport interface CompareOptions {\n  baselinePath: string;\n  currentPath: string;\n  diffPath: string;\n  threshold?: number;\n}\n\n/**\n * Session file paths\n */\nexport interface SessionPaths {\n  root: string;\n  sessionJson: string;\n  baseline: string;\n  current: string;\n  diff: string;\n}\n\n/**\n * CLI output format\n */\nexport type OutputFormat = 'json' | 'text' | 'minimal';\n\n/**\n * Session list item for display\n */\nexport interface SessionListItem {\n  id: string;\n  name: string;\n  url: string;\n  status: string;\n  createdAt: string;\n  viewport: string;\n}\n\n/**\n * Clean options\n */\nexport interface CleanOptions {\n  olderThan?: string; // e.g., '7d', '24h'\n  keepLast?: number;\n  dryRun?: boolean;\n}\n\n/**\n * Serve options\n */\nexport interface ServeOptions {\n  port?: number;\n  open?: boolean;\n}\n\n/**\n * Authentication options for capture\n */\nexport interface AuthOptions {\n  storageStatePath?: string;\n}\n\n/**\n * Login options\n */\nexport interface LoginOptions {\n  url: string;\n  outputDir: string;\n  timeout?: number;\n}\n\n// Re-export schema types for convenience\nexport type {\n  Config,\n  Session,\n  ComparisonResult,\n  ComparisonReport,\n  Viewport,\n  Analysis,\n};\n","import { chromium } from 'playwright';\nimport { mkdir, access, readFile, writeFile, unlink, chmod, stat } from 'fs/promises';\nimport { join, resolve } from 'path';\nimport { existsSync, readFileSync } from 'fs';\nimport { userInfo, homedir } from 'os';\nimport { createHash, randomBytes } from 'crypto';\nimport type { LoginOptions } from './types.js';\n\n// Auth state file name (reserved for future use)\n// const AUTH_STATE_FILE = 'auth.json';\n\n/**\n * Auth state with metadata for security\n */\ninterface StoredAuthState {\n  state: object; // Playwright storage state\n  metadata: {\n    createdAt: number;\n    expiresAt: number;\n    username: string;\n    projectPath: string;\n  };\n}\n\n/**\n * Check if running in a CI/CD or deployed environment\n * Auth operations should be blocked in these environments\n */\nexport function isDeployedEnvironment(): boolean {\n  return !!(\n    process.env.VERCEL ||\n    process.env.NETLIFY ||\n    process.env.CI ||\n    process.env.GITHUB_ACTIONS ||\n    process.env.GITLAB_CI ||\n    process.env.CIRCLECI ||\n    process.env.JENKINS_URL ||\n    process.env.TRAVIS ||\n    process.env.HEROKU ||\n    process.env.AWS_LAMBDA_FUNCTION_NAME ||\n    process.env.AZURE_FUNCTIONS_ENVIRONMENT\n  );\n}\n\n/**\n * Get the path to the auth state file\n * Uses per-user isolation to prevent credential sharing\n */\nexport function getAuthStatePath(outputDir: string): string {\n  const username = userInfo().username;\n  // Include username in filename for user isolation\n  return join(outputDir, `auth.${username}.json`);\n}\n\n/**\n * Get a secure auth path in user's home directory (alternative)\n * This keeps auth completely outside the project directory\n */\nexport function getSecureAuthPath(projectPath: string): string {\n  const username = userInfo().username;\n  // Hash project path to create unique identifier\n  const projectHash = createHash('sha256')\n    .update(resolve(projectPath))\n    .digest('hex')\n    .substring(0, 16);\n\n  return join(\n    homedir(),\n    '.config',\n    'ibr',\n    'auth',\n    `${projectHash}.${username}.json`\n  );\n}\n\n/**\n * Check if .gitignore properly excludes .ibr directory\n */\nfunction validateGitignore(projectDir: string): void {\n  const gitignorePath = join(projectDir, '.gitignore');\n\n  if (existsSync(gitignorePath)) {\n    const gitignore = readFileSync(gitignorePath, 'utf-8');\n    const lines = gitignore.split('\\n').map(l => l.trim());\n\n    const hasIbrIgnore = lines.some(line =>\n      line === '.ibr/' ||\n      line === '.ibr' ||\n      line === '**/.ibr/' ||\n      line === '**/.ibr'\n    );\n\n    if (!hasIbrIgnore) {\n      console.warn('\\n‚ö†Ô∏è  WARNING: .ibr/ is not in .gitignore!');\n      console.warn('   Add \".ibr/\" to .gitignore to prevent credential leaks.\\n');\n    }\n  } else {\n    console.warn('\\n‚ö†Ô∏è  No .gitignore found. Create one with \".ibr/\" entry.\\n');\n  }\n}\n\n/**\n * Check if auth state exists\n */\nexport async function hasAuthState(outputDir: string): Promise<boolean> {\n  try {\n    await access(getAuthStatePath(outputDir));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Load auth state if it exists and is valid\n */\nexport async function loadAuthState(outputDir: string): Promise<object | null> {\n  // Block in deployed environments\n  if (isDeployedEnvironment()) {\n    console.warn('‚ö†Ô∏è  Deployed environment detected. Auth state not available.');\n    return null;\n  }\n\n  try {\n    const authPath = getAuthStatePath(outputDir);\n    const content = await readFile(authPath, 'utf-8');\n    const stored: StoredAuthState = JSON.parse(content);\n\n    // Validate metadata exists\n    if (!stored.metadata) {\n      console.warn('‚ö†Ô∏è  Legacy auth format detected. Please re-authenticate with `ibr login`.');\n      return null;\n    }\n\n    // Check user matches\n    const currentUser = userInfo().username;\n    if (stored.metadata.username !== currentUser) {\n      console.warn(`‚ö†Ô∏è  Auth state belongs to different user (${stored.metadata.username}).`);\n      return null;\n    }\n\n    // Check expiration\n    if (Date.now() > stored.metadata.expiresAt) {\n      console.warn('‚ö†Ô∏è  Auth state expired. Please re-authenticate with `ibr login`.');\n      await clearAuthState(outputDir);\n      return null;\n    }\n\n    // Warn if auth is getting old (> 24 hours)\n    const ageHours = (Date.now() - stored.metadata.createdAt) / (1000 * 60 * 60);\n    if (ageHours > 24) {\n      console.warn(`‚ö†Ô∏è  Auth state is ${Math.floor(ageHours)} hours old. Consider re-authenticating.`);\n    }\n\n    return stored.state;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Open a browser for manual login and save the state\n *\n * This opens a visible browser window where the user can:\n * 1. Navigate to login page\n * 2. Enter credentials\n * 3. Complete any 2FA or other auth steps\n *\n * When done, close the browser or press Ctrl+C to save the state.\n */\nexport async function performLogin(options: LoginOptions): Promise<string> {\n  const { url, outputDir, timeout = 300000 } = options; // 5 min default timeout\n\n  // Block in deployed environments\n  if (isDeployedEnvironment()) {\n    throw new Error(\n      'Authentication cannot be performed in deployed environments.\\n' +\n      'Run `ibr login` locally on your development machine.'\n    );\n  }\n\n  // Validate .gitignore before storing credentials\n  validateGitignore(process.cwd());\n\n  // Ensure output directory exists with restricted permissions\n  await mkdir(outputDir, { recursive: true, mode: 0o700 }); // rwx------\n\n  // Fix permissions on existing directory\n  try {\n    await chmod(outputDir, 0o700);\n  } catch {\n    // Ignore if chmod fails (e.g., on Windows)\n  }\n\n  const authStatePath = getAuthStatePath(outputDir);\n  const currentUser = userInfo().username;\n\n  console.log('\\nüîê Opening browser for login...');\n  console.log(`   User: ${currentUser}`);\n  console.log('   Navigate to your login page and complete authentication.');\n  console.log('   When finished, close the browser window to save your session.\\n');\n\n  const browser = await chromium.launch({\n    headless: false, // Visible browser for manual login\n  });\n\n  const context = await browser.newContext({\n    viewport: { width: 1280, height: 800 },\n  });\n\n  const page = await context.newPage();\n\n  try {\n    // Navigate to the provided URL\n    await page.goto(url, {\n      waitUntil: 'domcontentloaded',\n      timeout: 30000,\n    });\n\n    // Wait for browser to close (user manually closes it after login)\n    // or timeout after the specified duration\n    await Promise.race([\n      new Promise<void>((resolve) => {\n        browser.on('disconnected', () => resolve());\n      }),\n      new Promise<void>((_, reject) => {\n        setTimeout(() => reject(new Error('Login timeout exceeded')), timeout);\n      }),\n    ]);\n\n  } catch (error) {\n    // If browser is still open, save the state before closing\n    if (browser.isConnected()) {\n      await saveAuthState(context, authStatePath, outputDir);\n      await browser.close();\n    }\n\n    // Check if it was a timeout or browser close\n    if (error instanceof Error && error.message.includes('timeout')) {\n      throw error;\n    }\n  }\n\n  // If we get here without the browser being disconnected, save state\n  if (browser.isConnected()) {\n    await saveAuthState(context, authStatePath, outputDir);\n    await browser.close();\n  } else {\n    // Browser was closed by user - try to reconnect to save state\n    console.log('\\n‚ö†Ô∏è  Browser was closed. Attempting to save any captured state...');\n\n    // Create a new context just to save an empty state as fallback\n    const newBrowser = await chromium.launch({ headless: true });\n    const newContext = await newBrowser.newContext();\n\n    // Try to use any cookies from the page\n    try {\n      await newContext.addCookies(await context.cookies());\n    } catch {\n      // Context might be closed\n    }\n\n    await saveAuthState(newContext, authStatePath, outputDir);\n    await newBrowser.close();\n  }\n\n  console.log(`\\n‚úÖ Auth state saved for user: ${currentUser}`);\n  console.log(`   Location: ${authStatePath}`);\n  console.log('   Expires: 7 days from now');\n  console.log('   Future captures will use this authentication.\\n');\n\n  return authStatePath;\n}\n\n/**\n * Save auth state with metadata and secure permissions\n */\nasync function saveAuthState(\n  context: import('playwright').BrowserContext,\n  authStatePath: string,\n  _outputDir: string\n): Promise<void> {\n  const state = await context.storageState();\n  const currentUser = userInfo().username;\n\n  const storedState: StoredAuthState = {\n    state,\n    metadata: {\n      createdAt: Date.now(),\n      expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days\n      username: currentUser,\n      projectPath: resolve(process.cwd()),\n    }\n  };\n\n  // Write with restricted permissions (owner read/write only)\n  await writeFile(\n    authStatePath,\n    JSON.stringify(storedState, null, 2),\n    { mode: 0o600 } // rw-------\n  );\n\n  // Ensure permissions are correct (in case file existed)\n  try {\n    await chmod(authStatePath, 0o600);\n  } catch {\n    // Ignore if chmod fails (e.g., on Windows)\n  }\n}\n\n/**\n * Clear saved auth state with secure deletion\n */\nexport async function clearAuthState(outputDir: string): Promise<void> {\n  const authPath = getAuthStatePath(outputDir);\n\n  try {\n    // Get file stats for size\n    const stats = await stat(authPath);\n\n    // Overwrite with random data before deletion (secure delete)\n    const randomData = randomBytes(stats.size);\n    await writeFile(authPath, randomData, { mode: 0o600 });\n\n    // Now delete the file\n    await unlink(authPath);\n\n    console.log('‚úÖ Auth state securely cleared');\n  } catch {\n    console.log('‚ÑπÔ∏è  No auth state to clear');\n  }\n}\n\n/**\n * Get auth state info without loading the full state\n */\nexport async function getAuthStateInfo(outputDir: string): Promise<{\n  exists: boolean;\n  username?: string;\n  createdAt?: Date;\n  expiresAt?: Date;\n  expired?: boolean;\n} | null> {\n  try {\n    const authPath = getAuthStatePath(outputDir);\n    const content = await readFile(authPath, 'utf-8');\n    const stored: StoredAuthState = JSON.parse(content);\n\n    if (!stored.metadata) {\n      return { exists: true };\n    }\n\n    return {\n      exists: true,\n      username: stored.metadata.username,\n      createdAt: new Date(stored.metadata.createdAt),\n      expiresAt: new Date(stored.metadata.expiresAt),\n      expired: Date.now() > stored.metadata.expiresAt,\n    };\n  } catch {\n    return null;\n  }\n}\n","/**\n * Landmark Element Detection\n *\n * Detects common landmark elements on a page. Used for:\n * 1. Storing detected elements in baseline\n * 2. Comparing current elements against baseline\n * 3. Inferring expected elements from page intent when no baseline exists\n */\n\nimport type { Page } from 'playwright';\nimport type { LandmarkElement } from '../schemas.js';\nimport type { PageIntent } from './page-intent.js';\n\n/**\n * Standard landmark selectors\n */\nexport const LANDMARK_SELECTORS = {\n  logo: 'img[src*=\"logo\"], img[alt*=\"logo\" i], [class*=\"logo\"], [id*=\"logo\"], svg[class*=\"logo\"]',\n  header: 'header, [role=\"banner\"], [class*=\"header\"]:not([class*=\"subheader\"])',\n  navigation: 'nav, [role=\"navigation\"], [class*=\"nav\"]:not([class*=\"subnav\"])',\n  main: 'main, [role=\"main\"], [class*=\"main-content\"], #main',\n  footer: 'footer, [role=\"contentinfo\"], [class*=\"footer\"]',\n  sidebar: 'aside, [role=\"complementary\"], [class*=\"sidebar\"]',\n  search: 'input[type=\"search\"], [role=\"search\"], [class*=\"search-input\"], input[name*=\"search\"]',\n  heading: 'h1',\n  userMenu: '[class*=\"user-menu\"], [class*=\"avatar\"], [class*=\"profile\"], [class*=\"account\"]',\n  loginForm: 'form:has(input[type=\"password\"])',\n  heroSection: '[class*=\"hero\"], [class*=\"banner\"], [class*=\"jumbotron\"]',\n  ctaButton: '[class*=\"cta\"], a[class*=\"primary\"], button[class*=\"primary\"]',\n} as const;\n\nexport type LandmarkType = keyof typeof LANDMARK_SELECTORS;\n\n/**\n * Detect all landmark elements on a page\n */\nexport async function detectLandmarks(page: Page): Promise<LandmarkElement[]> {\n  const landmarks: LandmarkElement[] = [];\n\n  for (const [name, selector] of Object.entries(LANDMARK_SELECTORS)) {\n    try {\n      const element = await page.$(selector);\n      if (element) {\n        const box = await element.boundingBox();\n        landmarks.push({\n          name,\n          selector,\n          found: true,\n          bounds: box ? {\n            x: Math.round(box.x),\n            y: Math.round(box.y),\n            width: Math.round(box.width),\n            height: Math.round(box.height),\n          } : undefined,\n        });\n      } else {\n        landmarks.push({\n          name,\n          selector,\n          found: false,\n        });\n      }\n    } catch {\n      landmarks.push({\n        name,\n        selector,\n        found: false,\n      });\n    }\n  }\n\n  return landmarks;\n}\n\n/**\n * Get expected landmarks based on page intent\n * Used when no baseline exists\n */\nexport function getExpectedLandmarksForIntent(intent: PageIntent): LandmarkType[] {\n  const common: LandmarkType[] = ['header', 'navigation', 'main', 'footer', 'logo'];\n\n  const intentSpecific: Record<PageIntent, LandmarkType[]> = {\n    auth: ['loginForm', 'logo'],\n    form: ['heading'],\n    listing: ['search', 'heading'],\n    detail: ['heading'],\n    dashboard: ['sidebar', 'userMenu', 'heading'],\n    error: ['heading'],\n    landing: ['heroSection', 'ctaButton', 'heading'],\n    empty: ['heading'],\n    unknown: [],\n  };\n\n  // Combine common + intent-specific, dedupe\n  const expected = [...new Set([...common, ...(intentSpecific[intent] || [])])];\n  return expected;\n}\n\n/**\n * Compare current landmarks against baseline\n * Returns missing and new elements\n */\nexport function compareLandmarks(\n  baseline: LandmarkElement[],\n  current: LandmarkElement[]\n): {\n  missing: LandmarkElement[];  // Were in baseline, not in current\n  added: LandmarkElement[];    // In current, not in baseline\n  unchanged: LandmarkElement[];\n} {\n  const baselineFound = baseline.filter(l => l.found);\n  const currentFound = current.filter(l => l.found);\n\n  const baselineNames = new Set(baselineFound.map(l => l.name));\n  const currentNames = new Set(currentFound.map(l => l.name));\n\n  const missing = baselineFound.filter(l => !currentNames.has(l.name));\n  const added = currentFound.filter(l => !baselineNames.has(l.name));\n  const unchanged = currentFound.filter(l => baselineNames.has(l.name));\n\n  return { missing, added, unchanged };\n}\n\n/**\n * Get expected landmarks based on user context (CLAUDE.md design framework)\n */\nexport function getExpectedLandmarksFromContext(\n  framework: { principles: string[] } | null\n): LandmarkType[] {\n  if (!framework) return [];\n\n  const expected: LandmarkType[] = [];\n\n  // Parse principles for landmark requirements\n  const principlesText = framework.principles.join(' ').toLowerCase();\n\n  if (principlesText.includes('logo') || principlesText.includes('brand')) {\n    expected.push('logo');\n  }\n  if (principlesText.includes('navigation') || principlesText.includes('nav')) {\n    expected.push('navigation');\n  }\n  if (principlesText.includes('header') || principlesText.includes('banner')) {\n    expected.push('header');\n  }\n  if (principlesText.includes('footer')) {\n    expected.push('footer');\n  }\n  if (principlesText.includes('sidebar')) {\n    expected.push('sidebar');\n  }\n  if (principlesText.includes('search')) {\n    expected.push('search');\n  }\n  if (principlesText.includes('cta') || principlesText.includes('call-to-action')) {\n    expected.push('ctaButton');\n  }\n  if (principlesText.includes('hero')) {\n    expected.push('heroSection');\n  }\n\n  return expected;\n}\n\n/**\n * Format landmark comparison for display\n */\nexport function formatLandmarkComparison(\n  comparison: ReturnType<typeof compareLandmarks>\n): string {\n  const lines: string[] = [];\n\n  if (comparison.missing.length > 0) {\n    lines.push('Missing (were in baseline):');\n    for (const el of comparison.missing) {\n      lines.push(`  ! ${el.name}`);\n    }\n  }\n\n  if (comparison.added.length > 0) {\n    lines.push('New (not in baseline):');\n    for (const el of comparison.added) {\n      lines.push(`  + ${el.name}`);\n    }\n  }\n\n  if (comparison.unchanged.length > 0) {\n    lines.push('Unchanged:');\n    for (const el of comparison.unchanged) {\n      lines.push(`  ‚úì ${el.name}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Page Intent Classification\n *\n * Classifies pages by their semantic purpose based on DOM analysis.\n * This helps AI agents understand what kind of page they're looking at\n * without parsing raw accessibility trees.\n */\n\nimport type { Page } from 'playwright';\n\nexport type PageIntent =\n  | 'auth'        // Login, register, forgot-password, reset-password\n  | 'form'        // Contact, settings, profile edit, checkout\n  | 'listing'     // Search results, product grid, table, feed\n  | 'detail'      // Product page, article, profile view, single item\n  | 'dashboard'   // Admin panel, user home, analytics\n  | 'error'       // 404, 500, access denied, maintenance\n  | 'landing'     // Marketing page, homepage with CTA\n  | 'empty'       // Empty state, no content\n  | 'unknown';\n\nexport interface PageIntentResult {\n  intent: PageIntent;\n  confidence: number;        // 0-1\n  signals: string[];         // What led to this classification\n  secondaryIntent?: PageIntent; // If page has mixed signals\n}\n\ninterface IntentSignals {\n  auth: number;\n  form: number;\n  listing: number;\n  detail: number;\n  dashboard: number;\n  error: number;\n  landing: number;\n  empty: number;\n}\n\n/**\n * Classify page intent from DOM analysis\n */\nexport async function classifyPageIntent(page: Page): Promise<PageIntentResult> {\n  const signals: string[] = [];\n  const scores: IntentSignals = {\n    auth: 0,\n    form: 0,\n    listing: 0,\n    detail: 0,\n    dashboard: 0,\n    error: 0,\n    landing: 0,\n    empty: 0,\n  };\n\n  // Run all checks in parallel for speed\n  const checks = await page.evaluate(() => {\n    const doc = document;\n    const body = doc.body;\n    const text = body?.innerText?.toLowerCase() || '';\n\n    // Helper to count elements\n    const count = (selector: string) => doc.querySelectorAll(selector).length;\n    const exists = (selector: string) => count(selector) > 0;\n    const textContains = (terms: string[]) => terms.some(t => text.includes(t));\n\n    return {\n      // Auth signals\n      hasPasswordField: exists('input[type=\"password\"]'),\n      hasEmailField: exists('input[type=\"email\"], input[name*=\"email\"], input[name*=\"username\"]'),\n      hasLoginText: textContains(['sign in', 'log in', 'login', 'sign up', 'register', 'forgot password', 'reset password']),\n      hasRememberMe: exists('input[type=\"checkbox\"][name*=\"remember\"]') || Array.from(doc.querySelectorAll('label')).some(l => l.textContent?.toLowerCase().includes('remember')),\n      hasOAuthButtons: exists('[class*=\"google\"], [class*=\"facebook\"], [class*=\"github\"], [class*=\"oauth\"], [class*=\"social\"]'),\n\n      // Form signals\n      formCount: count('form'),\n      inputCount: count('input:not([type=\"hidden\"]):not([type=\"search\"])'),\n      textareaCount: count('textarea'),\n      selectCount: count('select'),\n      hasSubmitButton: exists('button[type=\"submit\"], input[type=\"submit\"]'),\n      hasFormLabels: count('label') > 2,\n\n      // Listing signals\n      listItemCount: count('li, [class*=\"item\"], [class*=\"card\"], [class*=\"row\"]'),\n      hasGrid: exists('[class*=\"grid\"], [class*=\"list\"], [class*=\"feed\"]'),\n      hasTable: exists('table tbody tr'),\n      hasPagination: exists('[class*=\"pagination\"], [class*=\"pager\"], nav[aria-label*=\"page\"]'),\n      hasFilters: exists('[class*=\"filter\"], [class*=\"sort\"], [class*=\"facet\"]'),\n      repeatingSimilarElements: (() => {\n        const cards = doc.querySelectorAll('[class*=\"card\"], [class*=\"item\"]');\n        if (cards.length < 3) return false;\n        const classes = Array.from(cards).map(c => c.className);\n        const unique = new Set(classes);\n        return unique.size <= 3; // Similar classes = listing\n      })(),\n\n      // Detail signals\n      hasMainArticle: exists('article, main > [class*=\"content\"], [class*=\"detail\"]'),\n      hasLongContent: text.length > 2000,\n      hasSingleHeading: count('h1') === 1,\n      hasMetadata: exists('[class*=\"meta\"], [class*=\"author\"], [class*=\"date\"], time'),\n      hasComments: exists('[class*=\"comment\"], [id*=\"comment\"]'),\n      hasSocialShare: exists('[class*=\"share\"], [class*=\"social\"]'),\n\n      // Dashboard signals\n      hasCharts: exists('canvas, svg[class*=\"chart\"], [class*=\"chart\"], [class*=\"graph\"]'),\n      hasStats: exists('[class*=\"stat\"], [class*=\"metric\"], [class*=\"kpi\"]'),\n      hasSidebar: exists('aside, [class*=\"sidebar\"], nav[class*=\"side\"]'),\n      hasWidgets: exists('[class*=\"widget\"], [class*=\"panel\"], [class*=\"tile\"]'),\n      hasUserMenu: exists('[class*=\"user\"], [class*=\"avatar\"], [class*=\"profile\"]'),\n      hasNavTabs: exists('[role=\"tablist\"], [class*=\"tabs\"]'),\n\n      // Error signals\n      hasErrorCode: textContains(['404', '500', '403', '401', 'not found', 'error', 'denied', 'forbidden']),\n      hasErrorClass: exists('[class*=\"error\"], [class*=\"404\"], [class*=\"500\"]'),\n      isMinimalContent: text.length < 200,\n      hasBackLink: textContains(['go back', 'go home', 'return']),\n\n      // Landing signals\n      hasHero: exists('[class*=\"hero\"], [class*=\"banner\"], [class*=\"jumbotron\"]'),\n      hasCTA: exists('[class*=\"cta\"], [class*=\"call-to-action\"], a[class*=\"primary\"]'),\n      hasTestimonials: exists('[class*=\"testimonial\"], [class*=\"review\"], [class*=\"quote\"]'),\n      hasPricing: exists('[class*=\"pricing\"], [class*=\"plan\"]'),\n      hasFeatures: exists('[class*=\"feature\"], [class*=\"benefit\"]'),\n\n      // Empty signals\n      hasEmptyState: exists('[class*=\"empty\"], [class*=\"no-data\"], [class*=\"no-results\"]'),\n      hasEmptyText: textContains(['no results', 'nothing here', 'no items', 'empty']),\n\n      // General metrics\n      totalElements: count('*'),\n      interactiveElements: count('a, button, input, select, textarea'),\n    };\n  });\n\n  // Score auth intent\n  if (checks.hasPasswordField) {\n    scores.auth += 40;\n    signals.push('password field present');\n  }\n  if (checks.hasEmailField && checks.hasPasswordField) {\n    scores.auth += 20;\n    signals.push('email + password combination');\n  }\n  if (checks.hasLoginText) {\n    scores.auth += 15;\n    signals.push('login-related text');\n  }\n  if (checks.hasRememberMe) {\n    scores.auth += 10;\n    signals.push('remember me checkbox');\n  }\n  if (checks.hasOAuthButtons) {\n    scores.auth += 10;\n    signals.push('OAuth buttons');\n  }\n\n  // Score form intent (but not auth)\n  if (checks.formCount > 0 && !checks.hasPasswordField) {\n    scores.form += 20;\n    signals.push('form without password');\n  }\n  if (checks.inputCount > 3 && !checks.hasPasswordField) {\n    scores.form += 15;\n    signals.push('multiple input fields');\n  }\n  if (checks.textareaCount > 0) {\n    scores.form += 15;\n    signals.push('textarea present');\n  }\n  if (checks.hasFormLabels && checks.inputCount > 2) {\n    scores.form += 10;\n    signals.push('labeled form fields');\n  }\n\n  // Score listing intent\n  if (checks.listItemCount > 5) {\n    scores.listing += 25;\n    signals.push(`${checks.listItemCount} list items`);\n  }\n  if (checks.hasGrid) {\n    scores.listing += 15;\n    signals.push('grid/list layout');\n  }\n  if (checks.hasTable) {\n    scores.listing += 20;\n    signals.push('data table');\n  }\n  if (checks.hasPagination) {\n    scores.listing += 20;\n    signals.push('pagination');\n  }\n  if (checks.hasFilters) {\n    scores.listing += 15;\n    signals.push('filters/sorting');\n  }\n  if (checks.repeatingSimilarElements) {\n    scores.listing += 15;\n    signals.push('repeating card elements');\n  }\n\n  // Score detail intent\n  if (checks.hasMainArticle) {\n    scores.detail += 25;\n    signals.push('main article element');\n  }\n  if (checks.hasLongContent) {\n    scores.detail += 20;\n    signals.push('long content');\n  }\n  if (checks.hasSingleHeading && checks.hasMetadata) {\n    scores.detail += 20;\n    signals.push('single heading with metadata');\n  }\n  if (checks.hasComments) {\n    scores.detail += 15;\n    signals.push('comments section');\n  }\n  if (checks.hasSocialShare) {\n    scores.detail += 10;\n    signals.push('social share buttons');\n  }\n\n  // Score dashboard intent\n  if (checks.hasCharts) {\n    scores.dashboard += 30;\n    signals.push('charts/graphs');\n  }\n  if (checks.hasStats) {\n    scores.dashboard += 25;\n    signals.push('stats/metrics');\n  }\n  if (checks.hasSidebar && checks.hasWidgets) {\n    scores.dashboard += 20;\n    signals.push('sidebar with widgets');\n  }\n  if (checks.hasNavTabs) {\n    scores.dashboard += 10;\n    signals.push('navigation tabs');\n  }\n  if (checks.hasUserMenu) {\n    scores.dashboard += 10;\n    signals.push('user menu');\n  }\n\n  // Score error intent\n  if (checks.hasErrorCode && checks.isMinimalContent) {\n    scores.error += 50;\n    signals.push('error code with minimal content');\n  }\n  if (checks.hasErrorClass) {\n    scores.error += 30;\n    signals.push('error CSS class');\n  }\n  if (checks.hasBackLink && checks.isMinimalContent) {\n    scores.error += 20;\n    signals.push('back link on minimal page');\n  }\n\n  // Score landing intent\n  if (checks.hasHero) {\n    scores.landing += 25;\n    signals.push('hero section');\n  }\n  if (checks.hasCTA) {\n    scores.landing += 20;\n    signals.push('call-to-action');\n  }\n  if (checks.hasTestimonials) {\n    scores.landing += 15;\n    signals.push('testimonials');\n  }\n  if (checks.hasPricing) {\n    scores.landing += 20;\n    signals.push('pricing section');\n  }\n  if (checks.hasFeatures) {\n    scores.landing += 15;\n    signals.push('features section');\n  }\n\n  // Score empty intent\n  if (checks.hasEmptyState) {\n    scores.empty += 40;\n    signals.push('empty state element');\n  }\n  if (checks.hasEmptyText && checks.listItemCount === 0) {\n    scores.empty += 30;\n    signals.push('empty text with no items');\n  }\n\n  // Find highest scoring intent\n  const entries = Object.entries(scores) as [PageIntent, number][];\n  entries.sort((a, b) => b[1] - a[1]);\n\n  const [topIntent, topScore] = entries[0];\n  const [secondIntent, secondScore] = entries[1];\n\n  // Calculate confidence (normalize to 0-1)\n  const maxPossible = 100;\n  const confidence = Math.min(topScore / maxPossible, 1);\n\n  // Determine if there's a secondary intent worth mentioning\n  const hasSecondary = secondScore > 30 && secondScore > topScore * 0.5;\n\n  return {\n    intent: topScore > 20 ? topIntent : 'unknown',\n    confidence,\n    signals: signals.slice(0, 5), // Top 5 signals\n    secondaryIntent: hasSecondary ? secondIntent : undefined,\n  };\n}\n\n/**\n * Get human-readable description of page intent\n */\nexport function getIntentDescription(intent: PageIntent): string {\n  const descriptions: Record<PageIntent, string> = {\n    auth: 'Authentication page (login, register, password reset)',\n    form: 'Form page (data entry, settings, contact)',\n    listing: 'Listing page (search results, product grid, table)',\n    detail: 'Detail page (article, product, profile)',\n    dashboard: 'Dashboard (admin panel, analytics, user home)',\n    error: 'Error page (404, 500, access denied)',\n    landing: 'Landing page (marketing, homepage)',\n    empty: 'Empty state (no content)',\n    unknown: 'Unknown page type',\n  };\n  return descriptions[intent];\n}\n","import { chromium, type Browser, type Page } from 'playwright';\nimport { mkdir } from 'fs/promises';\nimport { dirname } from 'path';\nimport { VIEWPORTS, type Viewport, type LandmarkElement } from './schemas.js';\nimport type { CaptureOptions, MaskOptions } from './types.js';\nimport { DEFAULT_DYNAMIC_SELECTORS } from './types.js';\nimport { loadAuthState, isDeployedEnvironment } from './auth.js';\nimport { detectLandmarks } from './semantic/landmarks.js';\nimport { classifyPageIntent, type PageIntent } from './semantic/page-intent.js';\n\n/**\n * Apply dynamic content masking to a page before screenshot\n */\nasync function applyMasking(page: Page, mask?: MaskOptions): Promise<void> {\n  // Default: always disable animations\n  const hideAnimations = mask?.hideAnimations !== false;\n\n  // Build list of selectors to hide\n  const selectorsToHide: string[] = [];\n\n  // Add user-specified selectors\n  if (mask?.selectors) {\n    selectorsToHide.push(...mask.selectors);\n  }\n\n  // Add default dynamic selectors if enabled\n  if (mask?.hideDynamicContent) {\n    selectorsToHide.push(...DEFAULT_DYNAMIC_SELECTORS);\n  }\n\n  // Build CSS rules\n  const cssRules: string[] = [];\n\n  // Animation/transition disabling\n  if (hideAnimations) {\n    cssRules.push(`\n      *, *::before, *::after {\n        animation-duration: 0s !important;\n        animation-delay: 0s !important;\n        transition-duration: 0s !important;\n        transition-delay: 0s !important;\n        scroll-behavior: auto !important;\n      }\n      @keyframes none { }\n    `);\n  }\n\n  // Hide specified elements\n  if (selectorsToHide.length > 0) {\n    const selectorList = selectorsToHide.join(',\\n');\n    cssRules.push(`\n      ${selectorList} {\n        visibility: hidden !important;\n        opacity: 0 !important;\n      }\n    `);\n  }\n\n  // Inject CSS\n  if (cssRules.length > 0) {\n    await page.addStyleTag({\n      content: cssRules.join('\\n'),\n    });\n  }\n\n  // Apply text pattern masking via JavaScript\n  if (mask?.textPatterns && mask.textPatterns.length > 0) {\n    const placeholder = mask.placeholder || '‚ñà‚ñà‚ñà';\n    const patterns = mask.textPatterns.map(p =>\n      typeof p === 'string' ? p : p.source\n    );\n\n    await page.evaluate(({ patterns, placeholder }) => {\n      const walker = document.createTreeWalker(\n        document.body,\n        NodeFilter.SHOW_TEXT,\n        null\n      );\n\n      const textNodes: Text[] = [];\n      let node: Text | null;\n      while ((node = walker.nextNode() as Text | null)) {\n        textNodes.push(node);\n      }\n\n      for (const textNode of textNodes) {\n        let text = textNode.textContent || '';\n        for (const pattern of patterns) {\n          const regex = new RegExp(pattern, 'gi');\n          text = text.replace(regex, placeholder);\n        }\n        if (text !== textNode.textContent) {\n          textNode.textContent = text;\n        }\n      }\n    }, { patterns, placeholder });\n  }\n}\n\n/**\n * Capture result with timing and diagnostic info\n */\nexport interface CaptureResult {\n  success: boolean;\n  outputPath?: string;\n  timing: {\n    navigationMs: number;\n    renderMs: number;\n    totalMs: number;\n  };\n  diagnostics: {\n    httpStatus?: number;\n    consoleErrors: string[];\n    networkErrors: string[];\n    suggestions: string[];\n  };\n  error?: {\n    type: 'timeout' | 'navigation' | 'screenshot' | 'unknown';\n    message: string;\n    suggestion: string;\n  };\n}\n\n// Playwright's storage state type\ntype StorageState = {\n  cookies: Array<{\n    name: string;\n    value: string;\n    domain: string;\n    path: string;\n    expires: number;\n    httpOnly: boolean;\n    secure: boolean;\n    sameSite: 'Strict' | 'Lax' | 'None';\n  }>;\n  origins: Array<{\n    origin: string;\n    localStorage: Array<{ name: string; value: string }>;\n  }>;\n};\n\nlet browser: Browser | null = null;\n\n/**\n * Get or create a browser instance\n */\nasync function getBrowser(): Promise<Browser> {\n  if (!browser) {\n    browser = await chromium.launch({\n      headless: true,\n    });\n  }\n  return browser;\n}\n\n/**\n * Close the browser instance\n */\nexport async function closeBrowser(): Promise<void> {\n  if (browser) {\n    await browser.close();\n    browser = null;\n  }\n}\n\n/**\n * Capture a screenshot of a URL\n */\nexport async function captureScreenshot(\n  options: CaptureOptions & { outputDir?: string }\n): Promise<string> {\n  const {\n    url,\n    outputPath,\n    viewport = VIEWPORTS.desktop,\n    fullPage = true,\n    waitForNetworkIdle = true,\n    timeout = 30000,\n    outputDir,\n    selector,\n    waitFor,\n  } = options;\n\n  // Ensure output directory exists\n  await mkdir(dirname(outputPath), { recursive: true });\n\n  // Load auth state if available (handles validation, expiration, user isolation)\n  let storageState: StorageState | undefined;\n  if (outputDir && !isDeployedEnvironment()) {\n    const authState = await loadAuthState(outputDir);\n    if (authState) {\n      storageState = authState as StorageState;\n      console.log('üîê Using saved authentication state');\n    }\n  }\n\n  const browserInstance = await getBrowser();\n  const context = await browserInstance.newContext({\n    viewport: {\n      width: viewport.width,\n      height: viewport.height,\n    },\n    // Disable animations for consistent screenshots\n    reducedMotion: 'reduce',\n    // Load auth state if available (Playwright accepts object or file path)\n    ...(storageState ? { storageState } : {}),\n  });\n\n  const page = await context.newPage();\n\n  try {\n    // Navigate to URL\n    await page.goto(url, {\n      waitUntil: waitForNetworkIdle ? 'networkidle' : 'load',\n      timeout,\n    });\n\n    // Wait for specific selector if provided (for dynamic content)\n    if (waitFor) {\n      await page.waitForSelector(waitFor, { timeout });\n    }\n\n    // Wait for any remaining animations to settle\n    await page.waitForTimeout(500);\n\n    // Apply dynamic content masking (includes animation disabling)\n    await applyMasking(page, options.mask);\n\n    // Take screenshot - element or full page\n    if (selector) {\n      // Wait for element and capture just that element\n      const element = await page.waitForSelector(selector, { timeout: 5000 });\n      if (!element) {\n        throw new Error(`Element not found: ${selector}`);\n      }\n      await element.screenshot({\n        path: outputPath,\n        type: 'png',\n      });\n    } else {\n      await page.screenshot({\n        path: outputPath,\n        fullPage,\n        type: 'png',\n      });\n    }\n\n    return outputPath;\n  } finally {\n    await context.close();\n  }\n}\n\n/**\n * Capture result with landmark detection\n */\nexport interface CaptureWithLandmarksResult {\n  outputPath: string;\n  landmarkElements: LandmarkElement[];\n  pageIntent: PageIntent;\n}\n\n/**\n * Capture a screenshot and detect landmark elements\n * Used during baseline capture to store expected elements\n */\nexport async function captureWithLandmarks(\n  options: CaptureOptions & { outputDir?: string }\n): Promise<CaptureWithLandmarksResult> {\n  const {\n    url,\n    outputPath,\n    viewport = VIEWPORTS.desktop,\n    fullPage = true,\n    waitForNetworkIdle = true,\n    timeout = 30000,\n    outputDir,\n    selector,\n    waitFor,\n  } = options;\n\n  // Ensure output directory exists\n  await mkdir(dirname(outputPath), { recursive: true });\n\n  // Load auth state if available\n  let storageState: StorageState | undefined;\n  if (outputDir && !isDeployedEnvironment()) {\n    const authState = await loadAuthState(outputDir);\n    if (authState) {\n      storageState = authState as StorageState;\n      console.log('üîê Using saved authentication state');\n    }\n  }\n\n  const browserInstance = await getBrowser();\n  const context = await browserInstance.newContext({\n    viewport: {\n      width: viewport.width,\n      height: viewport.height,\n    },\n    reducedMotion: 'reduce',\n    ...(storageState ? { storageState } : {}),\n  });\n\n  const page = await context.newPage();\n\n  try {\n    // Navigate to URL\n    await page.goto(url, {\n      waitUntil: waitForNetworkIdle ? 'networkidle' : 'load',\n      timeout,\n    });\n\n    // Wait for specific selector if provided\n    if (waitFor) {\n      await page.waitForSelector(waitFor, { timeout });\n    }\n\n    // Wait for animations to settle\n    await page.waitForTimeout(500);\n\n    // Detect page intent and landmarks while page is still open\n    const intentResult = await classifyPageIntent(page);\n    const landmarkElements = await detectLandmarks(page);\n\n    // Apply dynamic content masking (includes animation disabling)\n    await applyMasking(page, options.mask);\n\n    // Take screenshot\n    if (selector) {\n      const element = await page.waitForSelector(selector, { timeout: 5000 });\n      if (!element) {\n        throw new Error(`Element not found: ${selector}`);\n      }\n      await element.screenshot({\n        path: outputPath,\n        type: 'png',\n      });\n    } else {\n      await page.screenshot({\n        path: outputPath,\n        fullPage,\n        type: 'png',\n      });\n    }\n\n    return {\n      outputPath,\n      landmarkElements,\n      pageIntent: intentResult.intent,\n    };\n  } finally {\n    await context.close();\n  }\n}\n\n/**\n * Get viewport dimensions by name\n */\nexport function getViewport(name: 'desktop' | 'mobile' | 'tablet'): Viewport {\n  return VIEWPORTS[name];\n}\n\n/**\n * Capture multiple viewports\n */\nexport async function captureMultipleViewports(\n  url: string,\n  outputDir: string,\n  viewports: Array<'desktop' | 'mobile' | 'tablet'> = ['desktop'],\n  options: Omit<CaptureOptions, 'url' | 'outputPath' | 'viewport'> = {}\n): Promise<Record<string, string>> {\n  const results: Record<string, string> = {};\n\n  for (const viewportName of viewports) {\n    const viewport = getViewport(viewportName);\n    const outputPath = `${outputDir}/${viewportName}.png`;\n\n    await captureScreenshot({\n      url,\n      outputPath,\n      viewport,\n      ...options,\n    });\n\n    results[viewportName] = outputPath;\n  }\n\n  return results;\n}\n\n/**\n * Enhanced capture with detailed timing and diagnostics\n * Returns actionable info for debugging slow loads or errors\n */\nexport async function captureWithDiagnostics(\n  options: CaptureOptions & { outputDir?: string }\n): Promise<CaptureResult> {\n  const {\n    url,\n    outputPath,\n    viewport = VIEWPORTS.desktop,\n    fullPage = true,\n    waitForNetworkIdle = true,\n    timeout = 30000,\n    outputDir,\n    selector,\n  } = options;\n\n  const startTime = Date.now();\n  let navigationTime = 0;\n  let renderTime = 0;\n\n  const consoleErrors: string[] = [];\n  const networkErrors: string[] = [];\n  const suggestions: string[] = [];\n  let httpStatus: number | undefined;\n\n  try {\n    // Ensure output directory exists\n    await mkdir(dirname(outputPath), { recursive: true });\n\n    // Load auth state if available\n    let storageState: StorageState | undefined;\n    if (outputDir && !isDeployedEnvironment()) {\n      const authState = await loadAuthState(outputDir);\n      if (authState) {\n        storageState = authState as StorageState;\n      }\n    }\n\n    const browserInstance = await getBrowser();\n    const context = await browserInstance.newContext({\n      viewport: {\n        width: viewport.width,\n        height: viewport.height,\n      },\n      reducedMotion: 'reduce',\n      ...(storageState ? { storageState } : {}),\n    });\n\n    const page = await context.newPage();\n\n    // Collect console errors\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        consoleErrors.push(msg.text());\n      }\n    });\n\n    // Collect network errors\n    page.on('requestfailed', request => {\n      const failure = request.failure();\n      networkErrors.push(`${request.url()}: ${failure?.errorText || 'failed'}`);\n    });\n\n    // Track HTTP status\n    page.on('response', response => {\n      if (response.url() === url || response.url() === url + '/') {\n        httpStatus = response.status();\n      }\n    });\n\n    try {\n      const navStart = Date.now();\n      await page.goto(url, {\n        waitUntil: waitForNetworkIdle ? 'networkidle' : 'load',\n        timeout,\n      });\n      navigationTime = Date.now() - navStart;\n    } catch (navError) {\n      await context.close();\n\n      const errorMsg = navError instanceof Error ? navError.message : String(navError);\n      const isTimeout = errorMsg.includes('Timeout');\n\n      // Generate helpful suggestions\n      if (isTimeout) {\n        suggestions.push(`Page took longer than ${timeout}ms to load`);\n        suggestions.push('Try increasing timeout: --timeout 60000');\n        if (waitForNetworkIdle) {\n          suggestions.push('Try disabling network idle wait: use \"load\" instead of \"networkidle\"');\n        }\n      }\n      if (networkErrors.length > 0) {\n        suggestions.push(`${networkErrors.length} network request(s) failed`);\n      }\n      if (httpStatus && httpStatus >= 400) {\n        suggestions.push(`Server returned HTTP ${httpStatus}`);\n      }\n\n      return {\n        success: false,\n        timing: {\n          navigationMs: Date.now() - startTime,\n          renderMs: 0,\n          totalMs: Date.now() - startTime,\n        },\n        diagnostics: {\n          httpStatus,\n          consoleErrors,\n          networkErrors,\n          suggestions,\n        },\n        error: {\n          type: isTimeout ? 'timeout' : 'navigation',\n          message: errorMsg,\n          suggestion: isTimeout\n            ? `Increase timeout or check if ${url} is responding`\n            : `Check if the server is running at ${url}`,\n        },\n      };\n    }\n\n    // Wait for animations to settle\n    await page.waitForTimeout(500);\n\n    // Apply dynamic content masking (includes animation disabling)\n    await applyMasking(page, options.mask);\n\n    // Take screenshot - element or full page\n    const renderStart = Date.now();\n    if (selector) {\n      const element = await page.waitForSelector(selector, { timeout: 5000 });\n      if (!element) {\n        throw new Error(`Element not found: ${selector}`);\n      }\n      await element.screenshot({\n        path: outputPath,\n        type: 'png',\n      });\n    } else {\n      await page.screenshot({\n        path: outputPath,\n        fullPage,\n        type: 'png',\n      });\n    }\n    renderTime = Date.now() - renderStart;\n\n    await context.close();\n\n    // Generate performance suggestions\n    if (navigationTime > 5000) {\n      suggestions.push(`Slow page load: ${(navigationTime / 1000).toFixed(1)}s`);\n    }\n    if (consoleErrors.length > 0) {\n      suggestions.push(`${consoleErrors.length} JavaScript error(s) detected`);\n    }\n\n    return {\n      success: true,\n      outputPath,\n      timing: {\n        navigationMs: navigationTime,\n        renderMs: renderTime,\n        totalMs: Date.now() - startTime,\n      },\n      diagnostics: {\n        httpStatus,\n        consoleErrors,\n        networkErrors,\n        suggestions,\n      },\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n\n    return {\n      success: false,\n      timing: {\n        navigationMs: navigationTime,\n        renderMs: renderTime,\n        totalMs: Date.now() - startTime,\n      },\n      diagnostics: {\n        httpStatus,\n        consoleErrors,\n        networkErrors,\n        suggestions,\n      },\n      error: {\n        type: 'unknown',\n        message: errorMsg,\n        suggestion: 'Check browser installation: npx playwright install chromium',\n      },\n    };\n  }\n}\n","import pixelmatch from 'pixelmatch';\nimport { PNG } from 'pngjs';\nimport { readFile, writeFile, mkdir } from 'fs/promises';\nimport { dirname } from 'path';\nimport type { CompareOptions } from './types.js';\nimport type { ComparisonResult, Analysis, ChangedRegion, Verdict } from './schemas.js';\n\n/**\n * Region detection configuration\n * Divides page into semantic regions based on common layout patterns\n */\ninterface RegionConfig {\n  name: string;\n  location: 'top' | 'bottom' | 'left' | 'right' | 'center' | 'full';\n  // Percentages of page dimensions\n  xStart: number;  // 0-1\n  xEnd: number;    // 0-1\n  yStart: number;  // 0-1\n  yEnd: number;    // 0-1\n}\n\n/**\n * Default regions based on common web layouts\n * Header (top 10%), Footer (bottom 10%), Left sidebar (left 20%), Content (center)\n */\nconst DEFAULT_REGIONS: RegionConfig[] = [\n  { name: 'header', location: 'top', xStart: 0, xEnd: 1, yStart: 0, yEnd: 0.1 },\n  { name: 'navigation', location: 'left', xStart: 0, xEnd: 0.2, yStart: 0.1, yEnd: 0.9 },\n  { name: 'content', location: 'center', xStart: 0.2, xEnd: 1, yStart: 0.1, yEnd: 0.9 },\n  { name: 'footer', location: 'bottom', xStart: 0, xEnd: 1, yStart: 0.9, yEnd: 1 },\n];\n\n/**\n * Analyze diff image to detect which regions have changes\n */\nexport function detectChangedRegions(\n  diffData: Uint8Array,\n  width: number,\n  height: number,\n  regions: RegionConfig[] = DEFAULT_REGIONS\n): ChangedRegion[] {\n  const changedRegions: ChangedRegion[] = [];\n\n  for (const region of regions) {\n    // Calculate pixel bounds\n    const xStart = Math.floor(region.xStart * width);\n    const xEnd = Math.floor(region.xEnd * width);\n    const yStart = Math.floor(region.yStart * height);\n    const yEnd = Math.floor(region.yEnd * height);\n\n    const regionWidth = xEnd - xStart;\n    const regionHeight = yEnd - yStart;\n    const regionPixels = regionWidth * regionHeight;\n\n    if (regionPixels === 0) continue;\n\n    // Count red pixels (diff color) in this region\n    let diffPixels = 0;\n\n    for (let y = yStart; y < yEnd; y++) {\n      for (let x = xStart; x < xEnd; x++) {\n        const idx = (y * width + x) * 4;\n        // Check if pixel is red (diff marker from pixelmatch)\n        // pixelmatch uses [255, 0, 0] for differences\n        if (diffData[idx] === 255 && diffData[idx + 1] === 0 && diffData[idx + 2] === 0) {\n          diffPixels++;\n        }\n      }\n    }\n\n    const diffPercent = (diffPixels / regionPixels) * 100;\n\n    // Only report regions with >0.1% changes\n    if (diffPercent > 0.1) {\n      const severity = diffPercent > 30 ? 'critical' :\n                       diffPercent > 10 ? 'unexpected' : 'expected';\n\n      changedRegions.push({\n        location: region.location,\n        bounds: {\n          x: xStart,\n          y: yStart,\n          width: regionWidth,\n          height: regionHeight,\n        },\n        description: `${region.name}: ${diffPercent.toFixed(1)}% changed`,\n        severity,\n      });\n    }\n  }\n\n  // Sort by severity (critical first) then by diff percentage\n  return changedRegions.sort((a, b) => {\n    const severityOrder = { critical: 0, unexpected: 1, expected: 2 };\n    const aSev = severityOrder[a.severity];\n    const bSev = severityOrder[b.severity];\n    if (aSev !== bSev) return aSev - bSev;\n\n    // Parse percentage from description for secondary sort\n    const aPercent = parseFloat(a.description.match(/(\\d+\\.?\\d*)%/)?.[1] || '0');\n    const bPercent = parseFloat(b.description.match(/(\\d+\\.?\\d*)%/)?.[1] || '0');\n    return bPercent - aPercent;\n  });\n}\n\n/**\n * Extended comparison result with diff image data for regional analysis\n */\nexport interface ExtendedComparisonResult extends ComparisonResult {\n  diffData?: Uint8Array;\n  width?: number;\n  height?: number;\n}\n\n/**\n * Compare two images using pixelmatch\n */\nexport async function compareImages(options: CompareOptions): Promise<ExtendedComparisonResult> {\n  const {\n    baselinePath,\n    currentPath,\n    diffPath,\n    threshold = 0.1, // pixelmatch threshold (0-1), lower = stricter\n  } = options;\n\n  // Read images\n  const [baselineBuffer, currentBuffer] = await Promise.all([\n    readFile(baselinePath),\n    readFile(currentPath),\n  ]);\n\n  const baseline = PNG.sync.read(baselineBuffer);\n  const current = PNG.sync.read(currentBuffer);\n\n  // Ensure images have same dimensions\n  if (baseline.width !== current.width || baseline.height !== current.height) {\n    throw new Error(\n      `Image dimensions mismatch: baseline (${baseline.width}x${baseline.height}) vs current (${current.width}x${current.height})`\n    );\n  }\n\n  const { width, height } = baseline;\n  const diff = new PNG({ width, height });\n  const totalPixels = width * height;\n\n  // Run pixelmatch\n  const diffPixels = pixelmatch(\n    baseline.data,\n    current.data,\n    diff.data,\n    width,\n    height,\n    {\n      threshold,\n      includeAA: false, // Ignore anti-aliasing differences\n      alpha: 0.1,\n      diffColor: [255, 0, 0], // Red for differences\n      diffColorAlt: [0, 255, 0], // Green for anti-aliased differences\n    }\n  );\n\n  // Ensure output directory exists\n  await mkdir(dirname(diffPath), { recursive: true });\n\n  // Write diff image\n  await writeFile(diffPath, PNG.sync.write(diff));\n\n  const diffPercent = (diffPixels / totalPixels) * 100;\n\n  return {\n    match: diffPixels === 0,\n    diffPercent: Math.round(diffPercent * 100) / 100, // Round to 2 decimal places\n    diffPixels,\n    totalPixels,\n    threshold,\n    // Include diff data for regional analysis\n    diffData: diff.data,\n    width,\n    height,\n  };\n}\n\n/**\n * Analyze comparison result and generate verdict with regional analysis\n */\nexport function analyzeComparison(\n  result: ExtendedComparisonResult,\n  thresholdPercent: number = 1.0\n): Analysis {\n  const { match, diffPercent, diffData, width, height } = result;\n\n  // Detect changed regions if diff data is available\n  let detectedRegions: ChangedRegion[] = [];\n  if (diffData && width && height && !match) {\n    detectedRegions = detectChangedRegions(diffData, width, height);\n  }\n\n  // Analyze regions for verdict determination\n  const criticalRegions = detectedRegions.filter(r => r.severity === 'critical');\n  const unexpectedRegions = detectedRegions.filter(r => r.severity === 'unexpected');\n  const hasNavigationChanges = detectedRegions.some(r =>\n    r.description.toLowerCase().includes('navigation') ||\n    r.description.toLowerCase().includes('header')\n  );\n\n  // Determine verdict based on regions and overall diff\n  let verdict: Verdict;\n  let summary: string;\n  let recommendation: string | null = null;\n\n  if (match || diffPercent === 0) {\n    verdict = 'MATCH';\n    summary = 'No visual changes detected. Screenshots are identical.';\n  } else if (criticalRegions.length > 0) {\n    verdict = 'LAYOUT_BROKEN';\n    const regionNames = criticalRegions.map(r =>\n      r.description.split(':')[0]\n    ).join(', ');\n    summary = `Critical changes in: ${regionNames}. Layout may be broken.`;\n    recommendation = `Major changes detected in ${regionNames}. Check for missing elements, broken layout, or loading errors.`;\n  } else if (unexpectedRegions.length > 0 || diffPercent > 20) {\n    verdict = 'UNEXPECTED_CHANGE';\n    const regionNames = unexpectedRegions.length > 0\n      ? unexpectedRegions.map(r => r.description.split(':')[0]).join(', ')\n      : 'multiple areas';\n    summary = `Significant changes in: ${regionNames} (${diffPercent}% overall).`;\n    recommendation = hasNavigationChanges\n      ? 'Navigation area changed - verify menu items and links are correct.'\n      : 'Review changes carefully - some may be unintentional.';\n  } else if (diffPercent <= thresholdPercent) {\n    verdict = 'EXPECTED_CHANGE';\n    summary = `Minor changes detected (${diffPercent}%). Within acceptable threshold.`;\n  } else {\n    verdict = 'EXPECTED_CHANGE';\n    const regionNames = detectedRegions.length > 0\n      ? detectedRegions.map(r => r.description.split(':')[0]).join(', ')\n      : 'content area';\n    summary = `Changes in: ${regionNames} (${diffPercent}% overall). Changes appear intentional.`;\n  }\n\n  // Separate expected vs unexpected changes\n  const changedRegions = detectedRegions.filter(r => r.severity === 'expected');\n  const unexpectedChanges = detectedRegions.filter(r =>\n    r.severity === 'unexpected' || r.severity === 'critical'\n  );\n\n  // If no regions detected but there are changes, create a fallback region\n  if (detectedRegions.length === 0 && !match) {\n    const fallbackRegion: ChangedRegion = {\n      location: diffPercent > 50 ? 'full' : 'center',\n      bounds: { x: 0, y: 0, width: width || 0, height: height || 0 },\n      description: `overall: ${diffPercent}% changed`,\n      severity: verdict === 'LAYOUT_BROKEN' ? 'critical' :\n                verdict === 'UNEXPECTED_CHANGE' ? 'unexpected' : 'expected',\n    };\n\n    if (verdict === 'UNEXPECTED_CHANGE' || verdict === 'LAYOUT_BROKEN') {\n      unexpectedChanges.push(fallbackRegion);\n    } else {\n      changedRegions.push(fallbackRegion);\n    }\n  }\n\n  return {\n    verdict,\n    summary,\n    changedRegions,\n    unexpectedChanges,\n    recommendation,\n  };\n}\n\n/**\n * Get a human-readable verdict description\n */\nexport function getVerdictDescription(verdict: Verdict): string {\n  switch (verdict) {\n    case 'MATCH':\n      return 'No changes - screenshots match';\n    case 'EXPECTED_CHANGE':\n      return 'Changes detected - appear intentional';\n    case 'UNEXPECTED_CHANGE':\n      return 'Unexpected changes - review required';\n    case 'LAYOUT_BROKEN':\n      return 'Layout broken - significant issues detected';\n    default:\n      return 'Unknown verdict';\n  }\n}\n","/**\n * Git repository context detection for organizing sessions by app and branch\n *\n * This module provides utilities to detect git repository information and combine it\n * with package.json metadata to create organized session storage paths.\n *\n * @example\n * ```typescript\n * const context = await getAppContext(process.cwd());\n * const sessionPath = getSessionBasePath('.ibr', context);\n * // Returns: .ibr/apps/my-app/main/sessions (if git context available)\n * //      or: .ibr/sessions (fallback for non-git projects)\n * ```\n */\n\nimport { readFile } from 'fs/promises';\nimport { join, basename } from 'path';\nimport { execSync } from 'child_process';\n\n/**\n * Git repository context information\n */\nexport interface GitContext {\n  /** Repository name (e.g., \"interface-built-right\") */\n  repoName: string | null;\n  /** Current branch name (e.g., \"main\", \"feature-xyz\") */\n  branch: string | null;\n  /** Remote name (e.g., \"origin\") */\n  remote: string | null;\n  /** Remote URL (e.g., \"git@github.com:user/repo.git\") */\n  remoteUrl: string | null;\n}\n\n/**\n * Application context combining git and package.json info\n */\nexport interface AppContext extends GitContext {\n  /** Application name from package.json */\n  appName: string;\n}\n\n/**\n * Parse git config file to extract remote information\n */\nasync function parseGitConfig(configPath: string): Promise<{ remote: string | null; remoteUrl: string | null }> {\n  try {\n    const content = await readFile(configPath, 'utf-8');\n    const lines = content.split('\\n');\n\n    let currentRemote: string | null = null;\n    let remoteUrl: string | null = null;\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n\n      // Match [remote \"origin\"] pattern\n      const remoteMatch = trimmed.match(/^\\[remote \"(.+)\"\\]$/);\n      if (remoteMatch) {\n        currentRemote = remoteMatch[1];\n        continue;\n      }\n\n      // Match url = ... pattern\n      if (currentRemote && trimmed.startsWith('url = ')) {\n        remoteUrl = trimmed.substring(6).trim();\n        break; // Use first remote found (typically \"origin\")\n      }\n    }\n\n    return { remote: currentRemote, remoteUrl };\n  } catch {\n    return { remote: null, remoteUrl: null };\n  }\n}\n\n/**\n * Extract repository name from remote URL\n */\nfunction extractRepoName(remoteUrl: string): string | null {\n  try {\n    // Handle SSH format: git@github.com:user/repo.git\n    const sshMatch = remoteUrl.match(/[:/]([^/]+\\/[^/]+?)(?:\\.git)?$/);\n    if (sshMatch) {\n      const parts = sshMatch[1].split('/');\n      return parts[parts.length - 1].replace(/\\.git$/, '');\n    }\n\n    // Handle HTTPS format: https://github.com/user/repo.git\n    const httpsMatch = remoteUrl.match(/\\/([^/]+?)(?:\\.git)?$/);\n    if (httpsMatch) {\n      return httpsMatch[1].replace(/\\.git$/, '');\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get current git branch using git command\n */\nfunction getCurrentBranch(dir: string): string | null {\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf-8',\n      stdio: ['ignore', 'pipe', 'ignore'],\n    }).trim();\n\n    return branch || null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get git context from directory\n * Detects git repository information including repo name, branch, and remote\n */\nexport async function getGitContext(dir: string): Promise<GitContext> {\n  const gitConfigPath = join(dir, '.git', 'config');\n\n  // Parse git config for remote info\n  const { remote, remoteUrl } = await parseGitConfig(gitConfigPath);\n\n  // Extract repo name from remote URL\n  const repoName = remoteUrl ? extractRepoName(remoteUrl) : null;\n\n  // Get current branch\n  const branch = getCurrentBranch(dir);\n\n  return {\n    repoName,\n    branch,\n    remote,\n    remoteUrl,\n  };\n}\n\n/**\n * Get app name from package.json\n * Falls back to directory name if package.json not found or has no name field\n */\nexport async function getAppName(dir: string): Promise<string> {\n  try {\n    const packageJsonPath = join(dir, 'package.json');\n    const content = await readFile(packageJsonPath, 'utf-8');\n    const packageJson = JSON.parse(content);\n\n    if (packageJson.name) {\n      // Remove scope if present (e.g., \"@tyroneross/package\" -> \"package\")\n      const name = packageJson.name;\n      const scopeMatch = name.match(/^@[^/]+\\/(.+)$/);\n      return scopeMatch ? scopeMatch[1] : name;\n    }\n  } catch {\n    // Fall through to directory name\n  }\n\n  // Fallback to directory name\n  return basename(dir);\n}\n\n/**\n * Get full app context (git + package.json)\n * Combines git repository information with application name\n */\nexport async function getAppContext(dir: string): Promise<AppContext> {\n  const [gitContext, appName] = await Promise.all([\n    getGitContext(dir),\n    getAppName(dir),\n  ]);\n\n  return {\n    ...gitContext,\n    appName,\n  };\n}\n\n/**\n * Compute session base path from context\n * Returns organized path: {outputDir}/apps/{appName}/{branch}/sessions/\n * Falls back to: {outputDir}/sessions/ for backward compatibility\n */\nexport function getSessionBasePath(outputDir: string, context: AppContext): string {\n  // If we have git context (repo name and branch), use organized structure\n  if (context.repoName && context.branch) {\n    return join(outputDir, 'apps', context.appName, context.branch, 'sessions');\n  }\n\n  // Fallback to flat structure for backward compatibility\n  return join(outputDir, 'sessions');\n}\n","import { nanoid } from 'nanoid';\nimport { mkdir, readFile, writeFile, readdir, rm } from 'fs/promises';\nimport { join } from 'path';\nimport { SessionSchema, SessionQuerySchema, type Session, type SessionQuery, type Viewport, type ComparisonResult, type Analysis } from './schemas.js';\nimport type { SessionPaths, CleanOptions } from './types.js';\nimport { getAppContext, getSessionBasePath, type AppContext } from './git-context.js';\n\nconst SESSION_PREFIX = 'sess_';\n\n/**\n * Generate a unique session ID\n */\nexport function generateSessionId(): string {\n  return `${SESSION_PREFIX}${nanoid(10)}`;\n}\n\n/**\n * Get paths for a session (legacy flat structure)\n */\nexport function getSessionPaths(outputDir: string, sessionId: string): SessionPaths {\n  const root = join(outputDir, 'sessions', sessionId);\n  return {\n    root,\n    sessionJson: join(root, 'session.json'),\n    baseline: join(root, 'baseline.png'),\n    current: join(root, 'current.png'),\n    diff: join(root, 'diff.png'),\n  };\n}\n\n/**\n * Get paths for a session with git context awareness\n * Uses: .ibr/apps/{appName}/{branch}/sessions/{sessionId}/\n * Falls back to flat structure for non-git projects\n */\nexport function getSessionPathsWithContext(\n  outputDir: string,\n  sessionId: string,\n  context: AppContext | null\n): SessionPaths {\n  const basePath = context\n    ? getSessionBasePath(outputDir, context)\n    : join(outputDir, 'sessions');\n\n  const root = join(basePath, sessionId);\n  return {\n    root,\n    sessionJson: join(root, 'session.json'),\n    baseline: join(root, 'baseline.png'),\n    current: join(root, 'current.png'),\n    diff: join(root, 'diff.png'),\n  };\n}\n\n// Cached app context to avoid repeated git lookups\nlet cachedContext: AppContext | null = null;\nlet contextCacheDir: string | null = null;\n\n/**\n * Get cached app context for current directory\n */\nexport async function getCachedAppContext(projectDir: string): Promise<AppContext | null> {\n  if (contextCacheDir === projectDir && cachedContext !== null) {\n    return cachedContext;\n  }\n\n  try {\n    cachedContext = await getAppContext(projectDir);\n    contextCacheDir = projectDir;\n    return cachedContext;\n  } catch {\n    cachedContext = null;\n    contextCacheDir = projectDir;\n    return null;\n  }\n}\n\n/**\n * Create a new session\n */\nexport async function createSession(\n  outputDir: string,\n  url: string,\n  name: string,\n  viewport: Viewport\n): Promise<Session> {\n  const sessionId = generateSessionId();\n  const paths = getSessionPaths(outputDir, sessionId);\n  const now = new Date().toISOString();\n\n  const session: Session = {\n    id: sessionId,\n    name,\n    url,\n    viewport,\n    status: 'baseline',\n    createdAt: now,\n    updatedAt: now,\n  };\n\n  // Create session directory\n  await mkdir(paths.root, { recursive: true });\n\n  // Write session file\n  await writeFile(paths.sessionJson, JSON.stringify(session, null, 2));\n\n  return session;\n}\n\n/**\n * Get a session by ID\n */\nexport async function getSession(outputDir: string, sessionId: string): Promise<Session | null> {\n  const paths = getSessionPaths(outputDir, sessionId);\n\n  try {\n    const content = await readFile(paths.sessionJson, 'utf-8');\n    const data = JSON.parse(content);\n    return SessionSchema.parse(data);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Update a session\n */\nexport async function updateSession(\n  outputDir: string,\n  sessionId: string,\n  updates: Partial<Omit<Session, 'id' | 'createdAt'>>\n): Promise<Session> {\n  const session = await getSession(outputDir, sessionId);\n  if (!session) {\n    throw new Error(`Session not found: ${sessionId}`);\n  }\n\n  const updated: Session = {\n    ...session,\n    ...updates,\n    updatedAt: new Date().toISOString(),\n  };\n\n  const paths = getSessionPaths(outputDir, sessionId);\n  await writeFile(paths.sessionJson, JSON.stringify(updated, null, 2));\n\n  return updated;\n}\n\n/**\n * Mark session as compared with results\n */\nexport async function markSessionCompared(\n  outputDir: string,\n  sessionId: string,\n  comparison: ComparisonResult,\n  analysis: Analysis\n): Promise<Session> {\n  return updateSession(outputDir, sessionId, {\n    status: 'compared',\n    comparison,\n    analysis,\n  });\n}\n\n/**\n * List all sessions\n */\nexport async function listSessions(outputDir: string): Promise<Session[]> {\n  const sessionsDir = join(outputDir, 'sessions');\n\n  try {\n    const entries = await readdir(sessionsDir, { withFileTypes: true });\n    const sessions: Session[] = [];\n\n    for (const entry of entries) {\n      if (entry.isDirectory() && entry.name.startsWith(SESSION_PREFIX)) {\n        const session = await getSession(outputDir, entry.name);\n        if (session) {\n          sessions.push(session);\n        }\n      }\n    }\n\n    // Sort by creation date, newest first\n    return sessions.sort((a, b) =>\n      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\n    );\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get the most recent session\n */\nexport async function getMostRecentSession(outputDir: string): Promise<Session | null> {\n  const sessions = await listSessions(outputDir);\n  return sessions[0] || null;\n}\n\n/**\n * Delete a session\n */\nexport async function deleteSession(outputDir: string, sessionId: string): Promise<boolean> {\n  const paths = getSessionPaths(outputDir, sessionId);\n\n  try {\n    await rm(paths.root, { recursive: true, force: true });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Parse duration string to milliseconds\n */\nfunction parseDuration(duration: string): number {\n  const match = duration.match(/^(\\d+)(d|h|m|s)$/);\n  if (!match) {\n    throw new Error(`Invalid duration format: ${duration}. Use format like '7d', '24h', '30m', '60s'`);\n  }\n\n  const value = parseInt(match[1], 10);\n  const unit = match[2];\n\n  switch (unit) {\n    case 'd': return value * 24 * 60 * 60 * 1000;\n    case 'h': return value * 60 * 60 * 1000;\n    case 'm': return value * 60 * 1000;\n    case 's': return value * 1000;\n    default: return value * 1000;\n  }\n}\n\n/**\n * Clean old sessions\n */\nexport async function cleanSessions(\n  outputDir: string,\n  options: CleanOptions = {}\n): Promise<{ deleted: string[]; kept: string[] }> {\n  const { olderThan, keepLast = 0, dryRun = false } = options;\n  const sessions = await listSessions(outputDir);\n\n  const deleted: string[] = [];\n  const kept: string[] = [];\n\n  // Sessions to keep based on keepLast\n  const keepIds = new Set(sessions.slice(0, keepLast).map(s => s.id));\n\n  // Calculate cutoff time if olderThan is specified\n  const cutoffTime = olderThan\n    ? Date.now() - parseDuration(olderThan)\n    : 0;\n\n  for (const session of sessions) {\n    const sessionTime = new Date(session.createdAt).getTime();\n    const shouldDelete = !keepIds.has(session.id) &&\n      (olderThan ? sessionTime < cutoffTime : true);\n\n    if (shouldDelete && !keepIds.has(session.id)) {\n      if (!dryRun) {\n        await deleteSession(outputDir, session.id);\n      }\n      deleted.push(session.id);\n    } else {\n      kept.push(session.id);\n    }\n  }\n\n  return { deleted, kept };\n}\n\n/**\n * Find sessions matching query criteria\n */\nexport async function findSessions(\n  outputDir: string,\n  query: Partial<SessionQuery> = {}\n): Promise<Session[]> {\n  // Validate query with defaults\n  const validatedQuery = SessionQuerySchema.parse({\n    limit: 50,\n    ...query,\n  });\n\n  const allSessions = await listSessions(outputDir);\n  let filtered = allSessions;\n\n  // Filter by route (extract path from URL)\n  if (validatedQuery.route) {\n    const routePattern = validatedQuery.route.toLowerCase();\n    filtered = filtered.filter(s => {\n      try {\n        const urlPath = new URL(s.url).pathname.toLowerCase();\n        return urlPath.includes(routePattern) || urlPath === routePattern;\n      } catch {\n        return s.url.toLowerCase().includes(routePattern);\n      }\n    });\n  }\n\n  // Filter by URL (exact or partial match)\n  if (validatedQuery.url) {\n    const urlPattern = validatedQuery.url.toLowerCase();\n    filtered = filtered.filter(s => s.url.toLowerCase().includes(urlPattern));\n  }\n\n  // Filter by status\n  if (validatedQuery.status) {\n    filtered = filtered.filter(s => s.status === validatedQuery.status);\n  }\n\n  // Filter by name\n  if (validatedQuery.name) {\n    const namePattern = validatedQuery.name.toLowerCase();\n    filtered = filtered.filter(s => s.name.toLowerCase().includes(namePattern));\n  }\n\n  // Filter by viewport\n  if (validatedQuery.viewport) {\n    const viewportPattern = validatedQuery.viewport.toLowerCase();\n    filtered = filtered.filter(s => s.viewport.name.toLowerCase() === viewportPattern);\n  }\n\n  // Filter by date range\n  if (validatedQuery.createdAfter) {\n    const afterTime = validatedQuery.createdAfter.getTime();\n    filtered = filtered.filter(s => new Date(s.createdAt).getTime() >= afterTime);\n  }\n\n  if (validatedQuery.createdBefore) {\n    const beforeTime = validatedQuery.createdBefore.getTime();\n    filtered = filtered.filter(s => new Date(s.createdAt).getTime() <= beforeTime);\n  }\n\n  // Apply limit\n  return filtered.slice(0, validatedQuery.limit);\n}\n\n/**\n * Get timeline of sessions for a specific route/URL\n * Returns sessions in chronological order (oldest first) for tracking changes over time\n */\nexport async function getTimeline(\n  outputDir: string,\n  route: string,\n  limit: number = 10\n): Promise<Session[]> {\n  const sessions = await findSessions(outputDir, { route, limit });\n  // Reverse to get chronological order (oldest first)\n  return sessions.reverse();\n}\n\n/**\n * Get sessions grouped by route\n */\nexport async function getSessionsByRoute(\n  outputDir: string\n): Promise<Record<string, Session[]>> {\n  const allSessions = await listSessions(outputDir);\n  const byRoute: Record<string, Session[]> = {};\n\n  for (const session of allSessions) {\n    let route: string;\n    try {\n      route = new URL(session.url).pathname;\n    } catch {\n      route = session.url;\n    }\n\n    if (!byRoute[route]) {\n      byRoute[route] = [];\n    }\n    byRoute[route].push(session);\n  }\n\n  return byRoute;\n}\n\n/**\n * Get session statistics\n */\nexport async function getSessionStats(outputDir: string): Promise<{\n  total: number;\n  byStatus: Record<string, number>;\n  byViewport: Record<string, number>;\n  byVerdict: Record<string, number>;\n}> {\n  const sessions = await listSessions(outputDir);\n\n  const byStatus: Record<string, number> = {};\n  const byViewport: Record<string, number> = {};\n  const byVerdict: Record<string, number> = {};\n\n  for (const session of sessions) {\n    // Count by status\n    byStatus[session.status] = (byStatus[session.status] || 0) + 1;\n\n    // Count by viewport\n    const viewportName = session.viewport.name;\n    byViewport[viewportName] = (byViewport[viewportName] || 0) + 1;\n\n    // Count by verdict\n    if (session.analysis?.verdict) {\n      byVerdict[session.analysis.verdict] = (byVerdict[session.analysis.verdict] || 0) + 1;\n    }\n  }\n\n  return {\n    total: sessions.length,\n    byStatus,\n    byViewport,\n    byVerdict,\n  };\n}\n","/**\n * Page State Detection\n *\n * Detects authentication state, loading state, and errors on a page.\n * Provides AI agents with actionable state information.\n */\n\nimport type { Page } from 'playwright';\n\nexport interface AuthState {\n  authenticated: boolean | null; // null = can't determine\n  confidence: number;\n  signals: string[];\n  username?: string; // If we can extract it\n}\n\nexport interface LoadingState {\n  loading: boolean;\n  type: 'spinner' | 'skeleton' | 'progress' | 'lazy' | 'none';\n  elements: number; // Count of loading indicators\n}\n\nexport interface ErrorState {\n  hasErrors: boolean;\n  errors: ErrorInfo[];\n  severity: 'none' | 'warning' | 'error' | 'critical';\n}\n\nexport interface ErrorInfo {\n  type: 'validation' | 'api' | 'permission' | 'notfound' | 'server' | 'network' | 'unknown';\n  message: string;\n  element?: string; // Selector hint\n}\n\nexport interface PageState {\n  auth: AuthState;\n  loading: LoadingState;\n  errors: ErrorState;\n  ready: boolean; // True if page is ready for interaction\n}\n\n/**\n * Detect authentication state from page signals\n */\nexport async function detectAuthState(page: Page): Promise<AuthState> {\n  const signals: string[] = [];\n  let authenticated: boolean | null = null;\n  let confidence = 0;\n  let username: string | undefined;\n\n  const checks = await page.evaluate(() => {\n    const doc = document;\n    const text = doc.body?.innerText?.toLowerCase() || '';\n\n    // Authenticated signals\n    const logoutButton = doc.querySelector(\n      'button:has-text(\"logout\"), button:has-text(\"sign out\"), ' +\n      'a:has-text(\"logout\"), a:has-text(\"sign out\"), ' +\n      '[class*=\"logout\"], [data-testid*=\"logout\"]'\n    );\n    const userMenu = doc.querySelector(\n      '[class*=\"user-menu\"], [class*=\"avatar\"], [class*=\"profile-menu\"], ' +\n      '[class*=\"account-menu\"], [data-testid*=\"user\"]'\n    );\n    const welcomeText = text.match(/welcome,?\\s+(\\w+)/i);\n    const userNameEl = doc.querySelector(\n      '[class*=\"username\"], [class*=\"user-name\"], [class*=\"display-name\"]'\n    );\n\n    // Not authenticated signals\n    const loginLink = doc.querySelector(\n      'a:has-text(\"login\"), a:has-text(\"sign in\"), ' +\n      'button:has-text(\"login\"), button:has-text(\"sign in\"), ' +\n      '[class*=\"login-link\"], [href*=\"/login\"], [href*=\"/signin\"]'\n    );\n    const signupLink = doc.querySelector(\n      'a:has-text(\"sign up\"), a:has-text(\"register\"), ' +\n      '[href*=\"/signup\"], [href*=\"/register\"]'\n    );\n\n    // Check for auth-gated content\n    const authRequired = doc.querySelector(\n      '[class*=\"auth-required\"], [class*=\"login-required\"], ' +\n      '[class*=\"protected\"]'\n    );\n\n    // Check cookies/localStorage hints (careful - limited access)\n    const hasAuthCookie = document.cookie.includes('auth') ||\n      document.cookie.includes('session') ||\n      document.cookie.includes('token');\n\n    return {\n      hasLogoutButton: !!logoutButton,\n      hasUserMenu: !!userMenu,\n      hasWelcomeText: !!welcomeText,\n      welcomeName: welcomeText?.[1],\n      hasUserNameElement: !!userNameEl,\n      userName: userNameEl?.textContent?.trim(),\n      hasLoginLink: !!loginLink,\n      hasSignupLink: !!signupLink,\n      hasAuthRequired: !!authRequired,\n      hasAuthCookie,\n    };\n  });\n\n  // Score authenticated signals\n  if (checks.hasLogoutButton) {\n    authenticated = true;\n    confidence += 40;\n    signals.push('logout button present');\n  }\n  if (checks.hasUserMenu) {\n    authenticated = true;\n    confidence += 30;\n    signals.push('user menu present');\n  }\n  if (checks.hasWelcomeText) {\n    authenticated = true;\n    confidence += 20;\n    signals.push('welcome text');\n    username = checks.welcomeName;\n  }\n  if (checks.hasUserNameElement) {\n    authenticated = true;\n    confidence += 15;\n    signals.push('username displayed');\n    username = username || checks.userName;\n  }\n  if (checks.hasAuthCookie) {\n    confidence += 10;\n    signals.push('auth cookie present');\n  }\n\n  // Score not authenticated signals\n  if (checks.hasLoginLink && !checks.hasLogoutButton) {\n    authenticated = false;\n    confidence += 30;\n    signals.push('login link visible');\n  }\n  if (checks.hasSignupLink && !checks.hasUserMenu) {\n    authenticated = false;\n    confidence += 20;\n    signals.push('signup link visible');\n  }\n  if (checks.hasAuthRequired) {\n    authenticated = false;\n    confidence += 25;\n    signals.push('auth-required message');\n  }\n\n  // Normalize confidence\n  confidence = Math.min(confidence / 100, 1);\n\n  // If no strong signals, we can't determine\n  if (confidence < 0.3) {\n    authenticated = null;\n  }\n\n  return {\n    authenticated,\n    confidence,\n    signals,\n    username,\n  };\n}\n\n/**\n * Detect loading state from page signals\n */\nexport async function detectLoadingState(page: Page): Promise<LoadingState> {\n  const checks = await page.evaluate(() => {\n    const doc = document;\n\n    // Spinner detection\n    const spinners = doc.querySelectorAll(\n      '[class*=\"spinner\"], [class*=\"loading\"], [class*=\"loader\"], ' +\n      '[role=\"progressbar\"][aria-busy=\"true\"], ' +\n      '.animate-spin, [class*=\"spin\"]'\n    );\n\n    // Skeleton detection\n    const skeletons = doc.querySelectorAll(\n      '[class*=\"skeleton\"], [class*=\"shimmer\"], [class*=\"placeholder\"], ' +\n      '[class*=\"pulse\"], [aria-busy=\"true\"]'\n    );\n\n    // Progress bar detection\n    const progress = doc.querySelectorAll(\n      'progress, [role=\"progressbar\"], [class*=\"progress-bar\"], ' +\n      '[class*=\"loading-bar\"]'\n    );\n\n    // Lazy loading detection\n    const lazyImages = doc.querySelectorAll(\n      'img[loading=\"lazy\"]:not([src]), [class*=\"lazy\"]:not([src])'\n    );\n\n    // Check if body has loading class\n    const bodyLoading = doc.body?.classList.contains('loading') ||\n      doc.body?.getAttribute('aria-busy') === 'true';\n\n    return {\n      spinnerCount: spinners.length,\n      skeletonCount: skeletons.length,\n      progressCount: progress.length,\n      lazyCount: lazyImages.length,\n      bodyLoading,\n    };\n  });\n\n  // Determine loading type\n  let type: LoadingState['type'] = 'none';\n  let elements = 0;\n  let loading = false;\n\n  if (checks.spinnerCount > 0) {\n    type = 'spinner';\n    elements = checks.spinnerCount;\n    loading = true;\n  } else if (checks.skeletonCount > 0) {\n    type = 'skeleton';\n    elements = checks.skeletonCount;\n    loading = true;\n  } else if (checks.progressCount > 0) {\n    type = 'progress';\n    elements = checks.progressCount;\n    loading = true;\n  } else if (checks.lazyCount > 0) {\n    type = 'lazy';\n    elements = checks.lazyCount;\n    loading = true;\n  } else if (checks.bodyLoading) {\n    type = 'spinner';\n    loading = true;\n  }\n\n  return { loading, type, elements };\n}\n\n/**\n * Detect error state from page signals\n */\nexport async function detectErrorState(page: Page): Promise<ErrorState> {\n  const errors: ErrorInfo[] = [];\n\n  const checks = await page.evaluate(() => {\n    const doc = document;\n    const text = doc.body?.innerText || '';\n\n    // Validation errors\n    const validationErrors = doc.querySelectorAll(\n      '[class*=\"error\"]:not([class*=\"error-boundary\"]), ' +\n      '[class*=\"invalid\"], [aria-invalid=\"true\"], ' +\n      '.field-error, .form-error, .validation-error'\n    );\n\n    // API/Server errors\n    const apiErrors = doc.querySelectorAll(\n      '[class*=\"api-error\"], [class*=\"server-error\"], ' +\n      '[class*=\"fetch-error\"], [class*=\"network-error\"]'\n    );\n\n    // Permission errors\n    const permissionText = text.match(/access denied|forbidden|unauthorized|not allowed/i);\n\n    // 404 errors\n    const notFoundText = text.match(/not found|404|page doesn't exist|no longer available/i);\n\n    // Server errors\n    const serverText = text.match(/500|server error|something went wrong|internal error/i);\n\n    // Toast/notification errors\n    const toastErrors = doc.querySelectorAll(\n      '[class*=\"toast\"][class*=\"error\"], [class*=\"notification\"][class*=\"error\"], ' +\n      '[role=\"alert\"][class*=\"error\"], [class*=\"snackbar\"][class*=\"error\"]'\n    );\n\n    // Extract error messages\n    const extractText = (el: Element) => el.textContent?.trim().slice(0, 200) || '';\n\n    return {\n      validationErrors: Array.from(validationErrors).map(extractText).filter(Boolean),\n      apiErrors: Array.from(apiErrors).map(extractText).filter(Boolean),\n      toastErrors: Array.from(toastErrors).map(extractText).filter(Boolean),\n      hasPermissionError: !!permissionText,\n      hasNotFoundError: !!notFoundText,\n      hasServerError: !!serverText,\n    };\n  });\n\n  // Build error list\n  if (checks.hasPermissionError) {\n    errors.push({\n      type: 'permission',\n      message: 'Access denied or unauthorized',\n    });\n  }\n\n  if (checks.hasNotFoundError) {\n    errors.push({\n      type: 'notfound',\n      message: 'Page or resource not found',\n    });\n  }\n\n  if (checks.hasServerError) {\n    errors.push({\n      type: 'server',\n      message: 'Server error occurred',\n    });\n  }\n\n  for (const msg of checks.validationErrors) {\n    errors.push({\n      type: 'validation',\n      message: msg,\n    });\n  }\n\n  for (const msg of checks.apiErrors) {\n    errors.push({\n      type: 'api',\n      message: msg,\n    });\n  }\n\n  for (const msg of checks.toastErrors) {\n    errors.push({\n      type: 'unknown',\n      message: msg,\n    });\n  }\n\n  // Determine severity\n  let severity: ErrorState['severity'] = 'none';\n  if (errors.length > 0) {\n    const hasCritical = errors.some(e =>\n      e.type === 'server' || e.type === 'permission'\n    );\n    const hasError = errors.some(e =>\n      e.type === 'api' || e.type === 'notfound'\n    );\n    const hasWarning = errors.some(e => e.type === 'validation');\n\n    if (hasCritical) severity = 'critical';\n    else if (hasError) severity = 'error';\n    else if (hasWarning) severity = 'warning';\n  }\n\n  return {\n    hasErrors: errors.length > 0,\n    errors,\n    severity,\n  };\n}\n\n/**\n * Detect full page state\n */\nexport async function detectPageState(page: Page): Promise<PageState> {\n  const [auth, loading, errors] = await Promise.all([\n    detectAuthState(page),\n    detectLoadingState(page),\n    detectErrorState(page),\n  ]);\n\n  // Page is ready if not loading and no critical errors\n  const ready = !loading.loading &&\n    errors.severity !== 'critical' &&\n    errors.severity !== 'error';\n\n  return {\n    auth,\n    loading,\n    errors,\n    ready,\n  };\n}\n\n/**\n * Wait for page to be ready (not loading, no errors)\n */\nexport async function waitForPageReady(\n  page: Page,\n  options: { timeout?: number; ignoreErrors?: boolean } = {}\n): Promise<PageState> {\n  const { timeout = 10000, ignoreErrors = false } = options;\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeout) {\n    const state = await detectPageState(page);\n\n    if (!state.loading.loading) {\n      if (ignoreErrors || !state.errors.hasErrors) {\n        return state;\n      }\n    }\n\n    // Wait a bit before checking again\n    await page.waitForTimeout(200);\n  }\n\n  // Return final state even if not ready\n  return detectPageState(page);\n}\n","/**\n * Semantic Output Formatter\n *\n * Transforms raw page data into AI-friendly semantic output.\n * Provides verdicts, recommendations, and recovery hints.\n */\n\nimport type { Page } from 'playwright';\nimport { classifyPageIntent, type PageIntent, type PageIntentResult } from './page-intent.js';\nimport { detectPageState, type PageState } from './state-detector.js';\n\nexport type SemanticVerdict = 'PASS' | 'ISSUES' | 'FAIL' | 'LOADING' | 'ERROR';\n\nexport interface SemanticIssue {\n  severity: 'critical' | 'major' | 'minor';\n  type: string;\n  element?: string;      // Human-readable description or selector\n  problem: string;\n  fix: string;\n}\n\nexport interface AvailableAction {\n  action: string;        // e.g., 'login', 'search', 'submit'\n  selector?: string;     // Best selector to use\n  description: string;   // What this action does\n}\n\nexport interface RecoveryHint {\n  suggestion: string;\n  alternatives?: string[];\n  waitFor?: string;      // Selector to wait for\n}\n\nexport interface SemanticResult {\n  // Primary verdict for decision loops\n  verdict: SemanticVerdict;\n  confidence: number;\n\n  // Page understanding\n  pageIntent: PageIntentResult;\n  state: PageState;\n\n  // What can be done on this page\n  availableActions: AvailableAction[];\n\n  // Issues found (if any)\n  issues: SemanticIssue[];\n\n  // Recovery suggestions (if failed)\n  recovery?: RecoveryHint;\n\n  // Summary for AI reasoning\n  summary: string;\n\n  // Raw data for advanced use\n  url: string;\n  title: string;\n  timestamp: string;\n}\n\n/**\n * Get semantic understanding of a page\n */\nexport async function getSemanticOutput(page: Page): Promise<SemanticResult> {\n  // Get page basics\n  const url = page.url();\n  const title = await page.title();\n  const timestamp = new Date().toISOString();\n\n  // Run semantic analysis in parallel\n  const [pageIntent, state] = await Promise.all([\n    classifyPageIntent(page),\n    detectPageState(page),\n  ]);\n\n  // Detect available actions based on intent\n  const availableActions = await detectAvailableActions(page, pageIntent.intent);\n\n  // Collect issues\n  const issues = collectIssues(state, pageIntent);\n\n  // Determine verdict\n  const verdict = determineVerdict(state, issues);\n\n  // Generate recovery hints if needed\n  const recovery = verdict === 'FAIL' || verdict === 'ERROR'\n    ? generateRecoveryHint(state, pageIntent.intent)\n    : undefined;\n\n  // Generate summary\n  const summary = generateSummary(pageIntent, state, verdict, issues.length);\n\n  return {\n    verdict,\n    confidence: pageIntent.confidence,\n    pageIntent,\n    state,\n    availableActions,\n    issues,\n    recovery,\n    summary,\n    url,\n    title,\n    timestamp,\n  };\n}\n\n/**\n * Detect available actions based on page intent\n */\nasync function detectAvailableActions(\n  page: Page,\n  intent: PageIntent\n): Promise<AvailableAction[]> {\n  const actions: AvailableAction[] = [];\n\n  const checks = await page.evaluate(() => {\n    const doc = document;\n\n    // Form actions\n    const submitButton = doc.querySelector('button[type=\"submit\"], input[type=\"submit\"]');\n    const searchInput = doc.querySelector('input[type=\"search\"], input[name*=\"search\"], input[placeholder*=\"search\"]');\n    const loginForm = doc.querySelector('form input[type=\"password\"]');\n\n    // Navigation actions\n    const mainNav = doc.querySelector('nav a, header a');\n    const backButton = doc.querySelector('a:has-text(\"back\"), button:has-text(\"back\")');\n\n    // Content actions\n    const addButton = doc.querySelector('button:has-text(\"add\"), button:has-text(\"create\"), button:has-text(\"new\")');\n    const editButton = doc.querySelector('button:has-text(\"edit\"), a:has-text(\"edit\")');\n    const deleteButton = doc.querySelector('button:has-text(\"delete\"), button:has-text(\"remove\")');\n\n    // List actions\n    const filterSelect = doc.querySelector('select[name*=\"filter\"], [class*=\"filter\"] select');\n    const sortSelect = doc.querySelector('select[name*=\"sort\"], [class*=\"sort\"] select');\n    const pagination = doc.querySelector('[class*=\"pagination\"] a, [class*=\"pager\"] button');\n\n    return {\n      hasSubmit: !!submitButton,\n      submitSelector: submitButton ? getSelector(submitButton) : null,\n      hasSearch: !!searchInput,\n      searchSelector: searchInput ? getSelector(searchInput) : null,\n      hasLogin: !!loginForm,\n      hasNav: !!mainNav,\n      hasBack: !!backButton,\n      hasAdd: !!addButton,\n      addSelector: addButton ? getSelector(addButton) : null,\n      hasEdit: !!editButton,\n      hasDelete: !!deleteButton,\n      hasFilter: !!filterSelect,\n      hasSort: !!sortSelect,\n      hasPagination: !!pagination,\n    };\n\n    function getSelector(el: Element): string {\n      if (el.id) return `#${el.id}`;\n      if (el.getAttribute('data-testid')) return `[data-testid=\"${el.getAttribute('data-testid')}\"]`;\n      if (el.className) return `.${el.className.split(' ')[0]}`;\n      return el.tagName.toLowerCase();\n    }\n  });\n\n  // Build actions based on intent and available elements\n  if (intent === 'auth' && checks.hasLogin) {\n    actions.push({\n      action: 'login',\n      selector: 'form',\n      description: 'Submit login credentials',\n    });\n  }\n\n  if (checks.hasSearch) {\n    actions.push({\n      action: 'search',\n      selector: checks.searchSelector || 'input[type=\"search\"]',\n      description: 'Search for content',\n    });\n  }\n\n  if (checks.hasSubmit && intent !== 'auth') {\n    actions.push({\n      action: 'submit',\n      selector: checks.submitSelector || 'button[type=\"submit\"]',\n      description: 'Submit form',\n    });\n  }\n\n  if (checks.hasAdd) {\n    actions.push({\n      action: 'create',\n      selector: checks.addSelector || 'button:has-text(\"add\")',\n      description: 'Create new item',\n    });\n  }\n\n  if (intent === 'listing') {\n    if (checks.hasFilter) {\n      actions.push({\n        action: 'filter',\n        description: 'Filter results',\n      });\n    }\n    if (checks.hasSort) {\n      actions.push({\n        action: 'sort',\n        description: 'Sort results',\n      });\n    }\n    if (checks.hasPagination) {\n      actions.push({\n        action: 'paginate',\n        description: 'Navigate to next/previous page',\n      });\n    }\n  }\n\n  if (checks.hasBack) {\n    actions.push({\n      action: 'back',\n      description: 'Go back to previous page',\n    });\n  }\n\n  return actions;\n}\n\n/**\n * Collect issues from page state\n */\nfunction collectIssues(state: PageState, intent: PageIntentResult): SemanticIssue[] {\n  const issues: SemanticIssue[] = [];\n\n  // Add error-based issues\n  for (const error of state.errors.errors) {\n    issues.push({\n      severity: error.type === 'server' || error.type === 'permission' ? 'critical' : 'major',\n      type: error.type,\n      problem: error.message,\n      fix: getErrorFix(error.type),\n    });\n  }\n\n  // Add loading issues if taking too long\n  if (state.loading.loading && state.loading.elements > 3) {\n    issues.push({\n      severity: 'minor',\n      type: 'slow-loading',\n      problem: `Page has ${state.loading.elements} loading indicators`,\n      fix: 'Wait for content to load or check network',\n    });\n  }\n\n  // Add auth issues\n  if (state.auth.authenticated === false && intent.intent === 'dashboard') {\n    issues.push({\n      severity: 'major',\n      type: 'auth-required',\n      problem: 'Dashboard requires authentication',\n      fix: 'Login first before accessing this page',\n    });\n  }\n\n  return issues;\n}\n\nfunction getErrorFix(errorType: string): string {\n  const fixes: Record<string, string> = {\n    validation: 'Fix the highlighted form fields',\n    api: 'Retry the request or check API status',\n    permission: 'Login with appropriate permissions',\n    notfound: 'Check the URL or navigate to a valid page',\n    server: 'Wait and retry, or contact support',\n    network: 'Check internet connection',\n    unknown: 'Investigate the error message',\n  };\n  return fixes[errorType] || 'Investigate the issue';\n}\n\n/**\n * Determine overall verdict\n */\nfunction determineVerdict(state: PageState, issues: SemanticIssue[]): SemanticVerdict {\n  // Check for critical issues first\n  const hasCritical = issues.some(i => i.severity === 'critical');\n  if (hasCritical) return 'ERROR';\n\n  // Check for loading state\n  if (state.loading.loading) return 'LOADING';\n\n  // Check for errors\n  if (state.errors.hasErrors) return 'FAIL';\n\n  // Check for major issues\n  const hasMajor = issues.some(i => i.severity === 'major');\n  if (hasMajor) return 'ISSUES';\n\n  // All good\n  return 'PASS';\n}\n\n/**\n * Generate recovery hints for failed states\n */\nfunction generateRecoveryHint(state: PageState, _intent: PageIntent): RecoveryHint {\n  // Auth issues\n  if (state.auth.authenticated === false) {\n    return {\n      suggestion: 'Login to access this page',\n      alternatives: ['Use ibr.flow.login()', 'Navigate to /login first'],\n      waitFor: '[class*=\"user\"], [class*=\"avatar\"]',\n    };\n  }\n\n  // Server errors\n  if (state.errors.errors.some(e => e.type === 'server')) {\n    return {\n      suggestion: 'Server error - wait and retry',\n      alternatives: ['Refresh the page', 'Check server status'],\n    };\n  }\n\n  // Not found errors\n  if (state.errors.errors.some(e => e.type === 'notfound')) {\n    return {\n      suggestion: 'Page not found - check URL',\n      alternatives: ['Navigate to homepage', 'Use search to find content'],\n    };\n  }\n\n  // Loading issues\n  if (state.loading.loading) {\n    return {\n      suggestion: 'Wait for page to finish loading',\n      waitFor: state.loading.type === 'skeleton'\n        ? ':not([class*=\"skeleton\"])'\n        : ':not([class*=\"loading\"])',\n    };\n  }\n\n  // Default\n  return {\n    suggestion: 'Investigate the page state and retry',\n  };\n}\n\n/**\n * Generate human-readable summary\n */\nfunction generateSummary(\n  intent: PageIntentResult,\n  state: PageState,\n  verdict: SemanticVerdict,\n  issueCount: number\n): string {\n  const parts: string[] = [];\n\n  // Intent\n  parts.push(`${intent.intent} page`);\n\n  // Confidence\n  if (intent.confidence < 0.5) {\n    parts.push('(low confidence)');\n  }\n\n  // Auth state\n  if (state.auth.authenticated === true) {\n    parts.push(`authenticated${state.auth.username ? ` as ${state.auth.username}` : ''}`);\n  } else if (state.auth.authenticated === false) {\n    parts.push('not authenticated');\n  }\n\n  // Loading\n  if (state.loading.loading) {\n    parts.push(`loading (${state.loading.type})`);\n  }\n\n  // Verdict\n  if (verdict === 'PASS') {\n    parts.push('ready for interaction');\n  } else if (verdict === 'ISSUES') {\n    parts.push(`${issueCount} issue${issueCount > 1 ? 's' : ''} detected`);\n  } else if (verdict === 'ERROR' || verdict === 'FAIL') {\n    parts.push(`${issueCount} error${issueCount > 1 ? 's' : ''}`);\n  }\n\n  return parts.join(', ');\n}\n\n/**\n * Format semantic result as concise text for AI consumption\n */\nexport function formatSemanticText(result: SemanticResult): string {\n  const lines: string[] = [];\n\n  lines.push(`Verdict: ${result.verdict}`);\n  lines.push(`Page: ${result.pageIntent.intent} (${Math.round(result.confidence * 100)}% confidence)`);\n  lines.push(`Summary: ${result.summary}`);\n\n  if (result.state.auth.authenticated !== null) {\n    lines.push(`Auth: ${result.state.auth.authenticated ? 'logged in' : 'logged out'}`);\n  }\n\n  if (result.availableActions.length > 0) {\n    lines.push(`Actions: ${result.availableActions.map(a => a.action).join(', ')}`);\n  }\n\n  if (result.issues.length > 0) {\n    lines.push(`Issues: ${result.issues.map(i => i.problem).join('; ')}`);\n  }\n\n  if (result.recovery) {\n    lines.push(`Recovery: ${result.recovery.suggestion}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format semantic result as JSON for structured consumption\n */\nexport function formatSemanticJson(result: SemanticResult): string {\n  // Return a cleaned version with just the essential fields\n  return JSON.stringify({\n    verdict: result.verdict,\n    intent: result.pageIntent.intent,\n    confidence: result.confidence,\n    authenticated: result.state.auth.authenticated,\n    loading: result.state.loading.loading,\n    ready: result.state.ready,\n    actions: result.availableActions.map(a => a.action),\n    issues: result.issues.map(i => ({ severity: i.severity, problem: i.problem })),\n    recovery: result.recovery?.suggestion,\n  }, null, 2);\n}\n","/**\n * IBR Semantic Layer\n *\n * Provides AI-friendly page understanding:\n * - Page intent classification (auth, form, listing, dashboard, etc.)\n * - State detection (authenticated, loading, errors)\n * - Semantic output with verdicts and recovery hints\n */\n\nexport {\n  classifyPageIntent,\n  getIntentDescription,\n  type PageIntent,\n  type PageIntentResult,\n} from './page-intent.js';\n\nexport {\n  detectAuthState,\n  detectLoadingState,\n  detectErrorState,\n  detectPageState,\n  waitForPageReady,\n  type AuthState,\n  type LoadingState,\n  type ErrorState,\n  type ErrorInfo,\n  type PageState,\n} from './state-detector.js';\n\nexport {\n  getSemanticOutput,\n  formatSemanticText,\n  formatSemanticJson,\n  type SemanticVerdict,\n  type SemanticIssue,\n  type AvailableAction,\n  type RecoveryHint,\n  type SemanticResult,\n} from './output.js';\n\nexport {\n  LANDMARK_SELECTORS,\n  detectLandmarks,\n  getExpectedLandmarksForIntent,\n  compareLandmarks,\n  getExpectedLandmarksFromContext,\n  formatLandmarkComparison,\n  type LandmarkType,\n} from './landmarks.js';\n","/**\n * Flow Types\n *\n * Common types used across all built-in flows.\n */\n\nimport type { Page } from 'playwright';\n\nexport interface FlowStep {\n  action: string;\n  success: boolean;\n  duration?: number;\n  error?: string;\n}\n\nexport interface FlowResult {\n  success: boolean;\n  steps: FlowStep[];\n  error?: string;\n  /** Time taken in ms */\n  duration: number;\n}\n\nexport interface FlowOptions {\n  /** Timeout for the entire flow in ms */\n  timeout?: number;\n  /** Whether to take screenshots at each step */\n  debug?: boolean;\n}\n\n/**\n * Find a form field by common label patterns\n */\nexport async function findFieldByLabel(\n  page: Page,\n  labels: string[]\n): Promise<ReturnType<Page['$']>> {\n  for (const label of labels) {\n    // Try various selector patterns\n    const selectors = [\n      `input[name*=\"${label}\" i]`,\n      `input[id*=\"${label}\" i]`,\n      `input[placeholder*=\"${label}\" i]`,\n      `input[aria-label*=\"${label}\" i]`,\n      `label:has-text(\"${label}\") + input`,\n      `label:has-text(\"${label}\") input`,\n    ];\n\n    for (const selector of selectors) {\n      const element = await page.$(selector);\n      if (element) return element;\n    }\n  }\n  return null;\n}\n\n/**\n * Find a button by common patterns\n */\nexport async function findButton(\n  page: Page,\n  patterns: string[]\n): Promise<ReturnType<Page['$']>> {\n  for (const pattern of patterns) {\n    const selectors = [\n      `button:has-text(\"${pattern}\")`,\n      `input[type=\"submit\"][value*=\"${pattern}\" i]`,\n      `button[type=\"submit\"]:has-text(\"${pattern}\")`,\n      `a:has-text(\"${pattern}\")`,\n      `[role=\"button\"]:has-text(\"${pattern}\")`,\n    ];\n\n    for (const selector of selectors) {\n      const element = await page.$(selector);\n      if (element) return element;\n    }\n  }\n\n  // Fallback to generic submit button\n  return page.$('button[type=\"submit\"], input[type=\"submit\"]');\n}\n\n/**\n * Wait for navigation or network idle\n */\nexport async function waitForNavigation(\n  page: Page,\n  timeout = 10000\n): Promise<void> {\n  try {\n    await Promise.race([\n      page.waitForNavigation({ timeout }),\n      page.waitForLoadState('networkidle', { timeout }),\n    ]);\n  } catch {\n    // Timeout is acceptable - page might not navigate\n  }\n}\n\n// =============================================================================\n// AI Search Testing Types\n// =============================================================================\n\n/**\n * Screenshot captured at a specific step during search flow\n */\nexport interface StepScreenshot {\n  /** Which step this screenshot was taken at */\n  step: 'before' | 'after-query' | 'loading' | 'results';\n  /** Path to the screenshot file */\n  path: string;\n  /** ISO timestamp when captured */\n  timestamp: string;\n  /** Milliseconds since flow start */\n  timing: number;\n}\n\n/**\n * Extracted content from a single search result element\n */\nexport interface ExtractedResult {\n  /** Zero-based index in result list */\n  index: number;\n  /** Title text if identifiable */\n  title?: string;\n  /** Snippet/description text if present */\n  snippet?: string;\n  /** Full text content of the result element */\n  fullText: string;\n  /** CSS selector to locate this element */\n  selector: string;\n  /** Whether the element is visible in viewport */\n  visible: boolean;\n}\n\n/**\n * Timing breakdown for search flow phases\n */\nexport interface SearchTiming {\n  /** Total flow duration in ms */\n  total: number;\n  /** Time spent typing the query */\n  typing: number;\n  /** Time waiting for results to load */\n  waiting: number;\n  /** Time for results to render after load */\n  rendering: number;\n}\n\n/**\n * Extended options for AI search testing\n */\nexport interface AISearchOptions extends FlowOptions {\n  /** Search query to execute */\n  query: string;\n  /** CSS selector for search results container */\n  resultsSelector?: string;\n  /** Whether to submit the form or just type (for autocomplete) */\n  submit?: boolean;\n  /** Capture screenshots at each step (default: true) */\n  captureSteps?: boolean;\n  /** Extract text content from results (default: true) */\n  extractContent?: boolean;\n  /** User's intent for validation (what they expect to find) */\n  userIntent?: string;\n  /** Session directory for storing screenshots */\n  sessionDir?: string;\n}\n\n/**\n * Extended result from AI search flow with full context for validation\n */\nexport interface AISearchResult extends FlowResult {\n  /** The search query that was executed */\n  query: string;\n  /** User's stated intent for validation */\n  userIntent?: string;\n  /** Number of results found */\n  resultCount: number;\n  /** Whether any results were found */\n  hasResults: boolean;\n  /** Timing breakdown for each phase */\n  timing: SearchTiming;\n  /** Screenshots captured at each step */\n  screenshots: StepScreenshot[];\n  /** Extracted content from result elements */\n  extractedResults: ExtractedResult[];\n  /** Directory where search artifacts are stored */\n  artifactDir?: string;\n}\n","/**\n * Search Flow\n *\n * Handles common search patterns with result detection.\n * Includes AI-powered search testing with step screenshots and content extraction.\n */\n\nimport type { Page } from 'playwright';\nimport { writeFile, mkdir } from 'fs/promises';\nimport { join } from 'path';\nimport {\n  findFieldByLabel,\n  waitForNavigation,\n  type FlowResult,\n  type FlowStep,\n  type FlowOptions,\n  type AISearchOptions,\n  type AISearchResult,\n  type StepScreenshot,\n  type ExtractedResult,\n  type SearchTiming,\n} from './types.js';\n\nexport interface FlowSearchOptions extends FlowOptions {\n  /** Search query */\n  query: string;\n  /** Selector for search results container */\n  resultsSelector?: string;\n  /** Whether to submit the form or just type (for autocomplete) */\n  submit?: boolean;\n}\n\nexport interface SearchResult extends FlowResult {\n  /** Number of results found */\n  resultCount: number;\n  /** Whether results were found */\n  hasResults: boolean;\n}\n\n/**\n * Execute search flow\n */\nexport async function searchFlow(\n  page: Page,\n  options: FlowSearchOptions\n): Promise<SearchResult> {\n  const startTime = Date.now();\n  const steps: FlowStep[] = [];\n  const timeout = options.timeout || 10000;\n\n  try {\n    // Step 1: Find search input\n    const searchInput = await findFieldByLabel(page, [\n      'search',\n      'query',\n      'q',\n      'find',\n    ]);\n\n    // Also try common search input patterns\n    const searchField = searchInput || await page.$(\n      'input[type=\"search\"], ' +\n      'input[name=\"q\"], ' +\n      'input[name=\"query\"], ' +\n      'input[placeholder*=\"search\" i], ' +\n      '[role=\"searchbox\"]'\n    );\n\n    if (!searchField) {\n      return {\n        success: false,\n        resultCount: 0,\n        hasResults: false,\n        steps,\n        error: 'Could not find search input',\n        duration: Date.now() - startTime,\n      };\n    }\n\n    // Clear existing content and type query\n    await searchField.fill('');\n    await searchField.fill(options.query);\n    steps.push({ action: `type \"${options.query}\"`, success: true });\n\n    // Step 2: Submit if requested (default true)\n    if (options.submit !== false) {\n      // Try pressing Enter first\n      await searchField.press('Enter');\n      steps.push({ action: 'submit search', success: true });\n\n      // Wait for results\n      await waitForNavigation(page, timeout);\n      steps.push({ action: 'wait for results', success: true });\n    } else {\n      // Just wait for autocomplete\n      await page.waitForTimeout(500);\n      steps.push({ action: 'wait for autocomplete', success: true });\n    }\n\n    // Step 3: Count results\n    const resultsSelector = options.resultsSelector ||\n      '[class*=\"result\"], [class*=\"item\"], [class*=\"card\"], ' +\n      '[data-testid*=\"result\"], li[class*=\"search\"]';\n\n    const results = await page.$$(resultsSelector);\n    const resultCount = results.length;\n    const hasResults = resultCount > 0;\n\n    // Check for empty state\n    const emptyState = await page.$(\n      '[class*=\"no-results\"], [class*=\"empty\"], ' +\n      ':has-text(\"no results\"), :has-text(\"nothing found\")'\n    );\n\n    steps.push({\n      action: `found ${resultCount} results`,\n      success: hasResults || !!emptyState,\n    });\n\n    return {\n      success: true,\n      resultCount,\n      hasResults,\n      steps,\n      duration: Date.now() - startTime,\n    };\n\n  } catch (error) {\n    return {\n      success: false,\n      resultCount: 0,\n      hasResults: false,\n      steps,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      duration: Date.now() - startTime,\n    };\n  }\n}\n\n// =============================================================================\n// AI Search Flow - Enhanced search with screenshots, timing, and content extraction\n// =============================================================================\n\n/**\n * Capture a screenshot at a specific step\n */\nasync function captureStepScreenshot(\n  page: Page,\n  step: StepScreenshot['step'],\n  artifactDir: string,\n  startTime: number\n): Promise<StepScreenshot> {\n  const timestamp = new Date().toISOString();\n  const timing = Date.now() - startTime;\n  const stepNum = { before: '01', 'after-query': '02', loading: '03', results: '04' }[step];\n  const filename = `${stepNum}-${step}.png`;\n  const path = join(artifactDir, filename);\n\n  // Disable animations before screenshot\n  await page.addStyleTag({\n    content: `\n      *, *::before, *::after {\n        animation-duration: 0s !important;\n        animation-delay: 0s !important;\n        transition-duration: 0s !important;\n        transition-delay: 0s !important;\n      }\n    `,\n  });\n\n  await page.screenshot({\n    path,\n    fullPage: false,\n    type: 'png',\n  });\n\n  return { step, path, timestamp, timing };\n}\n\n/**\n * Extract content from search result elements\n */\nasync function extractResultContent(\n  page: Page,\n  resultsSelector: string\n): Promise<ExtractedResult[]> {\n  return page.evaluate((selector) => {\n    const elements = document.querySelectorAll(selector);\n    const results: ExtractedResult[] = [];\n\n    elements.forEach((el, index) => {\n      const htmlEl = el as HTMLElement;\n      const rect = htmlEl.getBoundingClientRect();\n\n      // Try to identify title (usually in h1-h6, strong, or first bold text)\n      const titleEl = htmlEl.querySelector('h1, h2, h3, h4, h5, h6, strong, b, [class*=\"title\"]');\n      const title = titleEl?.textContent?.trim();\n\n      // Try to identify snippet/description\n      const snippetEl = htmlEl.querySelector('p, [class*=\"snippet\"], [class*=\"description\"], [class*=\"summary\"]');\n      const snippet = snippetEl?.textContent?.trim();\n\n      // Get full text content\n      const fullText = htmlEl.textContent?.trim() || '';\n\n      // Generate a unique selector for this element\n      let selector = el.tagName.toLowerCase();\n      if (el.id) {\n        selector = `#${el.id}`;\n      } else if (el.className && typeof el.className === 'string') {\n        const classes = el.className.split(' ').filter(c => c.trim())[0];\n        if (classes) selector += `.${classes}`;\n        selector += `:nth-of-type(${index + 1})`;\n      }\n\n      results.push({\n        index,\n        title: title || undefined,\n        snippet: snippet || undefined,\n        fullText: fullText.slice(0, 500), // Limit length\n        selector,\n        visible: rect.top >= 0 && rect.top < window.innerHeight,\n      });\n    });\n\n    return results;\n  }, resultsSelector);\n}\n\n/**\n * Execute AI-enhanced search flow with screenshots and content extraction\n *\n * This function extends the basic search flow with:\n * - Step-by-step screenshots (before, after-query, results)\n * - Detailed timing breakdown\n * - Extraction of result content for AI validation\n * - User intent tracking for relevance checking\n */\nexport async function aiSearchFlow(\n  page: Page,\n  options: AISearchOptions\n): Promise<AISearchResult> {\n  const startTime = Date.now();\n  const steps: FlowStep[] = [];\n  const screenshots: StepScreenshot[] = [];\n  const timeout = options.timeout || 10000;\n  const captureSteps = options.captureSteps !== false;\n  const extractContent = options.extractContent !== false;\n\n  // Timing breakdown\n  const timing: SearchTiming = {\n    total: 0,\n    typing: 0,\n    waiting: 0,\n    rendering: 0,\n  };\n\n  // Create artifact directory if capturing screenshots\n  let artifactDir: string | undefined;\n  if (captureSteps && options.sessionDir) {\n    artifactDir = join(options.sessionDir, `search-${Date.now()}`);\n    await mkdir(artifactDir, { recursive: true });\n  }\n\n  try {\n    // Step 1: Capture \"before\" screenshot\n    if (captureSteps && artifactDir) {\n      const shot = await captureStepScreenshot(page, 'before', artifactDir, startTime);\n      screenshots.push(shot);\n      steps.push({ action: 'capture before screenshot', success: true, duration: shot.timing });\n    }\n\n    // Step 2: Find search input\n    const searchInput = await findFieldByLabel(page, ['search', 'query', 'q', 'find']);\n    const searchField = searchInput || await page.$(\n      'input[type=\"search\"], ' +\n      'input[name=\"q\"], ' +\n      'input[name=\"query\"], ' +\n      'input[placeholder*=\"search\" i], ' +\n      '[role=\"searchbox\"]'\n    );\n\n    if (!searchField) {\n      return {\n        success: false,\n        query: options.query,\n        userIntent: options.userIntent,\n        resultCount: 0,\n        hasResults: false,\n        steps,\n        screenshots,\n        extractedResults: [],\n        timing: { ...timing, total: Date.now() - startTime },\n        error: 'Could not find search input',\n        duration: Date.now() - startTime,\n        artifactDir,\n      };\n    }\n\n    // Step 3: Type query with timing\n    const typingStart = Date.now();\n    await searchField.fill('');\n    await searchField.fill(options.query);\n    timing.typing = Date.now() - typingStart;\n    steps.push({ action: `type \"${options.query}\"`, success: true, duration: timing.typing });\n\n    // Step 4: Capture \"after-query\" screenshot (for autocomplete testing)\n    if (captureSteps && artifactDir) {\n      const shot = await captureStepScreenshot(page, 'after-query', artifactDir, startTime);\n      screenshots.push(shot);\n      steps.push({ action: 'capture after-query screenshot', success: true });\n    }\n\n    // Step 5: Submit if requested (default true)\n    const waitingStart = Date.now();\n    if (options.submit !== false) {\n      await searchField.press('Enter');\n      steps.push({ action: 'submit search', success: true });\n\n      // Wait for results\n      await waitForNavigation(page, timeout);\n      steps.push({ action: 'wait for results', success: true });\n    } else {\n      // Just wait for autocomplete\n      await page.waitForTimeout(500);\n      steps.push({ action: 'wait for autocomplete', success: true });\n    }\n    timing.waiting = Date.now() - waitingStart;\n\n    // Step 6: Capture \"results\" screenshot\n    const renderingStart = Date.now();\n    if (captureSteps && artifactDir) {\n      const shot = await captureStepScreenshot(page, 'results', artifactDir, startTime);\n      screenshots.push(shot);\n      steps.push({ action: 'capture results screenshot', success: true });\n    }\n\n    // Step 7: Count and extract results\n    const resultsSelector = options.resultsSelector ||\n      '[class*=\"result\"], [class*=\"item\"], [class*=\"card\"], ' +\n      '[data-testid*=\"result\"], li[class*=\"search\"]';\n\n    const resultElements = await page.$$(resultsSelector);\n    const resultCount = resultElements.length;\n    const hasResults = resultCount > 0;\n\n    // Extract content if enabled\n    let extractedResults: ExtractedResult[] = [];\n    if (extractContent && hasResults) {\n      extractedResults = await extractResultContent(page, resultsSelector);\n      steps.push({ action: `extracted ${extractedResults.length} results`, success: true });\n    }\n\n    timing.rendering = Date.now() - renderingStart;\n    timing.total = Date.now() - startTime;\n\n    // Save results.json if we have an artifact directory\n    if (artifactDir) {\n      const resultsData = {\n        query: options.query,\n        userIntent: options.userIntent,\n        timestamp: new Date().toISOString(),\n        resultCount,\n        hasResults,\n        timing,\n        extractedResults,\n      };\n      await writeFile(\n        join(artifactDir, 'results.json'),\n        JSON.stringify(resultsData, null, 2)\n      );\n    }\n\n    steps.push({\n      action: `found ${resultCount} results`,\n      success: hasResults,\n    });\n\n    return {\n      success: true,\n      query: options.query,\n      userIntent: options.userIntent,\n      resultCount,\n      hasResults,\n      steps,\n      screenshots,\n      extractedResults,\n      timing,\n      duration: timing.total,\n      artifactDir,\n    };\n\n  } catch (error) {\n    timing.total = Date.now() - startTime;\n    return {\n      success: false,\n      query: options.query,\n      userIntent: options.userIntent,\n      resultCount: 0,\n      hasResults: false,\n      steps,\n      screenshots,\n      extractedResults: [],\n      timing,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      duration: timing.total,\n      artifactDir,\n    };\n  }\n}\n","/**\n * Search Validation\n *\n * Generates structured output for Claude Code to analyze search results.\n * Provides context for AI-powered relevance checking.\n */\n\nimport type { AISearchResult, ExtractedResult, SearchTiming } from './types.js';\n\n/**\n * Context for AI validation of search results\n */\nexport interface ValidationContext {\n  /** The search query executed */\n  query: string;\n  /** What the user expected to find */\n  userIntent: string;\n  /** Extracted results for analysis */\n  results: ExtractedResult[];\n  /** Paths to screenshots for visual inspection */\n  screenshotPaths: string[];\n  /** Timing metrics */\n  timing: SearchTiming;\n  /** Timestamp of the search */\n  timestamp: string;\n  /** Whether any results were found */\n  hasResults: boolean;\n  /** Total result count */\n  resultCount: number;\n}\n\n/**\n * Result from AI validation\n */\nexport interface ValidationResult {\n  /** Whether results are relevant to user intent */\n  relevant: boolean;\n  /** Confidence in the assessment (0-1) */\n  confidence: number;\n  /** Explanation of the assessment */\n  reasoning: string;\n  /** Suggestions for improvement or next steps */\n  suggestions?: string[];\n  /** Specific issues found */\n  issues?: ValidationIssue[];\n}\n\n/**\n * Specific issue found during validation\n */\nexport interface ValidationIssue {\n  /** Type of issue */\n  type: 'irrelevant' | 'partial' | 'empty' | 'error' | 'slow';\n  /** Which result index (if applicable) */\n  resultIndex?: number;\n  /** Description of the issue */\n  description: string;\n  /** Severity: low, medium, high */\n  severity: 'low' | 'medium' | 'high';\n}\n\n/**\n * Generate validation context from AI search result\n */\nexport function generateValidationContext(result: AISearchResult): ValidationContext {\n  return {\n    query: result.query,\n    userIntent: result.userIntent || `Find results related to: ${result.query}`,\n    results: result.extractedResults,\n    screenshotPaths: result.screenshots.map(s => s.path),\n    timing: result.timing,\n    timestamp: new Date().toISOString(),\n    hasResults: result.hasResults,\n    resultCount: result.resultCount,\n  };\n}\n\n/**\n * Generate a structured prompt for Claude Code to analyze search results\n *\n * This prompt provides all necessary context for AI-powered validation:\n * - The query and user intent\n * - Extracted result content\n * - Screenshots for visual inspection\n * - Timing metrics\n */\nexport function generateValidationPrompt(context: ValidationContext): string {\n  const lines: string[] = [];\n\n  lines.push('# Search Result Validation Request');\n  lines.push('');\n  lines.push('Please analyze the following search results and determine if they are relevant to the user\\'s intent.');\n  lines.push('');\n\n  // Query and Intent\n  lines.push('## Search Details');\n  lines.push(`- **Query:** \"${context.query}\"`);\n  lines.push(`- **User Intent:** ${context.userIntent}`);\n  lines.push(`- **Results Found:** ${context.resultCount}`);\n  lines.push(`- **Total Time:** ${context.timing.total}ms`);\n  lines.push('');\n\n  // Screenshots\n  if (context.screenshotPaths.length > 0) {\n    lines.push('## Screenshots');\n    lines.push('The following screenshots capture the search interaction:');\n    for (const path of context.screenshotPaths) {\n      lines.push(`- ${path}`);\n    }\n    lines.push('');\n    lines.push('*Please view these screenshots using the Read tool to see the visual state.*');\n    lines.push('');\n  }\n\n  // Extracted Results\n  if (context.results.length > 0) {\n    lines.push('## Extracted Results');\n    lines.push('');\n    for (const result of context.results.slice(0, 10)) { // Limit to first 10\n      lines.push(`### Result ${result.index + 1}`);\n      if (result.title) {\n        lines.push(`**Title:** ${result.title}`);\n      }\n      if (result.snippet) {\n        lines.push(`**Snippet:** ${result.snippet}`);\n      }\n      lines.push(`**Full Text:** ${result.fullText.slice(0, 200)}${result.fullText.length > 200 ? '...' : ''}`);\n      lines.push(`**Visible:** ${result.visible ? 'Yes' : 'No'}`);\n      lines.push('');\n    }\n\n    if (context.results.length > 10) {\n      lines.push(`*...and ${context.results.length - 10} more results*`);\n      lines.push('');\n    }\n  } else {\n    lines.push('## No Results');\n    lines.push('The search returned no results. This may indicate:');\n    lines.push('- The search query is too specific');\n    lines.push('- No matching content exists');\n    lines.push('- A bug in the search functionality');\n    lines.push('');\n  }\n\n  // Validation Questions\n  lines.push('## Validation Questions');\n  lines.push('');\n  lines.push('1. **Relevance:** Do the results match the user\\'s intent?');\n  lines.push('2. **Quality:** Are the results useful and informative?');\n  lines.push('3. **Issues:** Are there any obvious problems (e.g., unrelated content)?');\n  lines.push('4. **Suggestions:** What could improve the search experience?');\n  lines.push('');\n\n  // Response Format\n  lines.push('## Expected Response');\n  lines.push('');\n  lines.push('Please respond with:');\n  lines.push('- `relevant`: true/false - whether results match user intent');\n  lines.push('- `confidence`: 0-1 - how confident you are in the assessment');\n  lines.push('- `reasoning`: brief explanation of your assessment');\n  lines.push('- `suggestions`: (optional) array of improvement suggestions');\n  lines.push('- `issues`: (optional) array of specific issues found');\n\n  return lines.join('\\n');\n}\n\n/**\n * Generate a concise summary for quick validation\n */\nexport function generateQuickSummary(context: ValidationContext): string {\n  const lines: string[] = [];\n\n  lines.push(`Search: \"${context.query}\"`);\n  lines.push(`Intent: ${context.userIntent}`);\n  lines.push(`Results: ${context.resultCount} found in ${context.timing.total}ms`);\n\n  if (context.results.length > 0) {\n    lines.push('');\n    lines.push('Top results:');\n    for (const result of context.results.slice(0, 3)) {\n      const title = result.title || result.fullText.slice(0, 50);\n      lines.push(`  ${result.index + 1}. ${title}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Analyze results for obvious issues (pre-AI check)\n *\n * Performs quick heuristic checks before involving AI:\n * - Empty results\n * - Very slow response\n * - Results with no text content\n */\nexport function analyzeForObviousIssues(context: ValidationContext): ValidationIssue[] {\n  const issues: ValidationIssue[] = [];\n\n  // Check for empty results\n  if (!context.hasResults) {\n    issues.push({\n      type: 'empty',\n      description: 'Search returned no results',\n      severity: 'high',\n    });\n  }\n\n  // Check for slow response (>5 seconds is concerning)\n  if (context.timing.total > 5000) {\n    issues.push({\n      type: 'slow',\n      description: `Search took ${context.timing.total}ms (>5s)`,\n      severity: context.timing.total > 10000 ? 'high' : 'medium',\n    });\n  }\n\n  // Check for results with no meaningful content\n  for (const result of context.results) {\n    if (!result.fullText || result.fullText.trim().length < 10) {\n      issues.push({\n        type: 'error',\n        resultIndex: result.index,\n        description: `Result ${result.index + 1} has no meaningful content`,\n        severity: 'medium',\n      });\n    }\n  }\n\n  // Check for query terms in results (basic relevance)\n  const queryTerms = context.query.toLowerCase().split(/\\s+/).filter(t => t.length > 2);\n  for (const result of context.results) {\n    const textLower = result.fullText.toLowerCase();\n    const matchCount = queryTerms.filter(term => textLower.includes(term)).length;\n    const matchRatio = matchCount / queryTerms.length;\n\n    if (matchRatio < 0.2 && queryTerms.length > 1) {\n      issues.push({\n        type: 'irrelevant',\n        resultIndex: result.index,\n        description: `Result ${result.index + 1} may not match query (low keyword overlap)`,\n        severity: 'low',\n      });\n    }\n  }\n\n  return issues;\n}\n\n/**\n * Format validation result for display\n */\nexport function formatValidationResult(result: ValidationResult): string {\n  const lines: string[] = [];\n\n  const status = result.relevant ? 'PASS' : 'FAIL';\n  const confidence = Math.round(result.confidence * 100);\n\n  lines.push(`## Validation: ${status} (${confidence}% confidence)`);\n  lines.push('');\n  lines.push(`**Assessment:** ${result.reasoning}`);\n\n  if (result.issues && result.issues.length > 0) {\n    lines.push('');\n    lines.push('**Issues Found:**');\n    for (const issue of result.issues) {\n      const severity = issue.severity.toUpperCase();\n      lines.push(`- [${severity}] ${issue.description}`);\n    }\n  }\n\n  if (result.suggestions && result.suggestions.length > 0) {\n    lines.push('');\n    lines.push('**Suggestions:**');\n    for (const suggestion of result.suggestions) {\n      lines.push(`- ${suggestion}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Create a dev-mode prompt for user feedback\n *\n * Used when results seem questionable and user input is needed.\n */\nexport function generateDevModePrompt(\n  context: ValidationContext,\n  issues: ValidationIssue[]\n): string {\n  const lines: string[] = [];\n\n  lines.push('## Search Results Review');\n  lines.push('');\n  lines.push(`Query: \"${context.query}\"`);\n  lines.push(`Intent: ${context.userIntent}`);\n  lines.push('');\n\n  if (issues.length > 0) {\n    lines.push('**Potential issues detected:**');\n    for (const issue of issues) {\n      lines.push(`- ${issue.description}`);\n    }\n    lines.push('');\n  }\n\n  // Show sample results\n  if (context.results.length > 0) {\n    lines.push('**Sample results:**');\n    for (const result of context.results.slice(0, 3)) {\n      const title = result.title || result.fullText.slice(0, 40);\n      lines.push(`  ${result.index + 1}. ${title}`);\n    }\n    lines.push('');\n  }\n\n  lines.push('**What would you like to do?**');\n  lines.push('1. Accept results as expected');\n  lines.push('2. Refine the search query');\n  lines.push('3. Report as bug');\n  lines.push('4. Skip this test');\n\n  return lines.join('\\n');\n}\n","import { chromium, Browser } from 'playwright';\n\n/**\n * UI metrics extracted from a page for consistency checking\n */\nexport interface PageMetrics {\n  url: string;\n  path: string;\n  title: string;\n\n  // Layout metrics\n  layout: {\n    headerHeight: number | null;\n    navWidth: number | null;\n    contentPadding: { top: number; right: number; bottom: number; left: number } | null;\n    footerHeight: number | null;\n  };\n\n  // Typography metrics\n  typography: {\n    bodyFontFamily: string | null;\n    bodyFontSize: string | null;\n    headingFontFamily: string | null;\n    h1FontSize: string | null;\n    h2FontSize: string | null;\n    lineHeight: string | null;\n  };\n\n  // Color metrics\n  colors: {\n    backgroundColor: string | null;\n    textColor: string | null;\n    linkColor: string | null;\n    primaryButtonBg: string | null;\n    primaryButtonText: string | null;\n  };\n\n  // Spacing metrics (common elements)\n  spacing: {\n    buttonPadding: string | null;\n    cardPadding: string | null;\n    sectionGap: string | null;\n  };\n}\n\n/**\n * Inconsistency found between pages\n */\nexport interface Inconsistency {\n  type: 'layout' | 'typography' | 'color' | 'spacing';\n  property: string;\n  severity: 'info' | 'warning' | 'error';\n  description: string;\n  pages: Array<{\n    path: string;\n    value: string | number | null;\n  }>;\n  suggestion?: string;\n}\n\n/**\n * Consistency check result\n */\nexport interface ConsistencyResult {\n  pages: PageMetrics[];\n  inconsistencies: Inconsistency[];\n  score: number; // 0-100, higher is more consistent\n  summary: string;\n}\n\n/**\n * Consistency check options\n */\nexport interface ConsistencyOptions {\n  /** URLs to check */\n  urls: string[];\n  /** Enable verbose output */\n  verbose?: boolean;\n  /** Timeout per page (ms) */\n  timeout?: number;\n  /** Ignore certain property types */\n  ignore?: Array<'layout' | 'typography' | 'color' | 'spacing'>;\n}\n\n/**\n * Extract UI metrics from a page\n */\nasync function extractMetrics(page: import('playwright').Page, url: string): Promise<PageMetrics> {\n  const parsedUrl = new URL(url);\n\n  const metrics = await page.evaluate(() => {\n    const getComputedStyleProp = (selector: string, prop: string): string | null => {\n      const el = document.querySelector(selector);\n      if (!el) return null;\n      return window.getComputedStyle(el).getPropertyValue(prop) || null;\n    };\n\n    const getElementHeight = (selector: string): number | null => {\n      const el = document.querySelector(selector);\n      if (!el) return null;\n      return el.getBoundingClientRect().height;\n    };\n\n    const getElementWidth = (selector: string): number | null => {\n      const el = document.querySelector(selector);\n      if (!el) return null;\n      return el.getBoundingClientRect().width;\n    };\n\n    // Try multiple selectors for common elements\n    const headerSelectors = ['header', '[role=\"banner\"]', '.header', '#header', 'nav'];\n    const navSelectors = ['nav', '[role=\"navigation\"]', '.sidebar', '.nav', '#sidebar'];\n    const mainSelectors = ['main', '[role=\"main\"]', '.content', '#content', '.main'];\n    const footerSelectors = ['footer', '[role=\"contentinfo\"]', '.footer', '#footer'];\n    const buttonSelectors = ['button', '.btn', '[role=\"button\"]', 'a.button'];\n    const cardSelectors = ['.card', '[class*=\"card\"]', '.panel', '.box'];\n\n    const findFirst = (selectors: string[], fn: (s: string) => string | number | null) => {\n      for (const sel of selectors) {\n        const result = fn(sel);\n        if (result !== null) return result;\n      }\n      return null;\n    };\n\n    // Get padding from main content\n    const getContentPadding = (): { top: number; right: number; bottom: number; left: number } | null => {\n      for (const sel of mainSelectors) {\n        const el = document.querySelector(sel);\n        if (el) {\n          const style = window.getComputedStyle(el);\n          return {\n            top: parseFloat(style.paddingTop) || 0,\n            right: parseFloat(style.paddingRight) || 0,\n            bottom: parseFloat(style.paddingBottom) || 0,\n            left: parseFloat(style.paddingLeft) || 0,\n          };\n        }\n      }\n      return null;\n    };\n\n    return {\n      title: document.title,\n      layout: {\n        headerHeight: findFirst(headerSelectors, getElementHeight) as number | null,\n        navWidth: findFirst(navSelectors, getElementWidth) as number | null,\n        contentPadding: getContentPadding(),\n        footerHeight: findFirst(footerSelectors, getElementHeight) as number | null,\n      },\n      typography: {\n        bodyFontFamily: getComputedStyleProp('body', 'font-family'),\n        bodyFontSize: getComputedStyleProp('body', 'font-size'),\n        headingFontFamily: getComputedStyleProp('h1, h2, h3', 'font-family'),\n        h1FontSize: getComputedStyleProp('h1', 'font-size'),\n        h2FontSize: getComputedStyleProp('h2', 'font-size'),\n        lineHeight: getComputedStyleProp('body', 'line-height'),\n      },\n      colors: {\n        backgroundColor: getComputedStyleProp('body', 'background-color'),\n        textColor: getComputedStyleProp('body', 'color'),\n        linkColor: getComputedStyleProp('a', 'color'),\n        primaryButtonBg: findFirst(buttonSelectors, s => getComputedStyleProp(s, 'background-color')) as string | null,\n        primaryButtonText: findFirst(buttonSelectors, s => getComputedStyleProp(s, 'color')) as string | null,\n      },\n      spacing: {\n        buttonPadding: findFirst(buttonSelectors, s => getComputedStyleProp(s, 'padding')) as string | null,\n        cardPadding: findFirst(cardSelectors, s => getComputedStyleProp(s, 'padding')) as string | null,\n        sectionGap: getComputedStyleProp('main > *', 'margin-bottom'),\n      },\n    };\n  });\n\n  return {\n    url,\n    path: parsedUrl.pathname,\n    ...metrics,\n  };\n}\n\n/**\n * Compare metrics across pages and find inconsistencies\n */\nfunction findInconsistencies(pages: PageMetrics[], ignore: string[] = []): Inconsistency[] {\n  const inconsistencies: Inconsistency[] = [];\n\n  // Helper to check if values are consistent\n  const checkProperty = (\n    type: Inconsistency['type'],\n    property: string,\n    getValue: (p: PageMetrics) => string | number | null,\n    description: string,\n    severity: Inconsistency['severity'] = 'warning'\n  ) => {\n    if (ignore.includes(type)) return;\n\n    const values = pages.map(p => ({\n      path: p.path,\n      value: getValue(p),\n    }));\n\n    // Filter out null values\n    const nonNullValues = values.filter(v => v.value !== null);\n    if (nonNullValues.length < 2) return;\n\n    // Check if all values are the same\n    const uniqueValues = new Set(nonNullValues.map(v => String(v.value)));\n    if (uniqueValues.size > 1) {\n      inconsistencies.push({\n        type,\n        property,\n        severity,\n        description,\n        pages: values,\n      });\n    }\n  };\n\n  // Layout checks\n  checkProperty('layout', 'headerHeight', p => p.layout.headerHeight, 'Header height differs across pages');\n  checkProperty('layout', 'navWidth', p => p.layout.navWidth, 'Navigation width differs across pages');\n  checkProperty('layout', 'footerHeight', p => p.layout.footerHeight, 'Footer height differs across pages');\n\n  // Typography checks\n  checkProperty('typography', 'bodyFontFamily', p => p.typography.bodyFontFamily, 'Body font family differs across pages', 'error');\n  checkProperty('typography', 'bodyFontSize', p => p.typography.bodyFontSize, 'Body font size differs across pages');\n  checkProperty('typography', 'headingFontFamily', p => p.typography.headingFontFamily, 'Heading font family differs across pages', 'error');\n  checkProperty('typography', 'h1FontSize', p => p.typography.h1FontSize, 'H1 font size differs across pages');\n  checkProperty('typography', 'lineHeight', p => p.typography.lineHeight, 'Line height differs across pages');\n\n  // Color checks\n  checkProperty('color', 'backgroundColor', p => p.colors.backgroundColor, 'Background color differs across pages');\n  checkProperty('color', 'textColor', p => p.colors.textColor, 'Text color differs across pages', 'error');\n  checkProperty('color', 'linkColor', p => p.colors.linkColor, 'Link color differs across pages');\n  checkProperty('color', 'primaryButtonBg', p => p.colors.primaryButtonBg, 'Primary button background differs across pages');\n\n  // Spacing checks\n  checkProperty('spacing', 'buttonPadding', p => p.spacing.buttonPadding, 'Button padding differs across pages');\n  checkProperty('spacing', 'cardPadding', p => p.spacing.cardPadding, 'Card padding differs across pages');\n\n  return inconsistencies;\n}\n\n/**\n * Calculate consistency score based on inconsistencies\n */\nfunction calculateScore(inconsistencies: Inconsistency[]): number {\n  if (inconsistencies.length === 0) return 100;\n\n  const weights = { error: 10, warning: 5, info: 1 };\n  const totalPenalty = inconsistencies.reduce((sum, i) => sum + weights[i.severity], 0);\n\n  // Score decreases based on penalty, minimum 0\n  return Math.max(0, 100 - totalPenalty);\n}\n\n/**\n * Check UI consistency across multiple pages\n */\nexport async function checkConsistency(options: ConsistencyOptions): Promise<ConsistencyResult> {\n  const { urls, timeout = 15000, ignore = [] } = options;\n\n  let browser: Browser | null = null;\n  const pages: PageMetrics[] = [];\n\n  try {\n    browser = await chromium.launch({ headless: true });\n    const context = await browser.newContext({\n      viewport: { width: 1920, height: 1080 },\n    });\n    const page = await context.newPage();\n\n    for (const url of urls) {\n      try {\n        await page.goto(url, {\n          waitUntil: 'domcontentloaded',\n          timeout,\n        });\n\n        const metrics = await extractMetrics(page, url);\n        pages.push(metrics);\n      } catch (error) {\n        console.error(`Failed to analyze ${url}:`, error instanceof Error ? error.message : error);\n      }\n    }\n\n    await browser.close();\n  } catch (error) {\n    if (browser) await browser.close();\n    throw error;\n  }\n\n  if (pages.length < 2) {\n    return {\n      pages,\n      inconsistencies: [],\n      score: 100,\n      summary: 'Need at least 2 pages to check consistency',\n    };\n  }\n\n  const inconsistencies = findInconsistencies(pages, ignore);\n  const score = calculateScore(inconsistencies);\n\n  const errorCount = inconsistencies.filter(i => i.severity === 'error').length;\n  const warningCount = inconsistencies.filter(i => i.severity === 'warning').length;\n\n  let summary: string;\n  if (score === 100) {\n    summary = `All ${pages.length} pages are consistent.`;\n  } else if (score >= 80) {\n    summary = `Minor inconsistencies found across ${pages.length} pages. ${warningCount} warning(s).`;\n  } else if (score >= 50) {\n    summary = `Notable inconsistencies found. ${errorCount} error(s), ${warningCount} warning(s).`;\n  } else {\n    summary = `Significant style inconsistencies detected. ${errorCount} error(s), ${warningCount} warning(s). Review recommended.`;\n  }\n\n  return {\n    pages,\n    inconsistencies,\n    score,\n    summary,\n  };\n}\n\n/**\n * Format consistency result for display\n */\nexport function formatConsistencyReport(result: ConsistencyResult): string {\n  const lines: string[] = [];\n\n  lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n  lines.push('  UI CONSISTENCY REPORT');\n  lines.push('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n  lines.push('');\n  lines.push(`Score: ${result.score}/100`);\n  lines.push(`Pages analyzed: ${result.pages.length}`);\n  lines.push(`Summary: ${result.summary}`);\n  lines.push('');\n\n  if (result.inconsistencies.length === 0) {\n    lines.push('‚úì No inconsistencies found');\n  } else {\n    lines.push('Inconsistencies:');\n    lines.push('');\n\n    for (const issue of result.inconsistencies) {\n      const icon = issue.severity === 'error' ? '‚úó' : issue.severity === 'warning' ? '!' : '‚Ñπ';\n      lines.push(`  ${icon} [${issue.type}] ${issue.description}`);\n\n      for (const page of issue.pages) {\n        if (page.value !== null) {\n          lines.push(`      ${page.path}: ${page.value}`);\n        }\n      }\n      lines.push('');\n    }\n  }\n\n  lines.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n  lines.push('Pages analyzed:');\n  for (const page of result.pages) {\n    lines.push(`  ‚Ä¢ ${page.path} (${page.title})`);\n  }\n\n  return lines.join('\\n');\n}\n","import { chromium, Browser } from 'playwright';\nimport { URL } from 'url';\n\nexport interface CrawlOptions {\n  /** Starting URL */\n  url: string;\n  /** Maximum number of pages to discover (default: 5) */\n  maxPages?: number;\n  /** Only crawl pages under this path prefix */\n  pathPrefix?: string;\n  /** Timeout per page in ms (default: 10000) */\n  timeout?: number;\n  /** Include external links (default: false) */\n  includeExternal?: boolean;\n}\n\nexport interface DiscoveredPage {\n  url: string;\n  path: string;\n  title: string;\n  linkText?: string;\n  depth: number;\n}\n\nexport interface CrawlResult {\n  baseUrl: string;\n  pages: DiscoveredPage[];\n  totalLinks: number;\n  crawlTime: number;\n}\n\n/**\n * Discover pages on a website by crawling from the starting URL\n * Returns up to maxPages unique pages within the same origin\n */\nexport async function discoverPages(options: CrawlOptions): Promise<CrawlResult> {\n  const {\n    url,\n    maxPages = 5,\n    pathPrefix,\n    timeout = 10000,\n    includeExternal = false,\n  } = options;\n\n  const startTime = Date.now();\n  const startUrl = new URL(url);\n  const origin = startUrl.origin;\n\n  const discovered: Map<string, DiscoveredPage> = new Map();\n  const visited: Set<string> = new Set();\n  const queue: { url: string; depth: number; linkText?: string }[] = [\n    { url: url, depth: 0 }\n  ];\n\n  let browser: Browser | null = null;\n  let totalLinks = 0;\n\n  try {\n    browser = await chromium.launch({ headless: true });\n    const context = await browser.newContext();\n    const page = await context.newPage();\n\n    while (queue.length > 0 && discovered.size < maxPages) {\n      const current = queue.shift();\n      if (!current) break;\n\n      const currentUrl = normalizeUrl(current.url);\n      if (visited.has(currentUrl)) continue;\n      visited.add(currentUrl);\n\n      try {\n        // Navigate to page\n        await page.goto(current.url, {\n          waitUntil: 'domcontentloaded',\n          timeout,\n        });\n\n        // Get page title\n        const title = await page.title();\n\n        // Add to discovered pages\n        const parsedUrl = new URL(current.url);\n        discovered.set(currentUrl, {\n          url: current.url,\n          path: parsedUrl.pathname,\n          title: title || parsedUrl.pathname,\n          linkText: current.linkText,\n          depth: current.depth,\n        });\n\n        // Only continue crawling if we haven't reached max\n        if (discovered.size >= maxPages) break;\n\n        // Find all links on the page\n        const links = await page.evaluate((): { href: string; text: string }[] => {\n          const anchors = Array.from(document.querySelectorAll('a[href]'));\n          return anchors.map((a: Element) => ({\n            href: (a as HTMLAnchorElement).getAttribute('href') || '',\n            text: a.textContent?.trim() || '',\n          }));\n        });\n\n        totalLinks += links.length;\n\n        // Process links\n        for (const link of links) {\n          if (discovered.size >= maxPages) break;\n\n          try {\n            const absoluteUrl = new URL(link.href, current.url);\n            const normalizedUrl = normalizeUrl(absoluteUrl.href);\n\n            // Skip if already visited or queued\n            if (visited.has(normalizedUrl)) continue;\n\n            // Check if same origin\n            if (!includeExternal && absoluteUrl.origin !== origin) continue;\n\n            // Check path prefix if specified\n            if (pathPrefix && !absoluteUrl.pathname.startsWith(pathPrefix)) continue;\n\n            // Skip common non-page URLs\n            if (shouldSkipUrl(absoluteUrl)) continue;\n\n            // Add to queue\n            queue.push({\n              url: absoluteUrl.href,\n              depth: current.depth + 1,\n              linkText: link.text,\n            });\n          } catch {\n            // Invalid URL, skip\n          }\n        }\n      } catch (error) {\n        // Page failed to load, continue with next\n        console.error(`Failed to load ${current.url}:`, error instanceof Error ? error.message : error);\n      }\n    }\n\n    await browser.close();\n  } catch (error) {\n    if (browser) await browser.close();\n    throw error;\n  }\n\n  const crawlTime = Date.now() - startTime;\n\n  return {\n    baseUrl: origin,\n    pages: Array.from(discovered.values()).sort((a, b) => {\n      // Sort by depth first, then by path\n      if (a.depth !== b.depth) return a.depth - b.depth;\n      return a.path.localeCompare(b.path);\n    }),\n    totalLinks,\n    crawlTime,\n  };\n}\n\n/**\n * Normalize URL for comparison (remove trailing slash, hash, query params)\n */\nfunction normalizeUrl(url: string): string {\n  try {\n    const parsed = new URL(url);\n    // Remove hash and query, normalize trailing slash\n    let normalized = `${parsed.origin}${parsed.pathname}`;\n    if (normalized.endsWith('/') && normalized.length > 1) {\n      normalized = normalized.slice(0, -1);\n    }\n    return normalized;\n  } catch {\n    return url;\n  }\n}\n\n/**\n * Check if URL should be skipped (non-page resources)\n */\nfunction shouldSkipUrl(url: URL): boolean {\n  const path = url.pathname.toLowerCase();\n  const skipExtensions = [\n    '.pdf', '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.css', '.js', '.json', '.xml', '.ico', '.woff', '.woff2',\n    '.mp3', '.mp4', '.webm', '.zip', '.tar', '.gz',\n  ];\n\n  if (skipExtensions.some(ext => path.endsWith(ext))) return true;\n\n  // Skip common non-content paths\n  const skipPaths = [\n    '/api/', '/static/', '/assets/', '/_next/', '/fonts/',\n    '/images/', '/img/', '/cdn/', '/admin/', '/auth/',\n  ];\n\n  if (skipPaths.some(p => path.includes(p))) return true;\n\n  // Skip hash-only links\n  if (url.hash && url.pathname === '/') return true;\n\n  return false;\n}\n\n/**\n * Quick scan to get navigation links from a page\n * Useful for finding main pages without full crawl\n */\nexport async function getNavigationLinks(url: string): Promise<DiscoveredPage[]> {\n  let browser: Browser | null = null;\n\n  try {\n    browser = await chromium.launch({ headless: true });\n    const page = await browser.newPage();\n\n    await page.goto(url, {\n      waitUntil: 'domcontentloaded',\n      timeout: 15000,\n    });\n\n    const origin = new URL(url).origin;\n\n    // Find links in navigation elements\n    const navLinks = await page.evaluate((): { href: string; text: string }[] => {\n      const selectors = [\n        'nav a[href]',\n        'header a[href]',\n        '[role=\"navigation\"] a[href]',\n        '.nav a[href]',\n        '.navbar a[href]',\n        '.sidebar a[href]',\n        '.menu a[href]',\n      ];\n\n      const links: { href: string; text: string }[] = [];\n      const seen = new Set<string>();\n\n      for (const selector of selectors) {\n        const anchors = Array.from(document.querySelectorAll(selector));\n        for (const a of anchors) {\n          const href = (a as HTMLAnchorElement).getAttribute('href');\n          const text = a.textContent?.trim();\n          if (href && text && !seen.has(href)) {\n            seen.add(href);\n            links.push({ href, text });\n          }\n        }\n      }\n\n      return links;\n    });\n\n    await browser.close();\n\n    // Convert to DiscoveredPage format\n    const pages: DiscoveredPage[] = [];\n\n    for (const link of navLinks) {\n      try {\n        const absoluteUrl = new URL(link.href, url);\n\n        // Only include same-origin links\n        if (absoluteUrl.origin !== origin) continue;\n\n        // Skip resources\n        if (shouldSkipUrl(absoluteUrl)) continue;\n\n        pages.push({\n          url: absoluteUrl.href,\n          path: absoluteUrl.pathname,\n          title: link.text,\n          linkText: link.text,\n          depth: 1,\n        });\n      } catch {\n        // Invalid URL\n      }\n    }\n\n    // Remove duplicates by path\n    const uniquePages = new Map<string, DiscoveredPage>();\n    for (const page of pages) {\n      if (!uniquePages.has(page.path)) {\n        uniquePages.set(page.path, page);\n      }\n    }\n\n    return Array.from(uniquePages.values());\n  } catch (error) {\n    if (browser) await browser.close();\n    throw error;\n  }\n}\n","/**\n * integration.ts\n * Extract API calls from TypeScript/React component files\n *\n * Detects:\n * - fetch() calls\n * - axios methods (get, post, put, delete, patch, etc.)\n * - Template literals and variable URLs\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface ApiCall {\n  endpoint: string;       // \"/api/users\" or \"https://...\" or \"${dynamic}\"\n  method: string;         // GET, POST, PUT, DELETE, PATCH, etc.\n  sourceFile: string;     // File where call was found\n  lineNumber?: number;    // Line number in source\n  callerContext?: string; // Function/component name containing the call\n  isDynamic?: boolean;    // True if endpoint uses template literals or variables\n}\n\n/**\n * Represents an API route discovered in the project\n */\nexport interface ApiRoute {\n  route: string;          // \"/api/users\", \"/api/posts/[id]\"\n  method: string[];       // [\"GET\", \"POST\"] based on exports\n  sourceFile: string;     // \"app/api/users/route.ts\"\n  isDynamic: boolean;     // Has [param] segments\n}\n\n/**\n * Extract the function/component context around a line number\n */\nfunction extractCallerContext(content: string, targetLine: number): string | undefined {\n  const lines = content.split('\\n');\n\n  // Search backwards from target line to find function/component declaration\n  for (let i = targetLine - 1; i >= Math.max(0, targetLine - 30); i--) {\n    const line = lines[i];\n\n    // Match function declarations, arrow functions, and React components\n    const functionMatch = line.match(/(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)/);\n    const arrowMatch = line.match(/(?:export\\s+)?const\\s+(\\w+)\\s*=\\s*(?:async\\s*)?\\(/);\n    const componentMatch = line.match(/(?:export\\s+)?(?:const|function)\\s+([A-Z]\\w+)/);\n\n    if (functionMatch) return functionMatch[1];\n    if (arrowMatch) return arrowMatch[1];\n    if (componentMatch) return componentMatch[1];\n  }\n\n  return undefined;\n}\n\n/**\n * Parse endpoint string, detecting dynamic parts\n */\nfunction parseEndpoint(rawEndpoint: string): { endpoint: string; isDynamic: boolean } {\n  // Check for template literal patterns\n  const hasTemplateLiteral = rawEndpoint.includes('${') || rawEndpoint.includes('`');\n\n  // Check for concatenation patterns\n  const hasConcatenation = /['\"].*\\+|^\\w+$/.test(rawEndpoint);\n\n  if (hasTemplateLiteral || hasConcatenation) {\n    return {\n      endpoint: rawEndpoint.replace(/`/g, '').replace(/\\$\\{[^}]+\\}/g, '{dynamic}'),\n      isDynamic: true\n    };\n  }\n\n  // Clean up quotes\n  return {\n    endpoint: rawEndpoint.replace(/['\"]/g, ''),\n    isDynamic: false\n  };\n}\n\n/**\n * Extract API calls from file content\n */\nfunction extractFromContent(content: string, sourceFile: string): ApiCall[] {\n  const calls: ApiCall[] = [];\n  const lines = content.split('\\n');\n\n  // Pattern 1: fetch() calls\n  // Matches: fetch('/api/users'), fetch(\"/api/users\"), fetch(`/api/${id}`)\n  const fetchPattern = /fetch\\s*\\(\\s*(['\"`])([^'\"`]+)\\1/g;\n  const fetchWithOptionsPattern = /fetch\\s*\\(\\s*(['\"`])([^'\"`]+)\\1\\s*,\\s*\\{[^}]*method\\s*:\\s*['\"](\\w+)['\"]/g;\n\n  // Pattern 2: axios method calls\n  // Matches: axios.get('/api/users'), axios.post('/api/users', data)\n  const axiosPattern = /axios\\.(get|post|put|delete|patch|head|options)\\s*\\(\\s*(['\"`])([^'\"`]+)\\2/g;\n\n  // Pattern 3: axios with method in config\n  // Matches: axios({ url: '/api/users', method: 'POST' })\n  const axiosConfigPattern = /axios\\s*\\(\\s*\\{[^}]*url\\s*:\\s*(['\"`])([^'\"`]+)\\1[^}]*method\\s*:\\s*['\"](\\w+)['\"]/g;\n\n  // Pattern 4: Template literals (more complex)\n  const templateLiteralPattern = /(?:fetch|axios(?:\\.\\w+)?)\\s*\\(\\s*`([^`]+)`/g;\n\n  // Pattern 5: Variable URLs\n  const urlVariablePattern = /const\\s+(\\w*[Uu]rl\\w*)\\s*=\\s*(['\"`])([^'\"`]+)\\2/g;\n  const urlUsagePattern = /(?:fetch|axios(?:\\.\\w+)?)\\s*\\(\\s*(\\w+)/g;\n\n  // Track URL variables\n  const urlVariables = new Map<string, { endpoint: string; lineNumber: number }>();\n\n  // First pass: collect URL variables\n  lines.forEach((line, index) => {\n    let match;\n    const urlVarRegex = new RegExp(urlVariablePattern.source, 'g');\n    while ((match = urlVarRegex.exec(line)) !== null) {\n      urlVariables.set(match[1], {\n        endpoint: match[3],\n        lineNumber: index + 1\n      });\n    }\n  });\n\n  // Second pass: extract API calls\n  lines.forEach((line, index) => {\n    const lineNumber = index + 1;\n\n    // Match fetch with explicit method\n    let match;\n    const fetchOptsRegex = new RegExp(fetchWithOptionsPattern.source, 'g');\n    while ((match = fetchOptsRegex.exec(line)) !== null) {\n      const { endpoint, isDynamic } = parseEndpoint(match[2]);\n      calls.push({\n        endpoint,\n        method: match[3].toUpperCase(),\n        sourceFile,\n        lineNumber,\n        callerContext: extractCallerContext(content, lineNumber),\n        isDynamic\n      });\n    }\n\n    // Match basic fetch (default GET)\n    const fetchRegex = new RegExp(fetchPattern.source, 'g');\n    while ((match = fetchRegex.exec(line)) !== null) {\n      // Skip if already matched with options\n      if (!line.includes('method:')) {\n        const { endpoint, isDynamic } = parseEndpoint(match[2]);\n        calls.push({\n          endpoint,\n          method: 'GET',\n          sourceFile,\n          lineNumber,\n          callerContext: extractCallerContext(content, lineNumber),\n          isDynamic\n        });\n      }\n    }\n\n    // Match axios method calls\n    const axiosRegex = new RegExp(axiosPattern.source, 'g');\n    while ((match = axiosRegex.exec(line)) !== null) {\n      const { endpoint, isDynamic } = parseEndpoint(match[3]);\n      calls.push({\n        endpoint,\n        method: match[1].toUpperCase(),\n        sourceFile,\n        lineNumber,\n        callerContext: extractCallerContext(content, lineNumber),\n        isDynamic\n      });\n    }\n\n    // Match axios config object\n    const axiosConfigRegex = new RegExp(axiosConfigPattern.source, 'g');\n    while ((match = axiosConfigRegex.exec(line)) !== null) {\n      const { endpoint, isDynamic } = parseEndpoint(match[2]);\n      calls.push({\n        endpoint,\n        method: match[3].toUpperCase(),\n        sourceFile,\n        lineNumber,\n        callerContext: extractCallerContext(content, lineNumber),\n        isDynamic\n      });\n    }\n\n    // Match template literals\n    const templateRegex = new RegExp(templateLiteralPattern.source, 'g');\n    while ((match = templateRegex.exec(line)) !== null) {\n      const { endpoint } = parseEndpoint(match[1]);\n\n      // Try to determine method\n      let method = 'GET';\n      const methodMatch = line.match(/method\\s*:\\s*['\"](\\w+)['\"]/);\n      if (methodMatch) {\n        method = methodMatch[1].toUpperCase();\n      }\n\n      calls.push({\n        endpoint,\n        method,\n        sourceFile,\n        lineNumber,\n        callerContext: extractCallerContext(content, lineNumber),\n        isDynamic: true // Template literals are always dynamic\n      });\n    }\n\n    // Match variable usage\n    const urlUsageRegex = new RegExp(urlUsagePattern.source, 'g');\n    while ((match = urlUsageRegex.exec(line)) !== null) {\n      const varName = match[1];\n      if (urlVariables.has(varName)) {\n        const urlInfo = urlVariables.get(varName)!;\n        const { endpoint, isDynamic } = parseEndpoint(urlInfo.endpoint);\n\n        // Try to determine method\n        let method = 'GET';\n        const methodMatch = line.match(/method\\s*:\\s*['\"](\\w+)['\"]/);\n        if (methodMatch) {\n          method = methodMatch[1].toUpperCase();\n        }\n\n        calls.push({\n          endpoint,\n          method,\n          sourceFile,\n          lineNumber,\n          callerContext: extractCallerContext(content, lineNumber),\n          isDynamic\n        });\n      }\n    }\n  });\n\n  // Deduplicate calls (same endpoint, method, and line)\n  const uniqueCalls = calls.filter((call, index, self) =>\n    index === self.findIndex((c) =>\n      c.endpoint === call.endpoint &&\n      c.method === call.method &&\n      c.lineNumber === call.lineNumber\n    )\n  );\n\n  return uniqueCalls;\n}\n\n/**\n * Parse a single file for fetch/axios calls\n *\n * @param filePath - Absolute path to TypeScript/React file\n * @returns Array of API calls found in the file\n */\nexport async function extractApiCalls(filePath: string): Promise<ApiCall[]> {\n  try {\n    const content = await fs.readFile(filePath, 'utf-8');\n    return extractFromContent(content, filePath);\n  } catch (error) {\n    console.error(`Error reading file ${filePath}:`, error);\n    return [];\n  }\n}\n\n/**\n * Recursively scan directory for TypeScript/React files and extract API calls\n *\n * @param dir - Directory to scan\n * @param pattern - File pattern to match (default: TypeScript/React files)\n * @returns Array of all API calls found\n */\nexport async function scanDirectoryForApiCalls(\n  dir: string,\n  _pattern: string = '**/*.{ts,tsx,js,jsx}'\n): Promise<ApiCall[]> {\n  const allCalls: ApiCall[] = [];\n\n  async function scanDir(currentDir: string): Promise<void> {\n    try {\n      const entries = await fs.readdir(currentDir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(currentDir, entry.name);\n\n        if (entry.isDirectory()) {\n          // Skip node_modules, dist, build, .next, etc.\n          const skipDirs = ['node_modules', 'dist', 'build', '.git', 'coverage', '.next', '__tests__', '__mocks__'];\n          if (!skipDirs.includes(entry.name)) {\n            await scanDir(fullPath);\n          }\n        } else if (entry.isFile()) {\n          // Check if file matches pattern\n          const ext = path.extname(entry.name);\n          if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\n            // Skip test files, spec files, and files with example patterns\n            const isTestFile = entry.name.includes('.test.') ||\n                              entry.name.includes('.spec.') ||\n                              entry.name.includes('.mock.') ||\n                              entry.name === 'integration.ts'; // Skip self (contains example patterns)\n            if (!isTestFile) {\n              const calls = await extractApiCalls(fullPath);\n              allCalls.push(...calls);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error scanning directory ${currentDir}:`, error);\n    }\n  }\n\n  await scanDir(dir);\n  return allCalls;\n}\n\n/**\n * Group API calls by endpoint\n */\nexport function groupByEndpoint(calls: ApiCall[]): Map<string, ApiCall[]> {\n  const grouped = new Map<string, ApiCall[]>();\n\n  for (const call of calls) {\n    const key = call.endpoint;\n    if (!grouped.has(key)) {\n      grouped.set(key, []);\n    }\n    grouped.get(key)!.push(call);\n  }\n\n  return grouped;\n}\n\n/**\n * Group API calls by source file\n */\nexport function groupByFile(calls: ApiCall[]): Map<string, ApiCall[]> {\n  const grouped = new Map<string, ApiCall[]>();\n\n  for (const call of calls) {\n    const key = call.sourceFile;\n    if (!grouped.has(key)) {\n      grouped.set(key, []);\n    }\n    grouped.get(key)!.push(call);\n  }\n\n  return grouped;\n}\n\n/**\n * Filter calls to only include specific HTTP methods\n */\nexport function filterByMethod(calls: ApiCall[], methods: string[]): ApiCall[] {\n  const upperMethods = methods.map(m => m.toUpperCase());\n  return calls.filter(call => upperMethods.includes(call.method));\n}\n\n/**\n * Filter calls to only include specific endpoints (supports wildcards)\n */\nexport function filterByEndpoint(calls: ApiCall[], endpointPattern: string): ApiCall[] {\n  const regex = new RegExp(\n    '^' + endpointPattern.replace(/\\*/g, '.*').replace(/\\?/g, '.') + '$'\n  );\n  return calls.filter(call => regex.test(call.endpoint));\n}\n\n/**\n * Discover API routes from Next.js/Remix file structure\n * Supports Next.js App Router (app/api) and Pages Router (pages/api)\n * Also searches subdirectories (like web-ui/) for nested Next.js apps\n */\nexport async function discoverApiRoutes(projectDir: string): Promise<ApiRoute[]> {\n  const routes: ApiRoute[] = [];\n\n  // Discover routes in a specific directory\n  async function discoverInDir(dir: string): Promise<void> {\n    // Check for Next.js App Router (app/api/**/route.ts)\n    const appApiDir = path.join(dir, 'app', 'api');\n    if (await directoryExists(appApiDir)) {\n      const appRoutes = await discoverAppRouterRoutes(appApiDir, dir);\n      routes.push(...appRoutes);\n    }\n\n    // Check for Next.js Pages Router (pages/api/**/*.ts)\n    const pagesApiDir = path.join(dir, 'pages', 'api');\n    if (await directoryExists(pagesApiDir)) {\n      const pagesRoutes = await discoverPagesRouterRoutes(pagesApiDir, dir);\n      routes.push(...pagesRoutes);\n    }\n\n    // Check for src directory variants\n    const srcAppApiDir = path.join(dir, 'src', 'app', 'api');\n    if (await directoryExists(srcAppApiDir)) {\n      const srcAppRoutes = await discoverAppRouterRoutes(srcAppApiDir, dir);\n      routes.push(...srcAppRoutes);\n    }\n\n    const srcPagesApiDir = path.join(dir, 'src', 'pages', 'api');\n    if (await directoryExists(srcPagesApiDir)) {\n      const srcPagesRoutes = await discoverPagesRouterRoutes(srcPagesApiDir, dir);\n      routes.push(...srcPagesRoutes);\n    }\n  }\n\n  // Discover in project root\n  await discoverInDir(projectDir);\n\n  // Also check subdirectories for nested apps (e.g., web-ui/, frontend/, client/)\n  try {\n    const entries = await fs.readdir(projectDir, { withFileTypes: true });\n    const skipDirs = ['node_modules', 'dist', 'build', '.git', 'coverage', '.next'];\n\n    for (const entry of entries) {\n      if (entry.isDirectory() && !skipDirs.includes(entry.name)) {\n        const subDir = path.join(projectDir, entry.name);\n\n        // Check if this subdir has a package.json (indicating it's a sub-project)\n        const hasPackageJson = await fileExists(path.join(subDir, 'package.json'));\n        if (hasPackageJson) {\n          await discoverInDir(subDir);\n        }\n      }\n    }\n  } catch {\n    // Ignore errors reading directory\n  }\n\n  return routes;\n}\n\n/**\n * Check if a file exists\n */\nasync function fileExists(filePath: string): Promise<boolean> {\n  try {\n    const stat = await fs.stat(filePath);\n    return stat.isFile();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Convert file path to API route\n * Examples:\n * - app/api/users/route.ts -> /api/users\n * - app/api/users/[id]/route.ts -> /api/users/[id]\n * - pages/api/users.ts -> /api/users\n * - pages/api/users/[id].ts -> /api/users/[id]\n */\nexport function filePathToRoute(filePath: string, projectDir: string): string {\n  // Normalize paths\n  const normalizedFilePath = path.normalize(filePath);\n  const normalizedProjectDir = path.normalize(projectDir);\n\n  // Get relative path from project root\n  const relativePath = path.relative(normalizedProjectDir, normalizedFilePath);\n\n  // Remove file extension\n  let routePath = relativePath.replace(/\\.(ts|tsx|js|jsx)$/, '');\n\n  // Handle App Router (remove 'route' filename)\n  routePath = routePath.replace(/\\/route$/, '');\n  routePath = routePath.replace(/\\\\route$/, ''); // Windows paths\n\n  // Extract the API portion\n  let apiPath = '';\n\n  if (routePath.includes('app/api/') || routePath.includes('app\\\\api\\\\')) {\n    apiPath = routePath.split(/app[/\\\\]api[/\\\\]/)[1] || '';\n  } else if (routePath.includes('src/app/api/') || routePath.includes('src\\\\app\\\\api\\\\')) {\n    apiPath = routePath.split(/src[/\\\\]app[/\\\\]api[/\\\\]/)[1] || '';\n  } else if (routePath.includes('pages/api/') || routePath.includes('pages\\\\api\\\\')) {\n    apiPath = routePath.split(/pages[/\\\\]api[/\\\\]/)[1] || '';\n  } else if (routePath.includes('src/pages/api/') || routePath.includes('src\\\\pages\\\\api\\\\')) {\n    apiPath = routePath.split(/src[/\\\\]pages[/\\\\]api[/\\\\]/)[1] || '';\n  }\n\n  // Convert to route format (normalize path separators)\n  const route = '/api/' + (apiPath ? apiPath.replace(/\\\\/g, '/') : '');\n\n  return route;\n}\n\n/**\n * Cross-reference API calls against routes, return orphans\n */\nexport function findOrphanEndpoints(\n  apiCalls: ApiCall[],\n  apiRoutes: ApiRoute[]\n): { call: ApiCall; searchedLocations: string[] }[] {\n  const orphans: { call: ApiCall; searchedLocations: string[] }[] = [];\n\n  for (const call of apiCalls) {\n    const endpoint = call.endpoint;\n\n    // Skip non-API endpoints (external URLs, relative paths without /api)\n    if (!endpoint.startsWith('/api') && !endpoint.includes('/api/')) {\n      continue;\n    }\n\n    // Skip dynamic endpoints that are just placeholders\n    if (endpoint.includes('{dynamic}')) {\n      continue;\n    }\n\n    // Extract the API path\n    let apiPath = endpoint;\n    if (endpoint.includes('/api/')) {\n      apiPath = '/api/' + endpoint.split('/api/')[1].split('?')[0]; // Remove query params\n    }\n\n    // Try to match against routes\n    const matchedRoute = apiRoutes.find(route => {\n      // Check if methods match\n      const methodMatches = route.method.includes(call.method) ||\n                           route.method.includes('ALL');\n      if (!methodMatches) {\n        return false;\n      }\n      // Check if route pattern matches endpoint\n      return routeMatchesEndpoint(route.route, apiPath);\n    });\n\n    if (!matchedRoute) {\n      // Generate possible file locations\n      const searchedLocations = generatePossibleRouteFiles(apiPath);\n\n      orphans.push({\n        call,\n        searchedLocations\n      });\n    }\n  }\n\n  return orphans;\n}\n\n/**\n * Check if a route pattern matches an endpoint\n * Handles dynamic segments like [id], [slug], etc.\n */\nfunction routeMatchesEndpoint(routePattern: string, endpoint: string): boolean {\n  const routeParts = routePattern.split('/').filter(Boolean);\n  const endpointParts = endpoint.split('/').filter(Boolean);\n\n  if (routeParts.length !== endpointParts.length) {\n    return false;\n  }\n\n  for (let i = 0; i < routeParts.length; i++) {\n    const routePart = routeParts[i];\n    const endpointPart = endpointParts[i];\n\n    // Dynamic segment matches anything\n    if (routePart.startsWith('[') && routePart.endsWith(']')) {\n      continue;\n    }\n\n    // Static segment must match exactly\n    if (routePart !== endpointPart) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Generate possible file locations for an API endpoint\n */\nfunction generatePossibleRouteFiles(apiPath: string): string[] {\n  const pathWithoutApi = apiPath.replace(/^\\/api\\//, '');\n  const locations: string[] = [];\n\n  // Next.js App Router possibilities\n  locations.push(`app/api/${pathWithoutApi}/route.ts`);\n  locations.push(`app/api/${pathWithoutApi}/route.js`);\n  locations.push(`src/app/api/${pathWithoutApi}/route.ts`);\n  locations.push(`src/app/api/${pathWithoutApi}/route.js`);\n\n  // Next.js Pages Router possibilities\n  locations.push(`pages/api/${pathWithoutApi}.ts`);\n  locations.push(`pages/api/${pathWithoutApi}.js`);\n  locations.push(`src/pages/api/${pathWithoutApi}.ts`);\n  locations.push(`src/pages/api/${pathWithoutApi}.js`);\n\n  return locations;\n}\n\n/**\n * Discover routes in Next.js App Router format\n */\nasync function discoverAppRouterRoutes(\n  apiDir: string,\n  projectDir: string\n): Promise<ApiRoute[]> {\n  const routes: ApiRoute[] = [];\n\n  try {\n    const files = await findRouteFiles(apiDir, 'route');\n\n    for (const file of files) {\n      const content = await fs.readFile(file, 'utf-8');\n      const methods = extractHttpMethods(content);\n      const route = filePathToRoute(file, projectDir);\n      const isDynamic = route.includes('[') && route.includes(']');\n\n      if (methods.length > 0) {\n        routes.push({\n          route,\n          method: methods,\n          sourceFile: file,\n          isDynamic\n        });\n      }\n    }\n  } catch (error) {\n    // Directory doesn't exist or not accessible\n  }\n\n  return routes;\n}\n\n/**\n * Discover routes in Next.js Pages Router format\n */\nasync function discoverPagesRouterRoutes(\n  apiDir: string,\n  projectDir: string\n): Promise<ApiRoute[]> {\n  const routes: ApiRoute[] = [];\n\n  try {\n    const files = await findRouteFiles(apiDir);\n\n    for (const file of files) {\n      const content = await fs.readFile(file, 'utf-8');\n      const methods = extractHttpMethods(content);\n      const route = filePathToRoute(file, projectDir);\n      const isDynamic = route.includes('[') && route.includes(']');\n\n      // Pages Router typically uses default export with req.method check\n      // If we find method checks or it has a default export, include it\n      if (methods.length > 0 || content.includes('export default')) {\n        routes.push({\n          route,\n          method: methods.length > 0 ? methods : ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n          sourceFile: file,\n          isDynamic\n        });\n      }\n    }\n  } catch (error) {\n    // Directory doesn't exist or not accessible\n  }\n\n  return routes;\n}\n\n/**\n * Find all route files in a directory recursively\n */\nasync function findRouteFiles(\n  dir: string,\n  filename?: string\n): Promise<string[]> {\n  const files: string[] = [];\n\n  try {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        const subFiles = await findRouteFiles(fullPath, filename);\n        files.push(...subFiles);\n      } else if (entry.isFile()) {\n        const ext = path.extname(entry.name);\n        const baseName = path.basename(entry.name, ext);\n\n        if (['.ts', '.tsx', '.js', '.jsx'].includes(ext)) {\n          if (filename) {\n            // Looking for specific filename (e.g., 'route.ts')\n            if (baseName === filename) {\n              files.push(fullPath);\n            }\n          } else {\n            // Include all TypeScript/JavaScript files\n            files.push(fullPath);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // Directory doesn't exist or not accessible\n  }\n\n  return files;\n}\n\n/**\n * Extract HTTP method exports from file content\n */\nfunction extractHttpMethods(content: string): string[] {\n  const methods: string[] = [];\n  const httpMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];\n\n  for (const method of httpMethods) {\n    // Look for exported functions: export async function GET\n    const exportPattern = new RegExp(`export\\\\s+(?:async\\\\s+)?function\\\\s+${method}\\\\s*\\\\(`, 'g');\n    if (exportPattern.test(content)) {\n      methods.push(method);\n    }\n  }\n\n  return methods;\n}\n\n/**\n * Check if a directory exists\n */\nasync function directoryExists(dir: string): Promise<boolean> {\n  try {\n    const stat = await fs.stat(dir);\n    return stat.isDirectory();\n  } catch {\n    return false;\n  }\n}\n\n// TODO: Iteration 3 - Add matching between frontend API calls and backend routes (DONE via findOrphanEndpoints)\n// TODO: Iteration 4 - Add OpenAPI/Swagger schema generation from discovered routes\n","import type { Page } from 'playwright';\n\n/**\n * Web Vitals metrics\n * @see https://web.dev/vitals/\n */\nexport interface WebVitals {\n  /** Largest Contentful Paint (ms) - loading performance */\n  LCP: number | null;\n  /** First Input Delay (ms) - interactivity (requires user interaction) */\n  FID: number | null;\n  /** Cumulative Layout Shift (score) - visual stability */\n  CLS: number | null;\n  /** Time to First Byte (ms) - server response time */\n  TTFB: number | null;\n  /** First Contentful Paint (ms) - initial render */\n  FCP: number | null;\n  /** Time to Interactive (ms) - when page becomes fully interactive */\n  TTI: number | null;\n}\n\n/**\n * Performance thresholds for each metric\n * Based on Core Web Vitals guidelines\n */\nexport const PERFORMANCE_THRESHOLDS = {\n  LCP: { good: 2500, poor: 4000 },\n  FID: { good: 100, poor: 300 },\n  CLS: { good: 0.1, poor: 0.25 },\n  TTFB: { good: 800, poor: 1800 },\n  FCP: { good: 1800, poor: 3000 },\n  TTI: { good: 3800, poor: 7300 },\n};\n\n/**\n * Performance rating\n */\nexport type PerformanceRating = 'good' | 'needs-improvement' | 'poor';\n\n/**\n * Rated metric with value and rating\n */\nexport interface RatedMetric {\n  value: number | null;\n  rating: PerformanceRating | null;\n}\n\n/**\n * Full performance result with ratings\n */\nexport interface PerformanceResult {\n  metrics: WebVitals;\n  ratings: Record<keyof WebVitals, RatedMetric>;\n  summary: {\n    overallRating: PerformanceRating;\n    passedVitals: number;\n    totalVitals: number;\n    issues: string[];\n    recommendations: string[];\n  };\n}\n\n/**\n * Rate a metric value against thresholds\n */\nfunction rateMetric(\n  value: number | null,\n  thresholds: { good: number; poor: number }\n): PerformanceRating | null {\n  if (value === null) return null;\n  if (value <= thresholds.good) return 'good';\n  if (value <= thresholds.poor) return 'needs-improvement';\n  return 'poor';\n}\n\n/**\n * Measure Core Web Vitals from a page\n *\n * Note: FID requires actual user interaction, so it will be null\n * for automated tests. Use TTI as an alternative measure.\n */\nexport async function measureWebVitals(page: Page): Promise<WebVitals> {\n  const metrics = await page.evaluate(() => {\n    return new Promise<WebVitals>((resolve) => {\n      const result: WebVitals = {\n        LCP: null,\n        FID: null,\n        CLS: null,\n        TTFB: null,\n        FCP: null,\n        TTI: null,\n      };\n\n      // Get navigation timing for TTFB\n      const navEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n      if (navEntry) {\n        result.TTFB = navEntry.responseStart - navEntry.requestStart;\n      }\n\n      // Get paint timing for FCP\n      const paintEntries = performance.getEntriesByType('paint');\n      const fcpEntry = paintEntries.find(e => e.name === 'first-contentful-paint');\n      if (fcpEntry) {\n        result.FCP = fcpEntry.startTime;\n      }\n\n      // Use PerformanceObserver for LCP and CLS\n      let lcpValue: number | null = null;\n      let clsValue = 0;\n\n      // LCP observer\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries[entries.length - 1];\n        if (lastEntry) {\n          lcpValue = lastEntry.startTime;\n        }\n      });\n\n      // CLS observer\n      const clsObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          // @ts-ignore - hadRecentInput is a valid property for layout-shift entries\n          if (!entry.hadRecentInput) {\n            // @ts-ignore - value is a valid property for layout-shift entries\n            clsValue += entry.value;\n          }\n        }\n      });\n\n      try {\n        lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });\n      } catch {\n        // LCP not supported\n      }\n\n      try {\n        clsObserver.observe({ type: 'layout-shift', buffered: true });\n      } catch {\n        // CLS not supported\n      }\n\n      // Wait for metrics to stabilize, then return\n      setTimeout(() => {\n        lcpObserver.disconnect();\n        clsObserver.disconnect();\n\n        result.LCP = lcpValue;\n        result.CLS = clsValue;\n\n        // Estimate TTI from navigation timing\n        if (navEntry) {\n          // TTI approximation: domInteractive + longest task estimate\n          result.TTI = navEntry.domInteractive;\n        }\n\n        resolve(result);\n      }, 3000); // Wait 3s for metrics\n    });\n  });\n\n  return metrics;\n}\n\n/**\n * Measure performance and return rated results\n */\nexport async function measurePerformance(page: Page): Promise<PerformanceResult> {\n  const metrics = await measureWebVitals(page);\n\n  // Rate each metric\n  const ratings: Record<keyof WebVitals, RatedMetric> = {\n    LCP: { value: metrics.LCP, rating: rateMetric(metrics.LCP, PERFORMANCE_THRESHOLDS.LCP) },\n    FID: { value: metrics.FID, rating: rateMetric(metrics.FID, PERFORMANCE_THRESHOLDS.FID) },\n    CLS: { value: metrics.CLS, rating: rateMetric(metrics.CLS, PERFORMANCE_THRESHOLDS.CLS) },\n    TTFB: { value: metrics.TTFB, rating: rateMetric(metrics.TTFB, PERFORMANCE_THRESHOLDS.TTFB) },\n    FCP: { value: metrics.FCP, rating: rateMetric(metrics.FCP, PERFORMANCE_THRESHOLDS.FCP) },\n    TTI: { value: metrics.TTI, rating: rateMetric(metrics.TTI, PERFORMANCE_THRESHOLDS.TTI) },\n  };\n\n  // Generate summary\n  const issues: string[] = [];\n  const recommendations: string[] = [];\n  let passedVitals = 0;\n  let totalVitals = 0;\n\n  // Core Web Vitals: LCP, CLS (FID requires interaction)\n  const coreVitals: (keyof WebVitals)[] = ['LCP', 'CLS', 'TTFB', 'FCP'];\n\n  for (const vital of coreVitals) {\n    const rated = ratings[vital];\n    if (rated.value !== null) {\n      totalVitals++;\n      if (rated.rating === 'good') {\n        passedVitals++;\n      } else if (rated.rating === 'poor') {\n        issues.push(`${vital} is poor (${formatMetric(vital, rated.value)})`);\n        recommendations.push(getRecommendation(vital));\n      } else if (rated.rating === 'needs-improvement') {\n        issues.push(`${vital} needs improvement (${formatMetric(vital, rated.value)})`);\n      }\n    }\n  }\n\n  // Calculate overall rating\n  const poorCount = Object.values(ratings).filter(r => r.rating === 'poor').length;\n  const needsImprovementCount = Object.values(ratings).filter(r => r.rating === 'needs-improvement').length;\n\n  let overallRating: PerformanceRating = 'good';\n  if (poorCount > 0) {\n    overallRating = 'poor';\n  } else if (needsImprovementCount > 0) {\n    overallRating = 'needs-improvement';\n  }\n\n  return {\n    metrics,\n    ratings,\n    summary: {\n      overallRating,\n      passedVitals,\n      totalVitals,\n      issues,\n      recommendations,\n    },\n  };\n}\n\n/**\n * Format a metric value for display\n */\nfunction formatMetric(name: keyof WebVitals, value: number): string {\n  if (name === 'CLS') {\n    return value.toFixed(3);\n  }\n  return `${Math.round(value)}ms`;\n}\n\n/**\n * Get improvement recommendation for a metric\n */\nfunction getRecommendation(metric: keyof WebVitals): string {\n  const recommendations: Record<keyof WebVitals, string> = {\n    LCP: 'Optimize largest image/text block: use lazy loading, preload critical assets, optimize server response',\n    FID: 'Reduce JavaScript execution time: split code, defer non-critical JS, use web workers',\n    CLS: 'Reserve space for dynamic content: set explicit dimensions for images/ads/embeds',\n    TTFB: 'Improve server response: use CDN, optimize database queries, enable caching',\n    FCP: 'Eliminate render-blocking resources: inline critical CSS, defer non-critical JS',\n    TTI: 'Reduce main thread work: minimize/defer JavaScript, reduce DOM size',\n  };\n  return recommendations[metric];\n}\n\n/**\n * Format performance result for console output\n */\nexport function formatPerformanceResult(result: PerformanceResult): string {\n  const lines: string[] = [];\n\n  lines.push('Performance Metrics');\n  lines.push('===================');\n  lines.push('');\n\n  // Overall rating\n  const ratingIcon = result.summary.overallRating === 'good' ? '‚úì' :\n                     result.summary.overallRating === 'needs-improvement' ? '~' : '‚úó';\n  const ratingColor = result.summary.overallRating === 'good' ? '\\x1b[32m' :\n                      result.summary.overallRating === 'needs-improvement' ? '\\x1b[33m' : '\\x1b[31m';\n  lines.push(`Overall: ${ratingColor}${ratingIcon} ${result.summary.overallRating.toUpperCase()}\\x1b[0m`);\n  lines.push(`Passed: ${result.summary.passedVitals}/${result.summary.totalVitals} core vitals`);\n  lines.push('');\n\n  // Individual metrics\n  lines.push('Core Web Vitals:');\n  const vitals: (keyof WebVitals)[] = ['LCP', 'FCP', 'TTFB', 'CLS'];\n  for (const vital of vitals) {\n    const rated = result.ratings[vital];\n    if (rated.value !== null) {\n      const icon = rated.rating === 'good' ? '‚úì' :\n                   rated.rating === 'needs-improvement' ? '~' : '‚úó';\n      const color = rated.rating === 'good' ? '\\x1b[32m' :\n                    rated.rating === 'needs-improvement' ? '\\x1b[33m' : '\\x1b[31m';\n      lines.push(`  ${color}${icon}\\x1b[0m ${vital}: ${formatMetric(vital, rated.value)}`);\n    }\n  }\n\n  // Issues\n  if (result.summary.issues.length > 0) {\n    lines.push('');\n    lines.push('Issues:');\n    for (const issue of result.summary.issues) {\n      lines.push(`  ! ${issue}`);\n    }\n  }\n\n  // Recommendations\n  if (result.summary.recommendations.length > 0) {\n    lines.push('');\n    lines.push('Recommendations:');\n    for (const rec of result.summary.recommendations) {\n      lines.push(`  -> ${rec}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","import type { Page } from 'playwright';\n\n/**\n * Interactive element info\n */\nexport interface InteractiveElement {\n  selector: string;\n  tagName: string;\n  type?: string;\n  text?: string;\n  hasHandler: boolean;\n  isDisabled: boolean;\n  isVisible: boolean;\n  a11y: {\n    role?: string;\n    ariaLabel?: string;\n    tabIndex?: number;\n  };\n}\n\n/**\n * Button analysis result\n */\nexport interface ButtonInfo extends InteractiveElement {\n  buttonType?: 'submit' | 'button' | 'reset';\n  formId?: string;\n}\n\n/**\n * Link analysis result\n */\nexport interface LinkInfo extends InteractiveElement {\n  href: string;\n  isPlaceholder: boolean;\n  opensNewTab: boolean;\n  isExternal: boolean;\n}\n\n/**\n * Form analysis result\n */\nexport interface FormInfo {\n  selector: string;\n  action?: string;\n  method?: string;\n  hasSubmitHandler: boolean;\n  fields: FormFieldInfo[];\n  hasValidation: boolean;\n  submitButton?: ButtonInfo;\n}\n\n/**\n * Form field info\n */\nexport interface FormFieldInfo {\n  selector: string;\n  name?: string;\n  type: string;\n  label?: string;\n  required: boolean;\n  hasValidation: boolean;\n}\n\n/**\n * Interactivity issue\n */\nexport interface InteractivityIssue {\n  type: 'NO_HANDLER' | 'PLACEHOLDER_LINK' | 'MISSING_LABEL' | 'DISABLED_NO_VISUAL' |\n        'SMALL_TOUCH_TARGET' | 'FORM_NO_SUBMIT' | 'ORPHAN_SUBMIT' | 'NO_KEYBOARD_ACCESS';\n  element: string;\n  severity: 'error' | 'warning' | 'info';\n  description: string;\n}\n\n/**\n * Full interactivity test result\n */\nexport interface InteractivityResult {\n  buttons: ButtonInfo[];\n  links: LinkInfo[];\n  forms: FormInfo[];\n  issues: InteractivityIssue[];\n  summary: {\n    totalInteractive: number;\n    withHandlers: number;\n    withoutHandlers: number;\n    issueCount: {\n      error: number;\n      warning: number;\n      info: number;\n    };\n  };\n}\n\n/**\n * Test interactivity of all interactive elements on a page\n */\nexport async function testInteractivity(page: Page): Promise<InteractivityResult> {\n  const data = await page.evaluate(() => {\n    const results: {\n      buttons: ButtonInfo[];\n      links: LinkInfo[];\n      forms: FormInfo[];\n    } = {\n      buttons: [],\n      links: [],\n      forms: [],\n    };\n\n    // Helper to check if element has event handlers\n    function hasEventHandler(el: Element): boolean {\n      // Check for inline handlers\n      const inlineHandlers = ['onclick', 'onmousedown', 'onmouseup', 'ontouchstart', 'ontouchend'];\n      for (const handler of inlineHandlers) {\n        if (el.getAttribute(handler)) return true;\n      }\n\n      // Check for common framework patterns\n      const attrs = Array.from(el.attributes).map(a => a.name);\n      const frameworkPatterns = ['@click', 'v-on:click', 'ng-click', '(click)'];\n      for (const pattern of frameworkPatterns) {\n        if (attrs.some(a => a.includes(pattern) || a.startsWith(pattern))) return true;\n      }\n\n      // Check for data attributes that suggest handlers\n      if (el.getAttribute('data-action') || el.getAttribute('data-onclick')) return true;\n\n      // Can't detect addEventListener from DOM, assume true for semantic elements\n      const tagName = el.tagName.toLowerCase();\n      if (tagName === 'a' && (el as HTMLAnchorElement).href) return true;\n      if (tagName === 'button') return true;\n      if (tagName === 'input' && ['submit', 'button'].includes((el as HTMLInputElement).type)) return true;\n\n      return false;\n    }\n\n    // Helper to get unique selector\n    function getSelector(el: Element): string {\n      if (el.id) return `#${el.id}`;\n      const classes = Array.from(el.classList).slice(0, 2).join('.');\n      const tag = el.tagName.toLowerCase();\n      if (classes) return `${tag}.${classes}`;\n      return tag;\n    }\n\n    // Helper to check visibility\n    function isVisible(el: Element): boolean {\n      const style = window.getComputedStyle(el);\n      const rect = el.getBoundingClientRect();\n      return style.display !== 'none' &&\n             style.visibility !== 'hidden' &&\n             style.opacity !== '0' &&\n             rect.width > 0 &&\n             rect.height > 0;\n    }\n\n    // Analyze buttons\n    const buttons = Array.from(document.querySelectorAll('button, [role=\"button\"], input[type=\"button\"], input[type=\"submit\"]'));\n    for (const btn of buttons) {\n      const el = btn as HTMLButtonElement | HTMLInputElement;\n      results.buttons.push({\n        selector: getSelector(el),\n        tagName: el.tagName.toLowerCase(),\n        type: el.type || undefined,\n        text: el.textContent?.trim() || (el as HTMLInputElement).value || undefined,\n        hasHandler: hasEventHandler(el),\n        isDisabled: el.disabled || el.getAttribute('aria-disabled') === 'true',\n        isVisible: isVisible(el),\n        a11y: {\n          role: el.getAttribute('role') || undefined,\n          ariaLabel: el.getAttribute('aria-label') || undefined,\n          tabIndex: el.tabIndex,\n        },\n        buttonType: (el as HTMLButtonElement).type as 'submit' | 'button' | 'reset' || undefined,\n        formId: el.form?.id || undefined,\n      });\n    }\n\n    // Analyze links\n    const links = Array.from(document.querySelectorAll('a[href]'));\n    for (const link of links) {\n      const el = link as HTMLAnchorElement;\n      const href = el.getAttribute('href') || '';\n      const isPlaceholder = href === '#' || href === '' || href === 'javascript:void(0)';\n\n      results.links.push({\n        selector: getSelector(el),\n        tagName: 'a',\n        text: el.textContent?.trim() || undefined,\n        hasHandler: hasEventHandler(el) || !isPlaceholder,\n        isDisabled: el.getAttribute('aria-disabled') === 'true',\n        isVisible: isVisible(el),\n        a11y: {\n          role: el.getAttribute('role') || undefined,\n          ariaLabel: el.getAttribute('aria-label') || undefined,\n          tabIndex: el.tabIndex,\n        },\n        href,\n        isPlaceholder,\n        opensNewTab: el.target === '_blank',\n        isExternal: el.hostname !== window.location.hostname,\n      });\n    }\n\n    // Analyze forms\n    const forms = Array.from(document.querySelectorAll('form'));\n    for (const form of forms) {\n      const el = form as HTMLFormElement;\n      const fields: FormFieldInfo[] = [];\n\n      // Get form fields\n      const inputs = Array.from(el.querySelectorAll('input, select, textarea'));\n      for (const input of inputs) {\n        const field = input as HTMLInputElement;\n        if (['hidden', 'submit', 'button'].includes(field.type)) continue;\n\n        const labelEl = el.querySelector(`label[for=\"${field.id}\"]`) ||\n                        field.closest('label');\n\n        fields.push({\n          selector: getSelector(field),\n          name: field.name || undefined,\n          type: field.type || field.tagName.toLowerCase(),\n          label: labelEl?.textContent?.trim() || undefined,\n          required: field.required,\n          hasValidation: field.hasAttribute('pattern') ||\n                         field.hasAttribute('min') ||\n                         field.hasAttribute('max') ||\n                         field.hasAttribute('minlength') ||\n                         field.hasAttribute('maxlength'),\n        });\n      }\n\n      // Find submit button\n      const submitBtn = el.querySelector('button[type=\"submit\"], input[type=\"submit\"]');\n      let submitInfo: ButtonInfo | undefined;\n      if (submitBtn) {\n        const btn = submitBtn as HTMLButtonElement;\n        submitInfo = {\n          selector: getSelector(btn),\n          tagName: btn.tagName.toLowerCase(),\n          text: btn.textContent?.trim() || (btn as HTMLInputElement).value || undefined,\n          hasHandler: hasEventHandler(btn),\n          isDisabled: btn.disabled,\n          isVisible: isVisible(btn),\n          a11y: {\n            role: btn.getAttribute('role') || undefined,\n            ariaLabel: btn.getAttribute('aria-label') || undefined,\n          },\n          buttonType: 'submit',\n        };\n      }\n\n      // Check for submit handler on form\n      const hasSubmitHandler = hasEventHandler(el) ||\n                               el.getAttribute('action') !== null ||\n                               submitBtn !== null;\n\n      results.forms.push({\n        selector: getSelector(el),\n        action: el.action || undefined,\n        method: el.method || undefined,\n        hasSubmitHandler,\n        fields,\n        hasValidation: fields.some(f => f.hasValidation || f.required),\n        submitButton: submitInfo,\n      });\n    }\n\n    return results;\n  });\n\n  // Analyze for issues\n  const issues: InteractivityIssue[] = [];\n\n  // Check buttons\n  for (const btn of data.buttons) {\n    if (!btn.hasHandler && !btn.isDisabled) {\n      issues.push({\n        type: 'NO_HANDLER',\n        element: btn.selector,\n        severity: 'warning',\n        description: `Button \"${btn.text || btn.selector}\" has no click handler`,\n      });\n    }\n\n    if (btn.isDisabled && btn.isVisible) {\n      // Check if disabled state is visually indicated\n      // This is a heuristic - we can't fully check CSS from here\n    }\n\n    if (!btn.a11y.ariaLabel && !btn.text) {\n      issues.push({\n        type: 'MISSING_LABEL',\n        element: btn.selector,\n        severity: 'error',\n        description: `Button has no accessible label (no text or aria-label)`,\n      });\n    }\n  }\n\n  // Check links\n  for (const link of data.links) {\n    if (link.isPlaceholder && !link.hasHandler) {\n      issues.push({\n        type: 'PLACEHOLDER_LINK',\n        element: link.selector,\n        severity: 'error',\n        description: `Link \"${link.text || link.selector}\" has placeholder href without handler`,\n      });\n    }\n\n    if (!link.a11y.ariaLabel && !link.text) {\n      issues.push({\n        type: 'MISSING_LABEL',\n        element: link.selector,\n        severity: 'error',\n        description: `Link has no accessible label (no text or aria-label)`,\n      });\n    }\n  }\n\n  // Check forms\n  for (const form of data.forms) {\n    if (!form.hasSubmitHandler) {\n      issues.push({\n        type: 'FORM_NO_SUBMIT',\n        element: form.selector,\n        severity: 'warning',\n        description: `Form has no submit handler or action`,\n      });\n    }\n\n    // Check for labels on fields\n    for (const field of form.fields) {\n      if (!field.label && field.type !== 'hidden') {\n        issues.push({\n          type: 'MISSING_LABEL',\n          element: field.selector,\n          severity: 'warning',\n          description: `Form field \"${field.name || field.selector}\" has no label`,\n        });\n      }\n    }\n  }\n\n  // Calculate summary\n  const allInteractive = [...data.buttons, ...data.links];\n  const withHandlers = allInteractive.filter(e => e.hasHandler).length;\n\n  return {\n    buttons: data.buttons,\n    links: data.links,\n    forms: data.forms,\n    issues,\n    summary: {\n      totalInteractive: allInteractive.length,\n      withHandlers,\n      withoutHandlers: allInteractive.length - withHandlers,\n      issueCount: {\n        error: issues.filter(i => i.severity === 'error').length,\n        warning: issues.filter(i => i.severity === 'warning').length,\n        info: issues.filter(i => i.severity === 'info').length,\n      },\n    },\n  };\n}\n\n/**\n * Format interactivity result for console output\n */\nexport function formatInteractivityResult(result: InteractivityResult): string {\n  const lines: string[] = [];\n\n  lines.push('Interactivity Analysis');\n  lines.push('======================');\n  lines.push('');\n\n  // Summary\n  lines.push(`Total interactive elements: ${result.summary.totalInteractive}`);\n  lines.push(`  With handlers: ${result.summary.withHandlers}`);\n  lines.push(`  Without handlers: ${result.summary.withoutHandlers}`);\n  lines.push('');\n\n  // Breakdown\n  lines.push(`Buttons: ${result.buttons.length}`);\n  lines.push(`Links: ${result.links.length}`);\n  lines.push(`Forms: ${result.forms.length}`);\n  lines.push('');\n\n  // Forms detail\n  if (result.forms.length > 0) {\n    lines.push('Forms:');\n    for (const form of result.forms) {\n      const icon = form.hasSubmitHandler ? '‚úì' : '!';\n      lines.push(`  ${icon} ${form.selector} (${form.fields.length} fields)`);\n    }\n    lines.push('');\n  }\n\n  // Issues\n  if (result.issues.length > 0) {\n    lines.push('Issues:');\n    for (const issue of result.issues) {\n      const icon = issue.severity === 'error' ? '\\x1b[31m‚úó\\x1b[0m' :\n                   issue.severity === 'warning' ? '\\x1b[33m!\\x1b[0m' : 'i';\n      lines.push(`  ${icon} [${issue.type}] ${issue.description}`);\n    }\n  } else {\n    lines.push('No issues detected.');\n  }\n\n  return lines.join('\\n');\n}\n","import type { Page, Request, Response } from 'playwright';\n\n/**\n * API request timing info\n */\nexport interface ApiRequestTiming {\n  url: string;\n  method: string;\n  duration: number;\n  status: number;\n  size: number;\n  resourceType: string;\n  timing: {\n    dnsLookup?: number;\n    tcpConnect?: number;\n    tlsHandshake?: number;\n    requestSent?: number;\n    waiting?: number;\n    contentDownload?: number;\n  };\n}\n\n/**\n * API timing measurement result\n */\nexport interface ApiTimingResult {\n  requests: ApiRequestTiming[];\n  summary: {\n    totalRequests: number;\n    totalTime: number;\n    totalSize: number;\n    averageTime: number;\n    slowestRequest: { url: string; duration: number } | null;\n    fastestRequest: { url: string; duration: number } | null;\n    failedRequests: number;\n    byStatus: Record<number, number>;\n  };\n}\n\n/**\n * Options for API timing measurement\n */\nexport interface ApiTimingOptions {\n  /** Filter to only track URLs matching this pattern */\n  filter?: RegExp;\n  /** Include static resources (images, fonts, etc.) */\n  includeStatic?: boolean;\n  /** Timeout to wait for requests to complete (ms) */\n  timeout?: number;\n  /** Minimum duration to report (ms) - filters out fast requests */\n  minDuration?: number;\n}\n\n/**\n * Measure API/network request timing on a page\n *\n * Call this before navigating to the page, then call stopMeasuring after navigation\n */\nexport async function measureApiTiming(\n  page: Page,\n  options: ApiTimingOptions = {}\n): Promise<ApiTimingResult> {\n  const {\n    filter,\n    includeStatic = false,\n    timeout = 10000,\n    minDuration = 0,\n  } = options;\n\n  const requests: Map<Request, { startTime: number }> = new Map();\n  const completedRequests: ApiRequestTiming[] = [];\n\n  // Track request start times\n  const requestHandler = (request: Request) => {\n    const url = request.url();\n    const resourceType = request.resourceType();\n\n    // Skip static resources unless requested\n    if (!includeStatic && ['image', 'font', 'stylesheet', 'media'].includes(resourceType)) {\n      return;\n    }\n\n    // Apply filter\n    if (filter && !filter.test(url)) {\n      return;\n    }\n\n    requests.set(request, { startTime: Date.now() });\n  };\n\n  // Track response completion\n  const responseHandler = async (response: Response) => {\n    const request = response.request();\n    const requestData = requests.get(request);\n\n    if (!requestData) return;\n\n    const duration = Date.now() - requestData.startTime;\n\n    // Skip if below minimum duration\n    if (duration < minDuration) {\n      requests.delete(request);\n      return;\n    }\n\n    try {\n      // Get response size\n      const body = await response.body().catch(() => Buffer.alloc(0));\n      const size = body.length;\n\n      // Get timing info if available\n      let timing: ReturnType<typeof request.timing> | Record<string, never> = {};\n      try {\n        timing = response.request().timing();\n      } catch {\n        // Timing not available\n      }\n\n      completedRequests.push({\n        url: request.url(),\n        method: request.method(),\n        duration,\n        status: response.status(),\n        size,\n        resourceType: request.resourceType(),\n        timing: {\n          dnsLookup: timing.domainLookupEnd !== undefined && timing.domainLookupStart !== undefined\n            ? timing.domainLookupEnd - timing.domainLookupStart\n            : undefined,\n          tcpConnect: timing.connectEnd !== undefined && timing.connectStart !== undefined\n            ? timing.connectEnd - timing.connectStart\n            : undefined,\n          requestSent: timing.requestStart !== undefined && timing.connectEnd !== undefined\n            ? timing.requestStart - timing.connectEnd\n            : undefined,\n          waiting: timing.responseStart !== undefined && timing.requestStart !== undefined\n            ? timing.responseStart - timing.requestStart\n            : undefined,\n          contentDownload: timing.responseEnd !== undefined && timing.responseStart !== undefined\n            ? timing.responseEnd - timing.responseStart\n            : undefined,\n        },\n      });\n    } catch {\n      // Ignore errors in timing collection\n    }\n\n    requests.delete(request);\n  };\n\n  // Track failed requests\n  const requestFailedHandler = (request: Request) => {\n    const requestData = requests.get(request);\n    if (!requestData) return;\n\n    const duration = Date.now() - requestData.startTime;\n\n    completedRequests.push({\n      url: request.url(),\n      method: request.method(),\n      duration,\n      status: 0, // 0 indicates failure\n      size: 0,\n      resourceType: request.resourceType(),\n      timing: {},\n    });\n\n    requests.delete(request);\n  };\n\n  // Attach listeners\n  page.on('request', requestHandler);\n  page.on('response', responseHandler);\n  page.on('requestfailed', requestFailedHandler);\n\n  // Wait for pending requests to complete\n  await new Promise<void>((resolve) => {\n    const startWait = Date.now();\n\n    const check = () => {\n      // All tracked requests completed or timeout\n      if (requests.size === 0 || Date.now() - startWait > timeout) {\n        resolve();\n        return;\n      }\n      setTimeout(check, 100);\n    };\n\n    // Wait for initial load, then check periodically\n    setTimeout(check, 1000);\n  });\n\n  // Clean up listeners\n  page.off('request', requestHandler);\n  page.off('response', responseHandler);\n  page.off('requestfailed', requestFailedHandler);\n\n  // Calculate summary\n  const totalRequests = completedRequests.length;\n  const totalTime = completedRequests.reduce((sum, r) => sum + r.duration, 0);\n  const totalSize = completedRequests.reduce((sum, r) => sum + r.size, 0);\n  const failedRequests = completedRequests.filter(r => r.status === 0 || r.status >= 400).length;\n\n  // Find slowest/fastest\n  let slowestRequest: { url: string; duration: number } | null = null;\n  let fastestRequest: { url: string; duration: number } | null = null;\n\n  if (completedRequests.length > 0) {\n    const sorted = [...completedRequests].sort((a, b) => b.duration - a.duration);\n    slowestRequest = { url: sorted[0].url, duration: sorted[0].duration };\n    fastestRequest = { url: sorted[sorted.length - 1].url, duration: sorted[sorted.length - 1].duration };\n  }\n\n  // Count by status\n  const byStatus: Record<number, number> = {};\n  for (const req of completedRequests) {\n    byStatus[req.status] = (byStatus[req.status] || 0) + 1;\n  }\n\n  return {\n    requests: completedRequests.sort((a, b) => b.duration - a.duration),\n    summary: {\n      totalRequests,\n      totalTime,\n      totalSize,\n      averageTime: totalRequests > 0 ? Math.round(totalTime / totalRequests) : 0,\n      slowestRequest,\n      fastestRequest,\n      failedRequests,\n      byStatus,\n    },\n  };\n}\n\n/**\n * Create an API timing tracker that records during page interactions\n */\nexport function createApiTracker(page: Page, options: ApiTimingOptions = {}) {\n  const {\n    filter,\n    includeStatic = false,\n    minDuration = 0,\n  } = options;\n\n  const requests: Map<Request, { startTime: number }> = new Map();\n  const completedRequests: ApiRequestTiming[] = [];\n  let isTracking = false;\n\n  const requestHandler = (request: Request) => {\n    if (!isTracking) return;\n\n    const url = request.url();\n    const resourceType = request.resourceType();\n\n    if (!includeStatic && ['image', 'font', 'stylesheet', 'media'].includes(resourceType)) {\n      return;\n    }\n\n    if (filter && !filter.test(url)) {\n      return;\n    }\n\n    requests.set(request, { startTime: Date.now() });\n  };\n\n  const responseHandler = async (response: Response) => {\n    const request = response.request();\n    const requestData = requests.get(request);\n\n    if (!requestData) return;\n\n    const duration = Date.now() - requestData.startTime;\n\n    if (duration < minDuration) {\n      requests.delete(request);\n      return;\n    }\n\n    try {\n      const body = await response.body().catch(() => Buffer.alloc(0));\n\n      completedRequests.push({\n        url: request.url(),\n        method: request.method(),\n        duration,\n        status: response.status(),\n        size: body.length,\n        resourceType: request.resourceType(),\n        timing: {},\n      });\n    } catch {\n      // Ignore\n    }\n\n    requests.delete(request);\n  };\n\n  const requestFailedHandler = (request: Request) => {\n    const requestData = requests.get(request);\n    if (!requestData) return;\n\n    completedRequests.push({\n      url: request.url(),\n      method: request.method(),\n      duration: Date.now() - requestData.startTime,\n      status: 0,\n      size: 0,\n      resourceType: request.resourceType(),\n      timing: {},\n    });\n\n    requests.delete(request);\n  };\n\n  return {\n    start() {\n      isTracking = true;\n      page.on('request', requestHandler);\n      page.on('response', responseHandler);\n      page.on('requestfailed', requestFailedHandler);\n    },\n\n    stop(): ApiTimingResult {\n      isTracking = false;\n      page.off('request', requestHandler);\n      page.off('response', responseHandler);\n      page.off('requestfailed', requestFailedHandler);\n\n      const totalRequests = completedRequests.length;\n      const totalTime = completedRequests.reduce((sum, r) => sum + r.duration, 0);\n      const totalSize = completedRequests.reduce((sum, r) => sum + r.size, 0);\n      const failedRequests = completedRequests.filter(r => r.status === 0 || r.status >= 400).length;\n\n      let slowestRequest: { url: string; duration: number } | null = null;\n      let fastestRequest: { url: string; duration: number } | null = null;\n\n      if (completedRequests.length > 0) {\n        const sorted = [...completedRequests].sort((a, b) => b.duration - a.duration);\n        slowestRequest = { url: sorted[0].url, duration: sorted[0].duration };\n        fastestRequest = { url: sorted[sorted.length - 1].url, duration: sorted[sorted.length - 1].duration };\n      }\n\n      const byStatus: Record<number, number> = {};\n      for (const req of completedRequests) {\n        byStatus[req.status] = (byStatus[req.status] || 0) + 1;\n      }\n\n      return {\n        requests: completedRequests.sort((a, b) => b.duration - a.duration),\n        summary: {\n          totalRequests,\n          totalTime,\n          totalSize,\n          averageTime: totalRequests > 0 ? Math.round(totalTime / totalRequests) : 0,\n          slowestRequest,\n          fastestRequest,\n          failedRequests,\n          byStatus,\n        },\n      };\n    },\n\n    getRequests(): ApiRequestTiming[] {\n      return [...completedRequests];\n    },\n  };\n}\n\n/**\n * Format API timing result for console output\n */\nexport function formatApiTimingResult(result: ApiTimingResult): string {\n  const lines: string[] = [];\n\n  lines.push('API Timing Analysis');\n  lines.push('===================');\n  lines.push('');\n\n  // Summary\n  lines.push('Summary:');\n  lines.push(`  Total requests: ${result.summary.totalRequests}`);\n  lines.push(`  Total time: ${result.summary.totalTime}ms`);\n  lines.push(`  Total size: ${formatBytes(result.summary.totalSize)}`);\n  lines.push(`  Average time: ${result.summary.averageTime}ms`);\n  lines.push(`  Failed requests: ${result.summary.failedRequests}`);\n  lines.push('');\n\n  // Slowest/fastest\n  if (result.summary.slowestRequest) {\n    lines.push(`Slowest: ${result.summary.slowestRequest.duration}ms`);\n    lines.push(`  ${truncateUrl(result.summary.slowestRequest.url)}`);\n  }\n  if (result.summary.fastestRequest && result.requests.length > 1) {\n    lines.push(`Fastest: ${result.summary.fastestRequest.duration}ms`);\n    lines.push(`  ${truncateUrl(result.summary.fastestRequest.url)}`);\n  }\n  lines.push('');\n\n  // Top 10 slowest requests\n  if (result.requests.length > 0) {\n    lines.push('Slowest requests:');\n    const top10 = result.requests.slice(0, 10);\n    for (const req of top10) {\n      const statusIcon = req.status === 0 ? '\\x1b[31m‚úó\\x1b[0m' :\n                         req.status >= 400 ? '\\x1b[31m!\\x1b[0m' : '\\x1b[32m‚úì\\x1b[0m';\n      lines.push(`  ${statusIcon} ${req.duration}ms ${req.method} ${truncateUrl(req.url)}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format bytes to human readable string\n */\nfunction formatBytes(bytes: number): string {\n  if (bytes < 1024) return `${bytes}B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;\n}\n\n/**\n * Truncate URL for display\n */\nfunction truncateUrl(url: string, maxLength = 60): string {\n  try {\n    const parsed = new URL(url);\n    const path = parsed.pathname + parsed.search;\n    if (path.length > maxLength) {\n      return path.substring(0, maxLength - 3) + '...';\n    }\n    return path;\n  } catch {\n    if (url.length > maxLength) {\n      return url.substring(0, maxLength - 3) + '...';\n    }\n    return url;\n  }\n}\n","/**\n * Memory System - Persistent UI/UX preferences with eviction and summarization\n *\n * Follows the \"Deep Agents\" context management pattern:\n * - summary.json: Always-loaded compact file (< 2KB)\n * - preferences/: Full preference detail files\n * - learned/: Expectations extracted from approved sessions\n * - archive/: Previous summary snapshots (eviction)\n */\n\nimport { readFile, writeFile, mkdir, readdir, unlink, copyFile } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport { nanoid } from 'nanoid';\nimport type {\n  MemorySummary,\n  Preference,\n  PreferenceCategory,\n  LearnedExpectation,\n  ActivePreference,\n  Observation,\n  ExpectationOperator,\n  MemorySource,\n  Violation,\n  EnhancedElement,\n  Session,\n} from './schemas.js';\nimport type { Rule, RuleContext, RulePreset } from './rules/engine.js';\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\nconst MEMORY_DIR = 'memory';\nconst SUMMARY_FILE = 'summary.json';\nconst PREFERENCES_DIR = 'preferences';\nconst LEARNED_DIR = 'learned';\nconst ARCHIVE_DIR = 'archive';\nconst PREF_PREFIX = 'pref_';\nconst LEARN_PREFIX = 'learn_';\nconst MAX_ACTIVE_PREFERENCES = 50;\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n/**\n * Ensure memory directory structure exists\n */\nexport async function initMemory(outputDir: string): Promise<void> {\n  const memoryDir = join(outputDir, MEMORY_DIR);\n  await mkdir(join(memoryDir, PREFERENCES_DIR), { recursive: true });\n  await mkdir(join(memoryDir, LEARNED_DIR), { recursive: true });\n  await mkdir(join(memoryDir, ARCHIVE_DIR), { recursive: true });\n}\n\n// ============================================================================\n// SUMMARY (Always-loaded compact state)\n// ============================================================================\n\nfunction getMemoryPath(outputDir: string, ...segments: string[]): string {\n  return join(outputDir, MEMORY_DIR, ...segments);\n}\n\n/**\n * Load the compact summary - the \"working memory\"\n */\nexport async function loadSummary(outputDir: string): Promise<MemorySummary> {\n  const summaryPath = getMemoryPath(outputDir, SUMMARY_FILE);\n\n  if (!existsSync(summaryPath)) {\n    return createEmptySummary();\n  }\n\n  try {\n    const content = await readFile(summaryPath, 'utf-8');\n    return JSON.parse(content) as MemorySummary;\n  } catch {\n    return createEmptySummary();\n  }\n}\n\n/**\n * Save the compact summary\n */\nexport async function saveSummary(outputDir: string, summary: MemorySummary): Promise<void> {\n  await initMemory(outputDir);\n  const summaryPath = getMemoryPath(outputDir, SUMMARY_FILE);\n  await writeFile(summaryPath, JSON.stringify(summary, null, 2));\n}\n\nfunction createEmptySummary(): MemorySummary {\n  return {\n    version: 1,\n    updatedAt: new Date().toISOString(),\n    stats: {\n      totalPreferences: 0,\n      totalLearned: 0,\n      byCategory: {},\n      bySource: {},\n    },\n    activePreferences: [],\n  };\n}\n\n// ============================================================================\n// PREFERENCE CRUD\n// ============================================================================\n\n/**\n * Add a new UI/UX preference\n */\nexport async function addPreference(\n  outputDir: string,\n  input: {\n    description: string;\n    category: PreferenceCategory;\n    source?: MemorySource;\n    route?: string;\n    componentType?: string;\n    property: string;\n    operator?: ExpectationOperator;\n    value: string;\n    confidence?: number;\n    sessionIds?: string[];\n  }\n): Promise<Preference> {\n  await initMemory(outputDir);\n\n  const now = new Date().toISOString();\n  const pref: Preference = {\n    id: `${PREF_PREFIX}${nanoid(8)}`,\n    description: input.description,\n    category: input.category,\n    source: input.source ?? 'user',\n    route: input.route,\n    componentType: input.componentType,\n    expectation: {\n      property: input.property,\n      operator: input.operator ?? 'equals',\n      value: input.value,\n    },\n    confidence: input.confidence ?? 1.0,\n    createdAt: now,\n    updatedAt: now,\n    sessionIds: input.sessionIds,\n  };\n\n  // Write full preference file\n  const prefPath = getMemoryPath(outputDir, PREFERENCES_DIR, `${pref.id}.json`);\n  await writeFile(prefPath, JSON.stringify(pref, null, 2));\n\n  // Rebuild summary\n  await rebuildSummary(outputDir);\n\n  return pref;\n}\n\n/**\n * Get full preference detail by ID\n */\nexport async function getPreference(outputDir: string, prefId: string): Promise<Preference | null> {\n  const prefPath = getMemoryPath(outputDir, PREFERENCES_DIR, `${prefId}.json`);\n\n  if (!existsSync(prefPath)) return null;\n\n  try {\n    const content = await readFile(prefPath, 'utf-8');\n    return JSON.parse(content) as Preference;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Remove a preference\n */\nexport async function removePreference(outputDir: string, prefId: string): Promise<boolean> {\n  const prefPath = getMemoryPath(outputDir, PREFERENCES_DIR, `${prefId}.json`);\n\n  if (!existsSync(prefPath)) return false;\n\n  await unlink(prefPath);\n  await rebuildSummary(outputDir);\n  return true;\n}\n\n/**\n * List preferences with optional filter\n */\nexport async function listPreferences(\n  outputDir: string,\n  filter?: { category?: PreferenceCategory; route?: string; componentType?: string }\n): Promise<Preference[]> {\n  const prefsDir = getMemoryPath(outputDir, PREFERENCES_DIR);\n\n  if (!existsSync(prefsDir)) return [];\n\n  const files = await readdir(prefsDir);\n  const prefs: Preference[] = [];\n\n  for (const file of files) {\n    if (!file.endsWith('.json')) continue;\n    try {\n      const content = await readFile(join(prefsDir, file), 'utf-8');\n      const pref = JSON.parse(content) as Preference;\n\n      if (filter?.category && pref.category !== filter.category) continue;\n      if (filter?.route && pref.route !== filter.route) continue;\n      if (filter?.componentType && pref.componentType !== filter.componentType) continue;\n\n      prefs.push(pref);\n    } catch {\n      // Skip malformed files\n    }\n  }\n\n  return prefs.sort((a, b) => b.confidence - a.confidence);\n}\n\n// ============================================================================\n// LEARNING FROM SESSIONS\n// ============================================================================\n\n/**\n * Extract and store expectations from an approved session\n */\nexport async function learnFromSession(\n  outputDir: string,\n  session: Session,\n  observations: Observation[]\n): Promise<LearnedExpectation> {\n  await initMemory(outputDir);\n\n  const route = new URL(session.url).pathname;\n  const learned: LearnedExpectation = {\n    id: `${LEARN_PREFIX}${nanoid(8)}`,\n    sessionId: session.id,\n    route,\n    observations,\n    approved: true,\n    createdAt: new Date().toISOString(),\n  };\n\n  const learnPath = getMemoryPath(outputDir, LEARNED_DIR, `${learned.id}.json`);\n  await writeFile(learnPath, JSON.stringify(learned, null, 2));\n\n  return learned;\n}\n\n/**\n * List learned expectations\n */\nexport async function listLearned(outputDir: string): Promise<LearnedExpectation[]> {\n  const learnedDir = getMemoryPath(outputDir, LEARNED_DIR);\n\n  if (!existsSync(learnedDir)) return [];\n\n  const files = await readdir(learnedDir);\n  const items: LearnedExpectation[] = [];\n\n  for (const file of files) {\n    if (!file.endsWith('.json')) continue;\n    try {\n      const content = await readFile(join(learnedDir, file), 'utf-8');\n      items.push(JSON.parse(content) as LearnedExpectation);\n    } catch {\n      // Skip malformed\n    }\n  }\n\n  return items.sort((a, b) => b.createdAt.localeCompare(a.createdAt));\n}\n\n/**\n * Promote a learned expectation to a full preference\n */\nexport async function promoteToPreference(\n  outputDir: string,\n  learnedId: string\n): Promise<Preference | null> {\n  const learnedPath = getMemoryPath(outputDir, LEARNED_DIR, `${learnedId}.json`);\n\n  if (!existsSync(learnedPath)) return null;\n\n  const content = await readFile(learnedPath, 'utf-8');\n  const learned = JSON.parse(content) as LearnedExpectation;\n\n  if (learned.observations.length === 0) return null;\n\n  // Promote first observation as the primary preference\n  const obs = learned.observations[0];\n  const pref = await addPreference(outputDir, {\n    description: obs.description,\n    category: obs.category,\n    source: 'learned',\n    route: learned.route,\n    property: obs.property,\n    value: obs.value,\n    confidence: 0.8,\n    sessionIds: [learned.sessionId],\n  });\n\n  return pref;\n}\n\n// ============================================================================\n// SUMMARIZATION & EVICTION\n// ============================================================================\n\n/**\n * Rebuild summary from all preference files (summarization pattern)\n */\nexport async function rebuildSummary(outputDir: string): Promise<MemorySummary> {\n  // Archive current summary (eviction pattern)\n  await archiveSummary(outputDir);\n\n  const prefs = await listPreferences(outputDir);\n  const learned = await listLearned(outputDir);\n\n  // Compute stats\n  const byCategory: Record<string, number> = {};\n  const bySource: Record<string, number> = {};\n\n  for (const pref of prefs) {\n    byCategory[pref.category] = (byCategory[pref.category] || 0) + 1;\n    bySource[pref.source] = (bySource[pref.source] || 0) + 1;\n  }\n\n  // Build compact active preferences (only top N by confidence)\n  const activePrefs = prefs\n    .slice(0, MAX_ACTIVE_PREFERENCES)\n    .map((pref): ActivePreference => ({\n      id: pref.id,\n      description: pref.description,\n      category: pref.category,\n      route: pref.route,\n      componentType: pref.componentType,\n      property: pref.expectation.property,\n      operator: pref.expectation.operator,\n      value: pref.expectation.value,\n      confidence: pref.confidence,\n    }));\n\n  const summary: MemorySummary = {\n    version: 1,\n    updatedAt: new Date().toISOString(),\n    stats: {\n      totalPreferences: prefs.length,\n      totalLearned: learned.length,\n      byCategory,\n      bySource,\n    },\n    activePreferences: activePrefs,\n  };\n\n  await saveSummary(outputDir, summary);\n  return summary;\n}\n\n/**\n * Archive current summary before rebuilding (eviction pattern)\n */\nexport async function archiveSummary(outputDir: string): Promise<void> {\n  const summaryPath = getMemoryPath(outputDir, SUMMARY_FILE);\n\n  if (!existsSync(summaryPath)) return;\n\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const archivePath = getMemoryPath(outputDir, ARCHIVE_DIR, `summary_${timestamp}.json`);\n\n  try {\n    await copyFile(summaryPath, archivePath);\n  } catch {\n    // Non-critical if archive fails\n  }\n}\n\n// ============================================================================\n// QUERY\n// ============================================================================\n\n/**\n * Query memory for preferences matching criteria\n */\nexport async function queryMemory(\n  outputDir: string,\n  query: { route?: string; category?: string; componentType?: string }\n): Promise<ActivePreference[]> {\n  const summary = await loadSummary(outputDir);\n\n  return summary.activePreferences.filter(pref => {\n    if (query.route && pref.route && !query.route.includes(pref.route)) return false;\n    if (query.category && pref.category !== query.category) return false;\n    if (query.componentType && pref.componentType !== query.componentType) return false;\n    return true;\n  });\n}\n\n// ============================================================================\n// RULES BRIDGE\n// ============================================================================\n\n/**\n * Evaluate an operator against actual and expected values\n */\nfunction evaluateOperator(operator: ExpectationOperator, actual: string, expected: string): boolean {\n  switch (operator) {\n    case 'equals':\n      return actual.toLowerCase() === expected.toLowerCase();\n    case 'contains':\n      return actual.toLowerCase().includes(expected.toLowerCase());\n    case 'matches':\n      try {\n        return new RegExp(expected, 'i').test(actual);\n      } catch {\n        return false;\n      }\n    case 'gte':\n      return parseFloat(actual) >= parseFloat(expected);\n    case 'lte':\n      return parseFloat(actual) <= parseFloat(expected);\n    default:\n      return false;\n  }\n}\n\n/**\n * Convert memory preferences into Rule objects for the rules engine\n */\nexport function preferencesToRules(preferences: ActivePreference[]): Rule[] {\n  return preferences.map((pref): Rule => ({\n    id: `memory-${pref.id}`,\n    name: `Memory: ${pref.description}`,\n    description: `User preference: ${pref.description}`,\n    defaultSeverity: pref.confidence >= 0.8 ? 'error' : 'warn',\n    check: (element: EnhancedElement, context: RuleContext): Violation | null => {\n      // Route scoping\n      if (pref.route && !context.url.includes(pref.route)) return null;\n\n      // Component type scoping\n      if (pref.componentType) {\n        const matchesTag = element.tagName.toLowerCase() === pref.componentType.toLowerCase();\n        const matchesRole = element.a11y?.role?.toLowerCase() === pref.componentType.toLowerCase();\n        if (!matchesTag && !matchesRole) return null;\n      }\n\n      // Property check against computed styles\n      const styles = element.computedStyles;\n      if (!styles) return null;\n\n      const actual = styles[pref.property];\n      if (!actual) return null;\n\n      if (evaluateOperator(pref.operator, actual, pref.value)) return null;\n\n      return {\n        ruleId: `memory-${pref.id}`,\n        ruleName: `Memory: ${pref.description}`,\n        severity: pref.confidence >= 0.8 ? 'error' : 'warn',\n        message: `Expected ${pref.property} to ${pref.operator} \"${pref.value}\", got \"${actual}\". (${pref.description})`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: `Update ${pref.property} to ${pref.value}`,\n      };\n    },\n  }));\n}\n\n/**\n * Create a RulePreset from memory preferences\n */\nexport function createMemoryPreset(preferences: ActivePreference[]): RulePreset {\n  const rules = preferencesToRules(preferences);\n  const defaults: Record<string, 'warn' | 'error'> = {};\n\n  for (const rule of rules) {\n    defaults[rule.id] = rule.defaultSeverity;\n  }\n\n  return {\n    name: 'memory',\n    description: 'UI/UX preferences from IBR memory',\n    rules,\n    defaults,\n  };\n}\n\n// ============================================================================\n// FORMAT\n// ============================================================================\n\n/**\n * Format memory summary for CLI output\n */\nexport function formatMemorySummary(summary: MemorySummary): string {\n  const lines: string[] = [];\n\n  lines.push('IBR Memory');\n  lines.push(`Updated: ${summary.updatedAt}`);\n  lines.push('');\n  lines.push(`Preferences: ${summary.stats.totalPreferences}`);\n  lines.push(`Learned: ${summary.stats.totalLearned}`);\n\n  if (Object.keys(summary.stats.byCategory).length > 0) {\n    lines.push('');\n    lines.push('By category:');\n    for (const [cat, count] of Object.entries(summary.stats.byCategory)) {\n      lines.push(`  ${cat}: ${count}`);\n    }\n  }\n\n  if (summary.activePreferences.length > 0) {\n    lines.push('');\n    lines.push('Active preferences:');\n    for (const pref of summary.activePreferences) {\n      const scope = pref.route ? ` (${pref.route})` : ' (global)';\n      const conf = pref.confidence < 1.0 ? ` [${Math.round(pref.confidence * 100)}%]` : '';\n      lines.push(`  ${pref.id}: ${pref.description}${scope}${conf}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format a single preference for display\n */\nexport function formatPreference(pref: Preference): string {\n  const lines: string[] = [];\n\n  lines.push(`ID: ${pref.id}`);\n  lines.push(`Description: ${pref.description}`);\n  lines.push(`Category: ${pref.category}`);\n  lines.push(`Source: ${pref.source}`);\n  lines.push(`Confidence: ${Math.round(pref.confidence * 100)}%`);\n  lines.push(`Expectation: ${pref.expectation.property} ${pref.expectation.operator} \"${pref.expectation.value}\"`);\n\n  if (pref.route) lines.push(`Route: ${pref.route}`);\n  if (pref.componentType) lines.push(`Component: ${pref.componentType}`);\n  if (pref.sessionIds?.length) lines.push(`Sessions: ${pref.sessionIds.join(', ')}`);\n\n  lines.push(`Created: ${pref.createdAt}`);\n  lines.push(`Updated: ${pref.updatedAt}`);\n\n  return lines.join('\\n');\n}\n","import { registerPreset, type Rule, type RuleContext, type RulePreset } from '../engine.js';\nimport type { EnhancedElement, Violation } from '../../schemas.js';\n\n/**\n * Rule: Buttons must have click handlers\n */\nconst noHandlerRule: Rule = {\n  id: 'no-handler',\n  name: 'No Click Handler',\n  description: 'Interactive elements like buttons must have click handlers',\n  defaultSeverity: 'error',\n  check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n    const isButton = element.tagName === 'button' || element.a11y.role === 'button';\n    const isDisabled = element.interactive.isDisabled;\n    const hasHandler = element.interactive.hasOnClick;\n\n    if (isButton && !isDisabled && !hasHandler) {\n      return {\n        ruleId: 'no-handler',\n        ruleName: 'No Click Handler',\n        severity: 'error',\n        message: `Button \"${element.text || element.selector}\" has no click handler`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: 'Add an onClick handler or make the button disabled',\n      };\n    }\n\n    return null;\n  },\n};\n\n/**\n * Rule: Links must have valid hrefs or handlers\n */\nconst placeholderLinkRule: Rule = {\n  id: 'placeholder-link',\n  name: 'Placeholder Link',\n  description: 'Links must have valid hrefs or click handlers',\n  defaultSeverity: 'error',\n  check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n    const isLink = element.tagName === 'a';\n    const hasValidHref = element.interactive.hasHref;\n    const hasHandler = element.interactive.hasOnClick;\n\n    if (isLink && !hasValidHref && !hasHandler) {\n      return {\n        ruleId: 'placeholder-link',\n        ruleName: 'Placeholder Link',\n        severity: 'error',\n        message: `Link \"${element.text || element.selector}\" has placeholder href and no handler`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: 'Add a valid href or onClick handler',\n      };\n    }\n\n    return null;\n  },\n};\n\n/**\n * Rule: Touch targets must be minimum size\n */\nconst touchTargetRule: Rule = {\n  id: 'touch-target-small',\n  name: 'Touch Target Too Small',\n  description: 'Interactive elements must meet minimum touch target size',\n  defaultSeverity: 'warn',\n  check: (element: EnhancedElement, context: RuleContext, options?: Record<string, unknown>): Violation | null => {\n    const isInteractive = element.interactive.hasOnClick || element.interactive.hasHref;\n    if (!isInteractive) return null;\n\n    const minSize = context.isMobile\n      ? (options?.mobileMinSize as number) ?? 44\n      : (options?.desktopMinSize as number) ?? 24;\n\n    const { width, height } = element.bounds;\n\n    if (width < minSize || height < minSize) {\n      return {\n        ruleId: 'touch-target-small',\n        ruleName: 'Touch Target Too Small',\n        severity: 'warn',\n        message: `\"${element.text || element.selector}\" touch target is ${width}x${height}px (min: ${minSize}px)`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: `Increase element size to at least ${minSize}x${minSize}px`,\n      };\n    }\n\n    return null;\n  },\n};\n\n/**\n * Rule: Interactive elements need accessible labels\n */\nconst missingAriaLabelRule: Rule = {\n  id: 'missing-aria-label',\n  name: 'Missing Accessible Label',\n  description: 'Interactive elements without text need aria-label',\n  defaultSeverity: 'warn',\n  check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n    const isInteractive = element.interactive.hasOnClick || element.interactive.hasHref;\n    if (!isInteractive) return null;\n\n    const hasText = element.text && element.text.trim().length > 0;\n    const hasAriaLabel = element.a11y.ariaLabel && element.a11y.ariaLabel.trim().length > 0;\n\n    if (!hasText && !hasAriaLabel) {\n      return {\n        ruleId: 'missing-aria-label',\n        ruleName: 'Missing Accessible Label',\n        severity: 'warn',\n        message: `\"${element.selector}\" is interactive but has no text or aria-label`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: 'Add visible text or aria-label attribute',\n      };\n    }\n\n    return null;\n  },\n};\n\n/**\n * Rule: Disabled elements should look disabled\n */\nconst disabledNoVisualRule: Rule = {\n  id: 'disabled-no-visual',\n  name: 'Disabled Without Visual',\n  description: 'Disabled elements should have visual indication',\n  defaultSeverity: 'warn',\n  check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n    if (!element.interactive.isDisabled) return null;\n\n    const cursor = element.interactive.cursor;\n    const hasDisabledCursor = cursor === 'not-allowed' || cursor === 'default';\n\n    // Check for visual indication via computed styles\n    const bgColor = element.computedStyles?.backgroundColor as string | undefined;\n    const hasGrayedBg = bgColor?.includes('gray') || bgColor?.includes('rgb(200') || bgColor?.includes('rgb(220');\n\n    if (!hasDisabledCursor && !hasGrayedBg) {\n      return {\n        ruleId: 'disabled-no-visual',\n        ruleName: 'Disabled Without Visual',\n        severity: 'warn',\n        message: `\"${element.text || element.selector}\" is disabled but has no visual indication`,\n        element: element.selector,\n        bounds: element.bounds,\n        fix: 'Add cursor: not-allowed and/or gray background to disabled state',\n      };\n    }\n\n    return null;\n  },\n};\n\n/**\n * Minimal preset - basic interactivity checks\n */\nconst minimalPreset: RulePreset = {\n  name: 'minimal',\n  description: 'Basic interactivity and accessibility checks',\n  rules: [\n    noHandlerRule,\n    placeholderLinkRule,\n    touchTargetRule,\n    missingAriaLabelRule,\n    disabledNoVisualRule,\n  ],\n  defaults: {\n    'no-handler': 'error',\n    'placeholder-link': 'error',\n    'touch-target-small': 'warn',\n    'missing-aria-label': 'warn',\n    'disabled-no-visual': 'warn',\n  },\n};\n\n/**\n * Register the minimal preset\n */\nexport function register(): void {\n  registerPreset(minimalPreset);\n}\n\n// Export rules for testing\nexport const rules = {\n  noHandlerRule,\n  placeholderLinkRule,\n  touchTargetRule,\n  missingAriaLabelRule,\n  disabledNoVisualRule,\n};\n","import { readFile } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport type {\n  EnhancedElement,\n  RulesConfig,\n  RuleSetting,\n  Violation,\n  RuleAuditResult,\n} from '../schemas.js';\n\n/**\n * Rule context passed to each rule check\n */\nexport interface RuleContext {\n  isMobile: boolean;\n  viewportWidth: number;\n  viewportHeight: number;\n  url: string;\n  allElements: EnhancedElement[];\n}\n\n/**\n * Rule definition\n */\nexport interface Rule {\n  id: string;\n  name: string;\n  description: string;\n  defaultSeverity: 'warn' | 'error';\n  check: (element: EnhancedElement, context: RuleContext, options?: Record<string, unknown>) => Violation | null;\n}\n\n/**\n * Rule preset - collection of rules with default settings\n */\nexport interface RulePreset {\n  name: string;\n  description: string;\n  rules: Rule[];\n  defaults: Record<string, RuleSetting>;\n}\n\n// Registered presets\nconst presets: Map<string, RulePreset> = new Map();\n\n/**\n * Register a rule preset\n */\nexport function registerPreset(preset: RulePreset): void {\n  presets.set(preset.name, preset);\n}\n\n/**\n * Get a registered preset by name\n */\nexport function getPreset(name: string): RulePreset | undefined {\n  return presets.get(name);\n}\n\n/**\n * List all registered presets\n */\nexport function listPresets(): string[] {\n  return Array.from(presets.keys());\n}\n\n/**\n * Load rules configuration from .ibr/rules.json\n *\n * By default, NO rules are enforced - rules must be explicitly configured by user.\n * Users can:\n * - Create .ibr/rules.json to define rules\n * - Pass --rules flag to CLI to use optional presets\n * - Define custom rules in the config\n */\nexport async function loadRulesConfig(projectDir: string): Promise<RulesConfig> {\n  const configPath = join(projectDir, '.ibr', 'rules.json');\n\n  if (!existsSync(configPath)) {\n    // Return empty config - no rules by default\n    // Users must explicitly configure rules\n    return { extends: [], rules: {} };\n  }\n\n  try {\n    const content = await readFile(configPath, 'utf-8');\n    return JSON.parse(content) as RulesConfig;\n  } catch (error) {\n    console.warn(`Failed to parse rules.json: ${error}`);\n    // Return empty config on error - don't force any rules\n    return { extends: [], rules: {} };\n  }\n}\n\n/**\n * Merge rule settings from presets and user config\n */\nfunction mergeRuleSettings(\n  presetNames: string[],\n  userRules: Record<string, RuleSetting> = {}\n): { rules: Rule[]; settings: Map<string, { severity: 'warn' | 'error' | 'off'; options?: Record<string, unknown> }> } {\n  const allRules: Rule[] = [];\n  const settings = new Map<string, { severity: 'warn' | 'error' | 'off'; options?: Record<string, unknown> }>();\n  const seenRuleIds = new Set<string>();\n\n  // Load rules from presets\n  for (const presetName of presetNames) {\n    const preset = presets.get(presetName);\n    if (!preset) {\n      console.warn(`Unknown preset: ${presetName}`);\n      continue;\n    }\n\n    for (const rule of preset.rules) {\n      if (!seenRuleIds.has(rule.id)) {\n        allRules.push(rule);\n        seenRuleIds.add(rule.id);\n\n        // Apply preset defaults\n        const defaultSetting = preset.defaults[rule.id] ?? rule.defaultSeverity;\n        if (typeof defaultSetting === 'string') {\n          settings.set(rule.id, { severity: defaultSetting as 'warn' | 'error' | 'off' });\n        } else {\n          settings.set(rule.id, { severity: defaultSetting[0] as 'warn' | 'error' | 'off', options: defaultSetting[1] as Record<string, unknown> });\n        }\n      }\n    }\n  }\n\n  // Apply user overrides\n  for (const [ruleId, setting] of Object.entries(userRules)) {\n    if (typeof setting === 'string') {\n      settings.set(ruleId, { severity: setting as 'warn' | 'error' | 'off' });\n    } else {\n      settings.set(ruleId, { severity: setting[0] as 'warn' | 'error' | 'off', options: setting[1] as Record<string, unknown> });\n    }\n  }\n\n  return { rules: allRules, settings };\n}\n\n/**\n * Run rules against elements\n */\nexport function runRules(\n  elements: EnhancedElement[],\n  context: RuleContext,\n  config: RulesConfig\n): Violation[] {\n  // No rules by default - user must configure in .ibr/rules.json or pass --rules flag\n  const { rules, settings } = mergeRuleSettings(config.extends ?? [], config.rules as Record<string, RuleSetting> | undefined);\n  const violations: Violation[] = [];\n\n  for (const element of elements) {\n    for (const rule of rules) {\n      const setting = settings.get(rule.id);\n\n      // Skip if rule is off\n      if (!setting || setting.severity === 'off') {\n        continue;\n      }\n\n      const violation = rule.check(element, context, setting.options);\n\n      if (violation) {\n        // Override severity from settings\n        violations.push({\n          ...violation,\n          severity: setting.severity as 'warn' | 'error',\n        });\n      }\n    }\n  }\n\n  return violations;\n}\n\n/**\n * Create full audit result\n */\nexport function createAuditResult(\n  url: string,\n  elements: EnhancedElement[],\n  violations: Violation[]\n): RuleAuditResult {\n  const errors = violations.filter(v => v.severity === 'error').length;\n  const warnings = violations.filter(v => v.severity === 'warn').length;\n\n  return {\n    url,\n    timestamp: new Date().toISOString(),\n    elementsScanned: elements.length,\n    violations,\n    summary: {\n      errors,\n      warnings,\n      passed: elements.length - errors - warnings,\n    },\n  };\n}\n\n/**\n * Format audit result for CLI output\n */\nexport function formatAuditResult(result: RuleAuditResult): string {\n  const lines: string[] = [];\n\n  lines.push(`IBR Audit: ${result.url}`);\n  lines.push(`Scanned: ${result.elementsScanned} elements`);\n  lines.push('');\n\n  if (result.violations.length === 0) {\n    lines.push('No violations found.');\n  } else {\n    lines.push(`Found ${result.summary.errors} errors, ${result.summary.warnings} warnings:`);\n    lines.push('');\n\n    for (const v of result.violations) {\n      const icon = v.severity === 'error' ? '‚úó' : '!';\n      lines.push(`  ${icon} [${v.ruleId}] ${v.message}`);\n      if (v.element) {\n        lines.push(`    Element: ${v.element.slice(0, 60)}${v.element.length > 60 ? '...' : ''}`);\n      }\n      if (v.fix) {\n        lines.push(`    Fix: ${v.fix}`);\n      }\n    }\n  }\n\n  lines.push('');\n  lines.push(`Summary: ${result.summary.errors} errors, ${result.summary.warnings} warnings, ${result.summary.passed} passed`);\n\n  return lines.join('\\n');\n}\n\n/**\n * Load and register memory preferences as a rule preset\n */\nexport async function loadMemoryPreset(outputDir: string): Promise<void> {\n  try {\n    const { loadSummary, createMemoryPreset } = await import('../memory.js');\n    const summary = await loadSummary(outputDir);\n\n    if (summary.activePreferences.length > 0) {\n      const preset = createMemoryPreset(summary.activePreferences);\n      registerPreset(preset);\n    }\n  } catch {\n    // Memory not available - not an error\n  }\n}\n\n// Auto-register presets on import\nimport('./presets/minimal.js').then(m => m.register()).catch(() => {});\n","import { chromium, type Browser, type Page } from 'playwright';\nimport { writeFile, readFile, unlink, mkdir } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport type { Viewport, EnhancedElement, ElementIssue, AuditResult } from './schemas.js';\nimport { VIEWPORTS } from './schemas.js';\n\n/**\n * Lock file to prevent concurrent extractions\n */\nconst LOCK_FILE = '.extracting';\nconst LOCK_TIMEOUT_MS = 180000; // 3 minutes (longer than extraction to prevent stale locks)\nconst EXTRACTION_TIMEOUT_MS = 120000; // 2 minutes - allows complex pages to load\n\n/**\n * Extracted element information\n */\nexport interface ExtractedElement {\n  selector: string;\n  tagName: string;\n  id?: string;\n  className?: string;\n  bounds: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  computedStyles: Record<string, string>;\n}\n\n/**\n * CSS custom properties (variables)\n */\nexport interface CSSVariables {\n  [key: string]: string;\n}\n\n/**\n * Full extraction result\n */\nexport interface ExtractionResult {\n  url: string;\n  timestamp: string;\n  viewport: Viewport;\n  html: string;\n  elements: ExtractedElement[];\n  cssVariables: CSSVariables;\n  screenshotPath: string;\n}\n\n/**\n * Options for HTML extraction\n */\nexport interface ExtractOptions {\n  url: string;\n  outputDir: string;\n  sessionId: string;\n  viewport?: Viewport;\n  timeout?: number;\n  /** CSS selectors to extract (defaults to semantic elements) */\n  selectors?: string[];\n}\n\n/**\n * Default semantic selectors to extract\n */\nconst DEFAULT_SELECTORS = [\n  'header',\n  'nav',\n  'main',\n  'section',\n  'article',\n  'aside',\n  'footer',\n  'h1',\n  'h2',\n  'h3',\n  'button',\n  'a[href]',\n  'form',\n  'input',\n  'img',\n];\n\n/**\n * Key CSS properties to extract\n */\nconst CSS_PROPERTIES_TO_EXTRACT = [\n  'display',\n  'position',\n  'width',\n  'height',\n  'padding',\n  'margin',\n  'backgroundColor',\n  'color',\n  'fontSize',\n  'fontFamily',\n  'fontWeight',\n  'lineHeight',\n  'textAlign',\n  'borderRadius',\n  'border',\n  'boxShadow',\n  'gap',\n  'flexDirection',\n  'alignItems',\n  'justifyContent',\n  'gridTemplateColumns',\n  'gridTemplateRows',\n];\n\n// Singleton browser instance\nlet browser: Browser | null = null;\n\n/**\n * Get or create browser instance\n */\nasync function getBrowser(): Promise<Browser> {\n  if (!browser) {\n    browser = await chromium.launch({\n      headless: true,\n    });\n  }\n  return browser;\n}\n\n/**\n * Close the browser instance\n */\nexport async function closeBrowser(): Promise<void> {\n  if (browser) {\n    await browser.close();\n    browser = null;\n  }\n}\n\n/**\n * Check if extraction is already in progress\n */\nasync function checkLock(outputDir: string): Promise<boolean> {\n  const lockPath = join(outputDir, LOCK_FILE);\n  if (!existsSync(lockPath)) {\n    return false;\n  }\n\n  try {\n    const content = await readFile(lockPath, 'utf-8');\n    const timestamp = parseInt(content, 10);\n    const age = Date.now() - timestamp;\n\n    // Lock is stale if older than timeout\n    if (age > LOCK_TIMEOUT_MS) {\n      await unlink(lockPath);\n      return false;\n    }\n\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Create extraction lock\n */\nasync function createLock(outputDir: string): Promise<void> {\n  const lockPath = join(outputDir, LOCK_FILE);\n  await writeFile(lockPath, Date.now().toString());\n}\n\n/**\n * Release extraction lock\n */\nasync function releaseLock(outputDir: string): Promise<void> {\n  const lockPath = join(outputDir, LOCK_FILE);\n  try {\n    await unlink(lockPath);\n  } catch {\n    // Ignore errors\n  }\n}\n\n/**\n * Extract computed styles for an element\n */\nasync function extractElementStyles(\n  page: Page,\n  selector: string\n): Promise<ExtractedElement[]> {\n  return page.evaluate(\n    ({ sel, props }) => {\n      const elements = document.querySelectorAll(sel);\n      const results: ExtractedElement[] = [];\n\n      elements.forEach((el, index) => {\n        const htmlEl = el as HTMLElement;\n        const rect = htmlEl.getBoundingClientRect();\n        const computed = window.getComputedStyle(htmlEl);\n\n        const styles: Record<string, string> = {};\n        props.forEach((prop) => {\n          const value = computed.getPropertyValue(\n            prop.replace(/([A-Z])/g, '-$1').toLowerCase()\n          );\n          if (value && value !== 'none' && value !== 'normal' && value !== '0px') {\n            styles[prop] = value;\n          }\n        });\n\n        results.push({\n          selector: `${sel}:nth-of-type(${index + 1})`,\n          tagName: htmlEl.tagName.toLowerCase(),\n          id: htmlEl.id || undefined,\n          className: htmlEl.className || undefined,\n          bounds: {\n            x: Math.round(rect.x),\n            y: Math.round(rect.y),\n            width: Math.round(rect.width),\n            height: Math.round(rect.height),\n          },\n          computedStyles: styles,\n        });\n      });\n\n      return results;\n    },\n    { sel: selector, props: CSS_PROPERTIES_TO_EXTRACT }\n  );\n}\n\n/**\n * Interactive element selectors for audit\n */\nconst INTERACTIVE_SELECTORS = [\n  'button',\n  'a[href]',\n  'a:not([href])',  // Links without href (potential issues)\n  'input[type=\"submit\"]',\n  'input[type=\"button\"]',\n  'input[type=\"text\"]',\n  'input[type=\"email\"]',\n  'input[type=\"password\"]',\n  'select',\n  'textarea',\n  '[role=\"button\"]',\n  '[role=\"link\"]',\n  '[onclick]',\n  '[tabindex]:not([tabindex=\"-1\"])',\n];\n\n/**\n * Extract enhanced interactive elements with handler detection\n */\nexport async function extractInteractiveElements(page: Page): Promise<EnhancedElement[]> {\n  return page.evaluate((selectors) => {\n    const seen = new Set<Element>();\n    const elements: EnhancedElement[] = [];\n\n    // Helper: Generate unique selector (arrow function to avoid __name bundling issue)\n    const generateSelector = (el: HTMLElement): string => {\n      if (el.id) return `#${el.id}`;\n\n      const path: string[] = [];\n      let current: HTMLElement | null = el;\n\n      while (current && current !== document.body) {\n        let selector = current.tagName.toLowerCase();\n        if (current.id) {\n          selector = `#${current.id}`;\n          path.unshift(selector);\n          break;\n        } else if (current.className && typeof current.className === 'string') {\n          const classes = current.className.split(' ').filter(c => c.trim() && !c.includes(':'));\n          if (classes.length > 0) {\n            selector += `.${classes[0]}`;\n          }\n        }\n\n        const parent = current.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children).filter(\n            c => c.tagName === current!.tagName\n          );\n          if (siblings.length > 1) {\n            const index = siblings.indexOf(current) + 1;\n            selector += `:nth-of-type(${index})`;\n          }\n        }\n\n        path.unshift(selector);\n        current = current.parentElement;\n      }\n\n      return path.join(' > ').slice(0, 200);\n    };\n\n    // Helper: Detect click handlers (arrow function to avoid __name bundling issue)\n    const detectHandlers = (el: HTMLElement) => {\n      const keys = Object.keys(el);\n\n      // React 17+ uses __reactProps$\n      const reactPropsKey = keys.find(k => k.startsWith('__reactProps$'));\n      let hasReactHandler = false;\n      if (reactPropsKey) {\n        const props = (el as any)[reactPropsKey];\n        hasReactHandler = !!(props?.onClick || props?.onSubmit || props?.onMouseDown);\n      }\n\n      // Also check React fiber\n      const fiberKey = keys.find(k => k.startsWith('__reactFiber$'));\n      if (!hasReactHandler && fiberKey) {\n        const fiber = (el as any)[fiberKey];\n        hasReactHandler = !!(fiber?.pendingProps?.onClick || fiber?.memoizedProps?.onClick);\n      }\n\n      // Vue uses __vue__ or __vnode\n      const hasVueHandler = !!(\n        (el as any).__vue__?.$listeners?.click ||\n        (el as any).__vnode?.props?.onClick\n      );\n\n      // Angular uses __ngContext__\n      const hasAngularHandler = !!(el as any).__ngContext__ || el.hasAttribute('ng-click');\n\n      // Vanilla DOM\n      const hasVanillaHandler = typeof (el as any).onclick === 'function' ||\n                                 el.hasAttribute('onclick');\n\n      return {\n        hasReactHandler,\n        hasVueHandler,\n        hasAngularHandler,\n        hasVanillaHandler,\n        hasAnyHandler: hasReactHandler || hasVueHandler || hasAngularHandler || hasVanillaHandler,\n      };\n    };\n\n    // Process each selector\n    for (const selector of selectors) {\n      try {\n        document.querySelectorAll(selector).forEach((el) => {\n          if (seen.has(el)) return;\n          seen.add(el);\n\n          const htmlEl = el as HTMLElement;\n          const rect = htmlEl.getBoundingClientRect();\n          const computed = window.getComputedStyle(htmlEl);\n          const handlers = detectHandlers(htmlEl);\n\n          // Check href for links\n          const href = htmlEl.getAttribute('href');\n          const hasValidHref = href !== null && href !== '#' && href !== '' &&\n                               !href.startsWith('javascript:');\n\n          elements.push({\n            selector: generateSelector(htmlEl),\n            tagName: htmlEl.tagName.toLowerCase(),\n            id: htmlEl.id || undefined,\n            className: typeof htmlEl.className === 'string' ? htmlEl.className : undefined,\n            text: (htmlEl.textContent || '').trim().slice(0, 100) || undefined,\n            bounds: {\n              x: Math.round(rect.x),\n              y: Math.round(rect.y),\n              width: Math.round(rect.width),\n              height: Math.round(rect.height),\n            },\n            computedStyles: {\n              cursor: computed.cursor,\n              color: computed.color,\n              backgroundColor: computed.backgroundColor,\n            },\n            interactive: {\n              hasOnClick: handlers.hasAnyHandler,\n              hasHref: hasValidHref,\n              isDisabled: htmlEl.hasAttribute('disabled') ||\n                          htmlEl.getAttribute('aria-disabled') === 'true' ||\n                          computed.pointerEvents === 'none',\n              tabIndex: parseInt(htmlEl.getAttribute('tabindex') || '0', 10),\n              cursor: computed.cursor,\n              hasReactHandler: handlers.hasReactHandler || undefined,\n              hasVueHandler: handlers.hasVueHandler || undefined,\n              hasAngularHandler: handlers.hasAngularHandler || undefined,\n            },\n            a11y: {\n              role: htmlEl.getAttribute('role'),\n              ariaLabel: htmlEl.getAttribute('aria-label'),\n              ariaDescribedBy: htmlEl.getAttribute('aria-describedby'),\n              ariaHidden: htmlEl.getAttribute('aria-hidden') === 'true' || undefined,\n            },\n            sourceHint: {\n              dataTestId: htmlEl.getAttribute('data-testid'),\n            },\n          });\n        });\n      } catch {\n        // Skip invalid selectors\n      }\n    }\n\n    return elements;\n  }, INTERACTIVE_SELECTORS);\n}\n\n/**\n * Analyze elements and detect issues\n */\nexport function analyzeElements(elements: EnhancedElement[], isMobile = false): AuditResult {\n  const issues: ElementIssue[] = [];\n  let withHandlers = 0;\n  let withoutHandlers = 0;\n\n  const interactiveElements = elements.filter(el => {\n    const isButton = el.tagName === 'button' || el.a11y.role === 'button';\n    const isLink = el.tagName === 'a';\n    const isInput = ['input', 'select', 'textarea'].includes(el.tagName);\n    const looksClickable = el.interactive.cursor === 'pointer';\n    return isButton || isLink || isInput || looksClickable;\n  });\n\n  for (const el of interactiveElements) {\n    const isButton = el.tagName === 'button' || el.a11y.role === 'button';\n    const isLink = el.tagName === 'a';\n    const hasHandler = el.interactive.hasOnClick || el.interactive.hasHref;\n\n    if (hasHandler) {\n      withHandlers++;\n    } else {\n      withoutHandlers++;\n    }\n\n    // Check: Button without handler\n    if (isButton && !el.interactive.hasOnClick && !el.interactive.isDisabled) {\n      issues.push({\n        type: 'NO_HANDLER',\n        severity: 'error',\n        message: `Button \"${el.text || el.selector}\" has no click handler`,\n      });\n    }\n\n    // Check: Link with placeholder href\n    if (isLink && !el.interactive.hasHref && !el.interactive.hasOnClick) {\n      issues.push({\n        type: 'PLACEHOLDER_LINK',\n        severity: 'error',\n        message: `Link \"${el.text || el.selector}\" has placeholder href and no handler`,\n      });\n    }\n\n    // Check: Touch target too small (mobile)\n    const minSize = isMobile ? 44 : 24;\n    if (el.bounds.width < minSize || el.bounds.height < minSize) {\n      issues.push({\n        type: 'TOUCH_TARGET_SMALL',\n        severity: isMobile ? 'error' : 'warning',\n        message: `\"${el.text || el.selector}\" touch target is ${el.bounds.width}x${el.bounds.height}px (min: ${minSize}px)`,\n      });\n    }\n\n    // Check: Missing aria-label on interactive element without text\n    if (hasHandler && !el.text && !el.a11y.ariaLabel) {\n      issues.push({\n        type: 'MISSING_ARIA_LABEL',\n        severity: 'warning',\n        message: `\"${el.selector}\" is interactive but has no text or aria-label`,\n      });\n    }\n  }\n\n  return {\n    totalElements: elements.length,\n    interactiveCount: interactiveElements.length,\n    withHandlers,\n    withoutHandlers,\n    issues,\n  };\n}\n\n/**\n * Extract CSS custom properties (variables)\n */\nasync function extractCSSVariables(page: Page): Promise<CSSVariables> {\n  return page.evaluate(() => {\n    const root = document.documentElement;\n    const variables: CSSVariables = {};\n\n    // Get all CSS rules from stylesheets\n    const sheets = Array.from(document.styleSheets);\n    sheets.forEach((sheet) => {\n      try {\n        const rules = Array.from(sheet.cssRules || []);\n        rules.forEach((rule) => {\n          if (rule instanceof CSSStyleRule && rule.selectorText === ':root') {\n            const style = rule.style;\n            for (let i = 0; i < style.length; i++) {\n              const prop = style[i];\n              if (prop.startsWith('--')) {\n                variables[prop] = style.getPropertyValue(prop).trim();\n              }\n            }\n          }\n        });\n      } catch {\n        // Cross-origin stylesheets will throw\n      }\n    });\n\n    // Also get computed custom properties from :root\n    const rootStyles = getComputedStyle(root);\n    // Check common variable prefixes\n    ['--primary', '--secondary', '--accent', '--background', '--foreground', '--border', '--radius', '--spacing']\n      .forEach(prefix => {\n        for (let i = 0; i < 20; i++) {\n          const variations = [\n            prefix,\n            `${prefix}-${i}`,\n            `${prefix}-color`,\n            `${prefix}-bg`,\n          ];\n          variations.forEach(varName => {\n            const value = rootStyles.getPropertyValue(varName).trim();\n            if (value && !variables[varName]) {\n              variables[varName] = value;\n            }\n          });\n        }\n      });\n\n    return variables;\n  });\n}\n\n/**\n * Extract HTML, CSS, and screenshot from a live URL\n */\nexport async function extractFromURL(\n  options: ExtractOptions\n): Promise<ExtractionResult> {\n  const {\n    url,\n    outputDir,\n    sessionId,\n    viewport = VIEWPORTS.desktop,\n    timeout = EXTRACTION_TIMEOUT_MS,\n    selectors = DEFAULT_SELECTORS,\n  } = options;\n\n  // Check for concurrent extraction\n  if (await checkLock(outputDir)) {\n    throw new Error('Another extraction is in progress. Please wait.');\n  }\n\n  // Create session directory\n  const sessionDir = join(outputDir, 'sessions', sessionId);\n  await mkdir(sessionDir, { recursive: true });\n\n  // Create lock\n  await createLock(outputDir);\n\n  const browserInstance = await getBrowser();\n  let timeoutHandle: NodeJS.Timeout | null = null;\n\n  try {\n    // Set up hard timeout\n    const timeoutPromise = new Promise<never>((_, reject) => {\n      timeoutHandle = setTimeout(() => {\n        reject(new Error(`Extraction timed out after ${timeout}ms`));\n      }, timeout);\n    });\n\n    const extractionPromise = async () => {\n      const context = await browserInstance.newContext({\n        viewport: {\n          width: viewport.width,\n          height: viewport.height,\n        },\n        reducedMotion: 'reduce',\n      });\n\n      const page = await context.newPage();\n\n      try {\n        // Navigate to URL\n        await page.goto(url, {\n          waitUntil: 'networkidle',\n          timeout: timeout,\n        });\n\n        // Wait for animations to settle\n        await page.waitForTimeout(500);\n\n        // Disable animations for screenshot\n        await page.addStyleTag({\n          content: `\n            *, *::before, *::after {\n              animation-duration: 0s !important;\n              animation-delay: 0s !important;\n              transition-duration: 0s !important;\n              transition-delay: 0s !important;\n            }\n          `,\n        });\n\n        // Extract HTML\n        const html = await page.content();\n\n        // Extract elements\n        const elements: ExtractedElement[] = [];\n        for (const selector of selectors) {\n          const extracted = await extractElementStyles(page, selector);\n          elements.push(...extracted);\n        }\n\n        // Extract CSS variables\n        const cssVariables = await extractCSSVariables(page);\n\n        // Take screenshot\n        const screenshotPath = join(sessionDir, 'reference.png');\n        await page.screenshot({\n          path: screenshotPath,\n          fullPage: true,\n          type: 'png',\n        });\n\n        const result: ExtractionResult = {\n          url,\n          timestamp: new Date().toISOString(),\n          viewport,\n          html,\n          elements,\n          cssVariables,\n          screenshotPath,\n        };\n\n        // Save extraction data\n        await writeFile(\n          join(sessionDir, 'reference.json'),\n          JSON.stringify(result, null, 2)\n        );\n\n        // Save HTML separately for easier access\n        await writeFile(join(sessionDir, 'reference.html'), html);\n\n        return result;\n      } finally {\n        await context.close();\n      }\n    };\n\n    // Race between extraction and timeout\n    const result = await Promise.race([extractionPromise(), timeoutPromise]);\n    return result;\n  } finally {\n    // Clear timeout\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle);\n    }\n\n    // Release lock\n    await releaseLock(outputDir);\n  }\n}\n\n/**\n * Get paths for a reference session\n */\nexport function getReferenceSessionPaths(outputDir: string, sessionId: string) {\n  const root = join(outputDir, 'sessions', sessionId);\n  return {\n    root,\n    sessionJson: join(root, 'session.json'),\n    reference: join(root, 'reference.png'),\n    referenceHtml: join(root, 'reference.html'),\n    referenceData: join(root, 'reference.json'),\n    current: join(root, 'current.png'),\n    diff: join(root, 'diff.png'),\n  };\n}\n","/**\n * Framework Parser - Extracts design frameworks from CLAUDE.md content\n *\n * Parses markdown to find design frameworks like:\n * - Calm Precision\n * - Material Design\n * - Human Interface Guidelines\n * - Custom frameworks defined by users\n *\n * Detection is based on:\n * 1. Framework name in headers (e.g., \"# CALM PRECISION 6.1\")\n * 2. Principles sections (e.g., \"## CORE PRINCIPLES\")\n * 3. Numbered design rules (e.g., \"### 1. Group, Don't Isolate\")\n */\n\nexport interface DesignFramework {\n  name: string;\n  version?: string;\n  principles: DesignPrinciple[];\n  source: string; // File path it was loaded from\n  rawContent: string;\n}\n\nexport interface DesignPrinciple {\n  id: string;\n  name: string;\n  description: string;\n  foundation?: string[]; // e.g., [\"Gestalt Proximity\", \"Common Region\"]\n  implementation: string[]; // Implementation rules/guidelines\n  category?: string;\n}\n\n// Common framework name patterns\nconst FRAMEWORK_PATTERNS = [\n  /^#\\s*(.+?)\\s*(\\d+\\.?\\d*)?$/m, // \"# CALM PRECISION 6.1\"\n  /^\\*\\*(.+?)\\*\\*\\s*v?(\\d+\\.?\\d*)?/m, // \"**Framework Name** v1.0\"\n  /^##?\\s*(?:Design\\s+)?Framework:\\s*(.+?)(?:\\s+v?(\\d+\\.?\\d*))?$/im,\n];\n\n// Section patterns that indicate principles\nconst PRINCIPLES_SECTION_PATTERNS = [\n  /^##\\s*(?:CORE\\s+)?PRINCIPLES?/im,\n  /^##\\s*DESIGN\\s+PRINCIPLES?/im,\n  /^##\\s*GUIDELINES?/im,\n  /^##\\s*RULES?/im,\n];\n\n// Numbered principle pattern\nconst NUMBERED_PRINCIPLE = /^###\\s*(\\d+)\\.\\s*(.+)$/m;\n\n/**\n * Parse a design framework from markdown content\n */\nexport function parseDesignFramework(\n  content: string,\n  sourcePath: string\n): DesignFramework | null {\n  // Try to detect framework name\n  const frameworkInfo = detectFrameworkName(content);\n  if (!frameworkInfo) {\n    // Check if there are principles even without explicit framework name\n    const principles = extractPrinciples(content);\n    if (principles.length >= 3) {\n      // At least 3 principles suggests a design framework\n      return {\n        name: 'Custom Design Framework',\n        principles,\n        source: sourcePath,\n        rawContent: content,\n      };\n    }\n    return null;\n  }\n\n  // Extract principles\n  const principles = extractPrinciples(content);\n\n  if (principles.length === 0) {\n    // Framework name found but no principles extracted\n    return null;\n  }\n\n  return {\n    name: frameworkInfo.name,\n    version: frameworkInfo.version,\n    principles,\n    source: sourcePath,\n    rawContent: content,\n  };\n}\n\n/**\n * Detect framework name from content\n */\nfunction detectFrameworkName(\n  content: string\n): { name: string; version?: string } | null {\n  // Check for common framework patterns\n  for (const pattern of FRAMEWORK_PATTERNS) {\n    const match = content.match(pattern);\n    if (match) {\n      const name = match[1].trim();\n      const version = match[2]?.trim();\n\n      // Filter out generic headers\n      if (\n        !name.toLowerCase().includes('instructions') &&\n        !name.toLowerCase().includes('readme') &&\n        !name.toLowerCase().includes('overview')\n      ) {\n        return { name, version };\n      }\n    }\n  }\n\n  // Look for known framework names in content\n  const knownFrameworks = [\n    'calm precision',\n    'material design',\n    'human interface guidelines',\n    'fluent design',\n    'ant design',\n    'carbon design',\n    'atlassian design',\n  ];\n\n  const contentLower = content.toLowerCase();\n  for (const framework of knownFrameworks) {\n    if (contentLower.includes(framework)) {\n      // Find the exact casing in the original content\n      const regex = new RegExp(framework, 'i');\n      const match = content.match(regex);\n      if (match) {\n        return { name: match[0] };\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract design principles from content\n */\nfunction extractPrinciples(content: string): DesignPrinciple[] {\n  const principles: DesignPrinciple[] = [];\n\n  // Find principles section\n  let principlesSection = content;\n  for (const pattern of PRINCIPLES_SECTION_PATTERNS) {\n    const match = content.match(pattern);\n    if (match) {\n      const startIndex = match.index || 0;\n      // Extract content from this section until the next major section\n      const afterMatch = content.slice(startIndex);\n      const nextMajorSection = afterMatch.match(/^##\\s+[A-Z]/m);\n      if (nextMajorSection && nextMajorSection.index) {\n        principlesSection = afterMatch.slice(0, nextMajorSection.index);\n      } else {\n        principlesSection = afterMatch;\n      }\n      break;\n    }\n  }\n\n  // Extract numbered principles (### 1. Name format)\n  const numberedMatches = principlesSection.matchAll(\n    /###\\s*(\\d+)\\.\\s*(.+?)(?:\\n|\\r\\n)([\\s\\S]*?)(?=###\\s*\\d+\\.|##\\s|$)/g\n  );\n\n  for (const match of numberedMatches) {\n    const number = match[1];\n    const name = match[2].trim();\n    const body = match[3].trim();\n\n    const principle = parsePrincipleBody(number, name, body);\n    if (principle) {\n      principles.push(principle);\n    }\n  }\n\n  // If no numbered principles found, try bullet point format\n  if (principles.length === 0) {\n    const bulletMatches = principlesSection.matchAll(\n      /[-*]\\s*\\*\\*(.+?)\\*\\*[:\\s]*(.+?)(?=\\n[-*]|\\n\\n|$)/gs\n    );\n\n    let index = 1;\n    for (const match of bulletMatches) {\n      const name = match[1].trim();\n      const description = match[2].trim();\n\n      principles.push({\n        id: `principle-${index}`,\n        name,\n        description,\n        implementation: extractImplementationRules(description),\n      });\n      index++;\n    }\n  }\n\n  return principles;\n}\n\n/**\n * Parse the body of a principle to extract details\n */\nfunction parsePrincipleBody(\n  number: string,\n  name: string,\n  body: string\n): DesignPrinciple | null {\n  // Generate ID from name\n  const id = name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '');\n\n  // Extract foundation (scientific basis)\n  const foundationMatch = body.match(\n    /\\*\\*(?:Foundation|Based on|Principle):\\*\\*\\s*(.+?)(?:\\n|$)/i\n  );\n  const foundation = foundationMatch\n    ? foundationMatch[1]\n        .split(/[,+]/)\n        .map((f) => f.trim())\n        .filter(Boolean)\n    : undefined;\n\n  // Extract description (first paragraph or sentence)\n  const lines = body.split('\\n').filter((l) => l.trim());\n  let description = '';\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n    // Skip foundation line\n    if (trimmed.toLowerCase().includes('foundation:')) continue;\n    // Skip bullet points for description\n    if (trimmed.startsWith('-') || trimmed.startsWith('*')) continue;\n\n    description = trimmed;\n    break;\n  }\n\n  // Extract implementation rules (bullet points)\n  const implementation = extractImplementationRules(body);\n\n  return {\n    id: `${number}-${id}`,\n    name,\n    description: description || name,\n    foundation,\n    implementation,\n  };\n}\n\n/**\n * Extract implementation rules from principle body\n */\nfunction extractImplementationRules(body: string): string[] {\n  const rules: string[] = [];\n\n  // Match bullet points\n  const bulletMatches = body.matchAll(/^[-*]\\s+(.+?)$/gm);\n  for (const match of bulletMatches) {\n    const rule = match[1].trim();\n    if (rule && rule.length > 5) {\n      // Skip very short rules\n      rules.push(rule);\n    }\n  }\n\n  // If no bullet points, extract sentences that sound like rules\n  if (rules.length === 0) {\n    const sentences = body.split(/[.!]\\s+/);\n    for (const sentence of sentences) {\n      const trimmed = sentence.trim();\n      // Look for imperative or declarative rules\n      if (\n        trimmed.length > 10 &&\n        (trimmed.match(/^(use|don't|never|always|avoid|prefer|ensure)/i) ||\n          trimmed.match(/should|must|need to|better to/i))\n      ) {\n        rules.push(trimmed);\n      }\n    }\n  }\n\n  return rules;\n}\n\n/**\n * Format framework for display\n */\nexport function formatFramework(framework: DesignFramework): string {\n  const lines: string[] = [];\n\n  lines.push(`Framework: ${framework.name}${framework.version ? ` v${framework.version}` : ''}`);\n  lines.push(`Source: ${framework.source}`);\n  lines.push(`Principles: ${framework.principles.length}`);\n  lines.push('');\n\n  for (const principle of framework.principles) {\n    lines.push(`  ${principle.id}: ${principle.name}`);\n    if (principle.foundation) {\n      lines.push(`    Foundation: ${principle.foundation.join(', ')}`);\n    }\n    lines.push(`    Rules: ${principle.implementation.length}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Context Loader - Discovers user design preferences from CLAUDE.md files\n *\n * IBR is context-aware, not standards-enforcing. It detects the user's\n * design framework from their CLAUDE.md and validates against THAT.\n *\n * Discovery priority (highest to lowest):\n * 1. Project .claude/CLAUDE.md\n * 2. Project root CLAUDE.md\n * 3. User ~/.claude/CLAUDE.md\n */\n\nimport { existsSync } from 'fs';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { homedir } from 'os';\nimport { parseDesignFramework, type DesignFramework } from './framework-parser.js';\nimport type { MemorySummary } from './schemas.js';\n\nexport interface UserContext {\n  projectDir: string;\n  framework?: DesignFramework;\n  sources: ContextSource[];\n  config: IBRConfig;\n  memory?: MemorySummary;\n}\n\nexport interface ContextSource {\n  path: string;\n  type: 'project-claude' | 'root-claude' | 'user-claude' | 'ibrrc';\n  found: boolean;\n  hasFramework: boolean;\n}\n\nexport interface IBRConfig {\n  baseUrl?: string;\n  outputDir?: string;\n  viewport?: string;\n  threshold?: number;\n  fullPage?: boolean;\n}\n\n/**\n * Discover user context from CLAUDE.md files and config\n */\nexport async function discoverUserContext(projectDir: string): Promise<UserContext> {\n  const sources: ContextSource[] = [];\n  let framework: DesignFramework | undefined;\n\n  // Priority 1: Project .claude/CLAUDE.md\n  const projectClaudePath = join(projectDir, '.claude', 'CLAUDE.md');\n  const projectClaudeResult = await tryLoadFramework(projectClaudePath, 'project-claude');\n  sources.push(projectClaudeResult.source);\n  if (projectClaudeResult.framework && !framework) {\n    framework = projectClaudeResult.framework;\n  }\n\n  // Priority 2: Project root CLAUDE.md\n  const rootClaudePath = join(projectDir, 'CLAUDE.md');\n  const rootClaudeResult = await tryLoadFramework(rootClaudePath, 'root-claude');\n  sources.push(rootClaudeResult.source);\n  if (rootClaudeResult.framework && !framework) {\n    framework = rootClaudeResult.framework;\n  }\n\n  // Priority 3: User ~/.claude/CLAUDE.md\n  const userClaudePath = join(homedir(), '.claude', 'CLAUDE.md');\n  const userClaudeResult = await tryLoadFramework(userClaudePath, 'user-claude');\n  sources.push(userClaudeResult.source);\n  if (userClaudeResult.framework && !framework) {\n    framework = userClaudeResult.framework;\n  }\n\n  // Load IBR config\n  const config = await loadIBRConfig(projectDir);\n\n  // Load memory if available\n  let memory: MemorySummary | undefined;\n  const outputDir = config.outputDir || './.ibr';\n  const memoryPath = join(outputDir, 'memory', 'summary.json');\n  if (existsSync(memoryPath)) {\n    try {\n      const memContent = await readFile(memoryPath, 'utf-8');\n      memory = JSON.parse(memContent) as MemorySummary;\n    } catch {\n      // Memory unavailable - not an error\n    }\n  }\n\n  return {\n    projectDir,\n    framework,\n    sources,\n    config,\n    memory,\n  };\n}\n\n/**\n * Try to load a design framework from a CLAUDE.md file\n */\nasync function tryLoadFramework(\n  filePath: string,\n  type: ContextSource['type']\n): Promise<{ source: ContextSource; framework?: DesignFramework }> {\n  const source: ContextSource = {\n    path: filePath,\n    type,\n    found: false,\n    hasFramework: false,\n  };\n\n  if (!existsSync(filePath)) {\n    return { source };\n  }\n\n  source.found = true;\n\n  try {\n    const content = await readFile(filePath, 'utf-8');\n    const framework = parseDesignFramework(content, filePath);\n\n    if (framework) {\n      source.hasFramework = true;\n      return { source, framework };\n    }\n  } catch (error) {\n    // File exists but couldn't parse - not an error, just no framework found\n  }\n\n  return { source };\n}\n\n/**\n * Load IBR configuration from .ibrrc.json\n */\nasync function loadIBRConfig(projectDir: string): Promise<IBRConfig> {\n  const configPath = join(projectDir, '.ibrrc.json');\n\n  if (!existsSync(configPath)) {\n    return {};\n  }\n\n  try {\n    const content = await readFile(configPath, 'utf-8');\n    return JSON.parse(content);\n  } catch {\n    return {};\n  }\n}\n\n/**\n * Format context for display\n */\nexport function formatContextSummary(context: UserContext): string {\n  const lines: string[] = [];\n\n  if (context.framework) {\n    lines.push(`Design Framework: ${context.framework.name}`);\n    lines.push(`Source: ${context.framework.source}`);\n    lines.push(`Principles: ${context.framework.principles.length}`);\n  } else {\n    lines.push('No design framework detected.');\n    lines.push('');\n    lines.push('To enable design validation, add your framework to CLAUDE.md.');\n    lines.push('IBR will parse principles and generate validation rules automatically.');\n  }\n\n  if (context.memory && context.memory.stats.totalPreferences > 0) {\n    lines.push('');\n    lines.push(`Memory: ${context.memory.stats.totalPreferences} preferences, ${context.memory.stats.totalLearned} learned`);\n  }\n\n  lines.push('');\n  lines.push('Context sources checked:');\n  for (const source of context.sources) {\n    const status = !source.found\n      ? '(not found)'\n      : source.hasFramework\n        ? '(framework detected)'\n        : '(no framework)';\n    lines.push(`  ${source.type}: ${source.path} ${status}`);\n  }\n\n  return lines.join('\\n');\n}\n","/**\n * Dynamic Rules Generator\n *\n * Converts design frameworks parsed from CLAUDE.md into auditable rules.\n * Rules are generated dynamically based on the user's framework, not hardcoded.\n *\n * This is the core of context-aware validation - IBR doesn't enforce\n * generic standards, it validates against what the USER specified.\n */\n\nimport type { EnhancedElement, Violation } from '../schemas.js';\nimport type { Rule, RuleContext, RulePreset } from './engine.js';\nimport type { DesignFramework, DesignPrinciple } from '../framework-parser.js';\n\n/**\n * Extended rule with framework context\n */\nexport interface DynamicRule extends Rule {\n  principleId: string;\n  framework: string;\n  principleIndex: number;\n}\n\n/**\n * Generate rules from a design framework\n */\nexport function generateRulesFromFramework(framework: DesignFramework): DynamicRule[] {\n  const rules: DynamicRule[] = [];\n\n  for (let i = 0; i < framework.principles.length; i++) {\n    const principle = framework.principles[i];\n    const principleRules = generateRulesForPrinciple(principle, framework.name, i);\n    rules.push(...principleRules);\n  }\n\n  return rules;\n}\n\n/**\n * Create a preset from a design framework\n */\nexport function createPresetFromFramework(framework: DesignFramework): RulePreset {\n  const rules = generateRulesFromFramework(framework);\n  const defaults: Record<string, 'warn' | 'error'> = {};\n\n  for (const rule of rules) {\n    defaults[rule.id] = rule.defaultSeverity;\n  }\n\n  return {\n    name: framework.name.toLowerCase().replace(/\\s+/g, '-'),\n    description: `Rules generated from ${framework.name}`,\n    rules,\n    defaults,\n  };\n}\n\n/**\n * Generate rules for a single principle\n */\nfunction generateRulesForPrinciple(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule[] {\n  const rules: DynamicRule[] = [];\n  const baseId = principle.id || `principle-${index + 1}`;\n\n  // Generate rules based on principle keywords and patterns\n  const keywords = extractKeywords(principle);\n\n  // Grouping/Border rules (Gestalt)\n  if (keywords.has('group') || keywords.has('border') || keywords.has('isolate')) {\n    rules.push(createBorderGroupingRule(principle, frameworkName, index));\n  }\n\n  // Size/Importance rules (Fitts' Law)\n  if (keywords.has('size') || keywords.has('importance') || keywords.has('button') || keywords.has('fitts')) {\n    rules.push(createButtonSizingRule(principle, frameworkName, index));\n  }\n\n  // Touch target rules\n  if (keywords.has('touch') || keywords.has('target') || keywords.has('44px') || keywords.has('mobile')) {\n    rules.push(createTouchTargetRule(principle, frameworkName, index));\n  }\n\n  // Hierarchy rules\n  if (keywords.has('hierarchy') || keywords.has('title') || keywords.has('description') || keywords.has('metadata')) {\n    rules.push(createHierarchyRule(principle, frameworkName, index));\n  }\n\n  // Status/Color rules\n  if (keywords.has('status') || keywords.has('color') || keywords.has('background')) {\n    rules.push(createStatusColorRule(principle, frameworkName, index));\n  }\n\n  // Content-chrome ratio\n  if (keywords.has('content') || keywords.has('chrome') || keywords.has('70%')) {\n    rules.push(createContentChromeRule(principle, frameworkName, index));\n  }\n\n  // If no specific rules were generated, create a generic principle reminder rule\n  if (rules.length === 0) {\n    rules.push(createGenericPrincipleRule(principle, frameworkName, index));\n  }\n\n  return rules;\n}\n\n/**\n * Extract keywords from a principle for rule mapping\n */\nfunction extractKeywords(principle: DesignPrinciple): Set<string> {\n  const text = [\n    principle.name,\n    principle.description,\n    ...(principle.foundation || []),\n    ...principle.implementation,\n  ].join(' ').toLowerCase();\n\n  return new Set(text.match(/\\b\\w+\\b/g) || []);\n}\n\n/**\n * Create a border grouping rule from a principle\n */\nfunction createBorderGroupingRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-border`,\n    name: `${principle.name}: Border Usage`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n      // Check if element has individual border when it might be part of a list\n      const style = element.computedStyles;\n      if (!style) return null;\n\n      const hasBorder = style.border && style.border !== 'none' && style.border !== '0px';\n      const isListItem = element.tagName === 'li' || element.selector?.includes('item');\n\n      if (hasBorder && isListItem) {\n        return {\n          ruleId: `${principle.id}-border`,\n          ruleName: `${frameworkName}: ${principle.name}`,\n          severity: 'warn',\n          message: `Individual borders on list items may isolate rather than group. Consider single group border per \"${principle.name}\".`,\n          element: element.selector,\n          bounds: element.bounds,\n          fix: 'Use single border around group with dividers between items.',\n        };\n      }\n\n      return null;\n    },\n  };\n}\n\n/**\n * Create a button sizing rule from a principle\n */\nfunction createButtonSizingRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-button-size`,\n    name: `${principle.name}: Button Sizing`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (element: EnhancedElement, context: RuleContext): Violation | null => {\n      if (element.tagName !== 'button' && element.role !== 'button') return null;\n\n      const width = element.bounds?.width || 0;\n      const height = element.bounds?.height || 0;\n\n      // Check if button has text suggesting it's a primary action\n      const text = (element.text || element.innerText || '').toLowerCase();\n      const isPrimaryAction = /submit|save|confirm|checkout|buy|sign|login|register|continue/i.test(text);\n\n      // Very small buttons for primary actions\n      if (isPrimaryAction && width < 120) {\n        return {\n          ruleId: `${principle.id}-button-size`,\n          ruleName: `${frameworkName}: ${principle.name}`,\n          severity: 'warn',\n          message: `Primary action button \"${text}\" is ${width}px wide. Per \"${principle.name}\", primary actions should be more prominent.`,\n          element: element.selector,\n          bounds: element.bounds,\n          fix: 'Increase button width to match importance of the action.',\n        };\n      }\n\n      return null;\n    },\n  };\n}\n\n/**\n * Create a touch target rule from a principle\n */\nfunction createTouchTargetRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-touch-target`,\n    name: `${principle.name}: Touch Targets`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (element: EnhancedElement, context: RuleContext): Violation | null => {\n      if (!element.interactive?.isInteractive) return null;\n\n      const width = element.bounds?.width || 0;\n      const height = element.bounds?.height || 0;\n      const minSize = context.isMobile ? 44 : 24;\n\n      if (width < minSize || height < minSize) {\n        return {\n          ruleId: `${principle.id}-touch-target`,\n          ruleName: `${frameworkName}: ${principle.name}`,\n          severity: 'warn',\n          message: `Interactive element is ${width}x${height}px, below ${minSize}px minimum per \"${principle.name}\".`,\n          element: element.selector,\n          bounds: element.bounds,\n          fix: `Increase to at least ${minSize}x${minSize}px for ${context.isMobile ? 'mobile' : 'desktop'}.`,\n        };\n      }\n\n      return null;\n    },\n  };\n}\n\n/**\n * Create a hierarchy rule from a principle\n */\nfunction createHierarchyRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-hierarchy`,\n    name: `${principle.name}: Content Hierarchy`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (_element: EnhancedElement, _context: RuleContext): Violation | null => {\n      // Hierarchy checks are more complex and require analyzing multiple elements\n      // This is a placeholder for future implementation\n      return null;\n    },\n  };\n}\n\n/**\n * Create a status color rule from a principle\n */\nfunction createStatusColorRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-status`,\n    name: `${principle.name}: Status Indication`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (element: EnhancedElement, _context: RuleContext): Violation | null => {\n      // Check for status badges with heavy backgrounds\n      const style = element.computedStyles;\n      if (!style) return null;\n\n      const text = (element.text || element.innerText || '').toLowerCase();\n      const isStatusText = /success|error|warning|pending|active|inactive|status/i.test(text);\n\n      if (isStatusText && style.backgroundColor && style.backgroundColor !== 'transparent') {\n        // Check if it's a heavy background (not subtle)\n        // This is a simplified check - could be more sophisticated\n        const bgColor = style.backgroundColor;\n        if (bgColor && !bgColor.includes('rgba') && !bgColor.includes('0.1') && !bgColor.includes('0.05')) {\n          return {\n            ruleId: `${principle.id}-status`,\n            ruleName: `${frameworkName}: ${principle.name}`,\n            severity: 'warn',\n            message: `Status element \"${text}\" has heavy background. Per \"${principle.name}\", consider text color only.`,\n            element: element.selector,\n            bounds: element.bounds,\n            fix: 'Use text color only for status indication, not background.',\n          };\n        }\n      }\n\n      return null;\n    },\n  };\n}\n\n/**\n * Create a content-chrome ratio rule from a principle\n */\nfunction createContentChromeRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-content-chrome`,\n    name: `${principle.name}: Content Ratio`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (_element: EnhancedElement, _context: RuleContext): Violation | null => {\n      // Content-chrome ratio requires page-level analysis\n      // This is a placeholder for future implementation\n      return null;\n    },\n  };\n}\n\n/**\n * Create a generic principle reminder rule\n */\nfunction createGenericPrincipleRule(\n  principle: DesignPrinciple,\n  frameworkName: string,\n  index: number\n): DynamicRule {\n  return {\n    id: `${principle.id}-reminder`,\n    name: `${principle.name}`,\n    description: principle.description,\n    defaultSeverity: 'warn',\n    principleId: principle.id,\n    framework: frameworkName,\n    principleIndex: index,\n    check: (_element: EnhancedElement, _context: RuleContext): Violation | null => {\n      // Generic rules don't check anything - they're for documentation\n      // Could be used to remind about principles during manual review\n      return null;\n    },\n  };\n}\n\n/**\n * Get a summary of rules generated from a framework\n */\nexport function getRulesSummary(rules: DynamicRule[]): string {\n  const byPrinciple = new Map<string, DynamicRule[]>();\n\n  for (const rule of rules) {\n    const existing = byPrinciple.get(rule.principleId) || [];\n    existing.push(rule);\n    byPrinciple.set(rule.principleId, existing);\n  }\n\n  const lines: string[] = [];\n  lines.push(`Generated ${rules.length} rules from ${byPrinciple.size} principles:`);\n  lines.push('');\n\n  for (const [principleId, principleRules] of byPrinciple) {\n    lines.push(`  ${principleId}: ${principleRules.length} rules`);\n    for (const rule of principleRules) {\n      lines.push(`    - ${rule.name}`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n","import { chromium, type BrowserServer, type Browser, type BrowserContext, type Page } from 'playwright';\nimport { writeFile, readFile, unlink, mkdir } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport { nanoid } from 'nanoid';\nimport { VIEWPORTS, type Viewport, type EnhancedElement, type AuditResult } from './schemas.js';\nimport { extractInteractiveElements, analyzeElements } from './extract.js';\n\n/**\n * Browser server state persisted to disk\n */\ninterface BrowserServerState {\n  wsEndpoint: string;\n  cdpUrl?: string;  // CDP URL for reconnection (shares contexts)\n  pid: number;\n  startedAt: string;\n  headless: boolean;\n  isolatedProfile: string;\n  lowMemory?: boolean;  // Whether low-memory mode is enabled\n}\n\n/**\n * Session state stored in the session directory\n */\ninterface SessionState {\n  id: string;\n  url: string;\n  name: string;\n  viewport: Viewport;\n  createdAt: string;\n  pageIndex: number;  // Index in the browser context\n  actions: ActionRecord[];\n  // Element audit data (captured on each screenshot)\n  elements?: EnhancedElement[];\n  audit?: AuditResult;\n}\n\n/**\n * Action record for session history\n */\nexport interface ActionRecord {\n  type: 'navigate' | 'click' | 'type' | 'fill' | 'hover' | 'evaluate' | 'screenshot' | 'wait';\n  timestamp: string;\n  params: Record<string, unknown>;\n  success: boolean;\n  error?: string;\n  duration?: number;\n}\n\n/**\n * Options for creating a session\n */\nexport interface SessionOptions {\n  url: string;\n  name?: string;\n  viewport?: Viewport;\n  waitFor?: string;  // CSS selector to wait for before considering page ready\n  timeout?: number;\n}\n\n/**\n * Options for starting the browser server\n */\nexport interface BrowserServerOptions {\n  headless?: boolean;  // Default: true\n  debug?: boolean;     // Visible + slowMo + devtools\n  isolated?: boolean;  // Use isolated profile (default: true)\n  lowMemory?: boolean; // Reduce memory usage for lower-powered machines\n}\n\nconst SERVER_STATE_FILE = 'browser-server.json';\nconst ISOLATED_PROFILE_DIR = 'browser-profile';\n\n/**\n * Get paths for browser server files\n */\nfunction getPaths(outputDir: string) {\n  return {\n    stateFile: join(outputDir, SERVER_STATE_FILE),\n    profileDir: join(outputDir, ISOLATED_PROFILE_DIR),\n    sessionsDir: join(outputDir, 'sessions'),\n  };\n}\n\n/**\n * Check if browser server is running\n */\nexport async function isServerRunning(outputDir: string): Promise<boolean> {\n  const { stateFile } = getPaths(outputDir);\n\n  if (!existsSync(stateFile)) {\n    return false;\n  }\n\n  try {\n    const content = await readFile(stateFile, 'utf-8');\n    const state: BrowserServerState = JSON.parse(content);\n\n    // Try to connect to verify it's actually running\n    const browser = await chromium.connect(state.wsEndpoint, { timeout: 2000 });\n    await browser.close();\n    return true;\n  } catch {\n    // Server not running or can't connect - clean up stale file\n    await cleanupServerState(outputDir);\n    return false;\n  }\n}\n\n/**\n * Clean up stale server state\n */\nasync function cleanupServerState(outputDir: string): Promise<void> {\n  const { stateFile } = getPaths(outputDir);\n  try {\n    await unlink(stateFile);\n  } catch {\n    // Ignore if file doesn't exist\n  }\n}\n\n/**\n * Start the browser server (long-running process)\n * This should be called from session:start and will keep the process alive\n */\nexport async function startBrowserServer(\n  outputDir: string,\n  options: BrowserServerOptions = {}\n): Promise<{ server: BrowserServer; wsEndpoint: string }> {\n  const { stateFile, profileDir } = getPaths(outputDir);\n  const headless = options.headless ?? !options.debug;\n  const isolated = options.isolated ?? true;\n\n  // Check if already running\n  if (await isServerRunning(outputDir)) {\n    throw new Error('Browser server already running. Use session:close all to stop it first.');\n  }\n\n  // Create directories\n  await mkdir(outputDir, { recursive: true });\n  if (isolated) {\n    await mkdir(profileDir, { recursive: true });\n  }\n\n  // Find an available port for CDP debugging\n  const debugPort = 9222 + Math.floor(Math.random() * 1000);\n\n  // Build browser args\n  const browserArgs: string[] = [`--remote-debugging-port=${debugPort}`];\n\n  // Low memory mode args - reduces Chromium memory footprint\n  // Useful for lower-powered machines (4GB RAM, older CPUs)\n  if (options.lowMemory) {\n    browserArgs.push(\n      '--disable-gpu',                    // Disable GPU acceleration\n      '--disable-dev-shm-usage',          // Use /tmp instead of /dev/shm\n      '--disable-extensions',             // No extensions\n      '--disable-background-networking',  // Reduce background activity\n      '--disable-default-apps',           // No default Chrome apps\n      '--disable-sync',                   // No Chrome sync\n      '--no-first-run',                   // Skip first run tasks\n      '--disable-background-timer-throttling',\n      '--disable-backgrounding-occluded-windows',\n      '--disable-renderer-backgrounding',\n      '--disable-features=TranslateUI',\n      '--disable-ipc-flooding-protection',\n      '--memory-pressure-off',            // Don't respond to memory pressure\n      '--js-flags=--max-old-space-size=256', // Limit V8 heap to 256MB\n    );\n  }\n\n  // Launch browser server with CDP debugging enabled\n  // This allows connectOverCDP to work and share contexts across reconnections\n  // Note: slowMo is not available on launchServer, only on launch()\n  const server = await chromium.launchServer({\n    headless,\n    args: browserArgs,\n  });\n\n  const wsEndpoint = server.wsEndpoint();\n  const cdpUrl = `http://127.0.0.1:${debugPort}`;\n\n  // Save server state\n  const state: BrowserServerState = {\n    wsEndpoint,\n    cdpUrl,\n    pid: process.pid,\n    startedAt: new Date().toISOString(),\n    headless,\n    isolatedProfile: isolated ? profileDir : '',\n    lowMemory: options.lowMemory,\n  };\n\n  await writeFile(stateFile, JSON.stringify(state, null, 2));\n\n  return { server, wsEndpoint };\n}\n\n/**\n * Connect to existing browser server\n * Uses CDP connection which shares contexts across reconnections\n */\nexport async function connectToBrowserServer(outputDir: string): Promise<Browser | null> {\n  const { stateFile } = getPaths(outputDir);\n\n  if (!existsSync(stateFile)) {\n    return null;\n  }\n\n  try {\n    const content = await readFile(stateFile, 'utf-8');\n    const state: BrowserServerState = JSON.parse(content);\n\n    // Use connectOverCDP to share contexts across reconnections\n    // This is critical - chromium.connect() creates isolated contexts per connection\n    // but connectOverCDP shares the same browser instance and sees all contexts\n    if (state.cdpUrl) {\n      const browser = await chromium.connectOverCDP(state.cdpUrl, { timeout: 5000 });\n      return browser;\n    }\n\n    // Fallback to standard connect (older state files without cdpUrl)\n    const browser = await chromium.connect(state.wsEndpoint, { timeout: 5000 });\n    return browser;\n  } catch (error) {\n    // Server not running - clean up\n    await cleanupServerState(outputDir);\n    return null;\n  }\n}\n\n/**\n * Stop the browser server\n */\nexport async function stopBrowserServer(outputDir: string): Promise<boolean> {\n  const { stateFile, profileDir: _profileDir } = getPaths(outputDir);\n\n  if (!existsSync(stateFile)) {\n    return false;\n  }\n\n  try {\n    const content = await readFile(stateFile, 'utf-8');\n    const state: BrowserServerState = JSON.parse(content);\n\n    // Connect and close\n    const browser = await chromium.connect(state.wsEndpoint, { timeout: 5000 });\n    await browser.close();\n\n    // Clean up state file\n    await unlink(stateFile);\n\n    // Optionally clean up profile dir\n    // await rm(profileDir, { recursive: true, force: true });\n\n    return true;\n  } catch {\n    // Force cleanup of state file\n    await cleanupServerState(outputDir);\n    return false;\n  }\n}\n\n/**\n * Persistent session that connects to browser server\n */\nexport class PersistentSession {\n  // Browser reference kept for potential future cleanup operations\n  public readonly browser: Browser;\n  private context: BrowserContext;\n  private page: Page;\n  private state: SessionState;\n  private sessionDir: string;\n\n  private constructor(\n    browser: Browser,\n    context: BrowserContext,\n    page: Page,\n    state: SessionState,\n    sessionDir: string\n  ) {\n    this.browser = browser;\n    this.context = context;\n    this.page = page;\n    this.state = state;\n    this.sessionDir = sessionDir;\n  }\n\n  /**\n   * Create a new session using the browser server\n   */\n  static async create(\n    outputDir: string,\n    options: SessionOptions\n  ): Promise<PersistentSession> {\n    const { url, name, viewport = VIEWPORTS.desktop, waitFor, timeout = 30000 } = options;\n\n    // Connect to browser server\n    const browser = await connectToBrowserServer(outputDir);\n    if (!browser) {\n      throw new Error(\n        'No browser server running.\\n' +\n        'Start one with: npx ibr session:start <url>\\n' +\n        'The first session:start launches the server and keeps it alive.'\n      );\n    }\n\n    // Generate session ID\n    const sessionId = `live_${nanoid(10)}`;\n    const sessionsDir = join(outputDir, 'sessions');\n    const sessionDir = join(sessionsDir, sessionId);\n    await mkdir(sessionDir, { recursive: true });\n\n    // Create context with viewport\n    const context = await browser.newContext({\n      viewport: {\n        width: viewport.width,\n        height: viewport.height,\n      },\n      reducedMotion: 'reduce',\n    });\n\n    // Create page and navigate\n    const page = await context.newPage();\n\n    const navStart = Date.now();\n    await page.goto(url, {\n      waitUntil: 'networkidle',\n      timeout,\n    });\n\n    // Wait for specific selector if requested\n    if (waitFor) {\n      await page.waitForSelector(waitFor, { timeout });\n    }\n\n    const navDuration = Date.now() - navStart;\n\n    // Initialize state\n    const state: SessionState = {\n      id: sessionId,\n      url,\n      name: name || new URL(url).pathname,\n      viewport,\n      createdAt: new Date().toISOString(),\n      pageIndex: 0,\n      actions: [{\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url, waitFor },\n        success: true,\n        duration: navDuration,\n      }],\n    };\n\n    // Save state\n    await writeFile(\n      join(sessionDir, 'live-session.json'),\n      JSON.stringify(state, null, 2)\n    );\n\n    // Capture initial screenshot as baseline\n    await page.screenshot({\n      path: join(sessionDir, 'baseline.png'),\n      fullPage: false,\n    });\n\n    return new PersistentSession(browser, context, page, state, sessionDir);\n  }\n\n  /**\n   * Get session from browser server by ID\n   */\n  static async get(outputDir: string, sessionId: string): Promise<PersistentSession | null> {\n    const sessionDir = join(outputDir, 'sessions', sessionId);\n    const statePath = join(sessionDir, 'live-session.json');\n\n    if (!existsSync(statePath)) {\n      return null;\n    }\n\n    // Connect to browser server\n    const browser = await connectToBrowserServer(outputDir);\n    if (!browser) {\n      return null;\n    }\n\n    // Load session state\n    const content = await readFile(statePath, 'utf-8');\n    const state: SessionState = JSON.parse(content);\n\n    // Find existing page or create new one\n    const contexts = browser.contexts();\n    let context: BrowserContext;\n    let page: Page;\n\n    const targetHost = new URL(state.url).host;\n\n    if (contexts.length > 0) {\n      // Try to find the page with matching URL\n      for (const ctx of contexts) {\n        const pages = ctx.pages();\n        for (const p of pages) {\n          if (p.url().includes(targetHost)) {\n            context = ctx;\n            page = p;\n            return new PersistentSession(browser, context, page, state, sessionDir);\n          }\n        }\n      }\n    }\n\n    // No matching page found - recreate\n    context = await browser.newContext({\n      viewport: {\n        width: state.viewport.width,\n        height: state.viewport.height,\n      },\n      reducedMotion: 'reduce',\n    });\n\n    page = await context.newPage();\n    await page.goto(state.url, { waitUntil: 'networkidle' });\n\n    return new PersistentSession(browser, context, page, state, sessionDir);\n  }\n\n  get id(): string {\n    return this.state.id;\n  }\n\n  get url(): string {\n    return this.page?.url() || this.state.url;\n  }\n\n  get actions(): ActionRecord[] {\n    return [...this.state.actions];\n  }\n\n  private async recordAction(action: ActionRecord): Promise<void> {\n    this.state.actions.push(action);\n    await this.saveState();\n  }\n\n  private async saveState(): Promise<void> {\n    await writeFile(\n      join(this.sessionDir, 'live-session.json'),\n      JSON.stringify(this.state, null, 2)\n    );\n  }\n\n  async navigate(url: string, options?: { timeout?: number; waitFor?: string }): Promise<void> {\n    const start = Date.now();\n\n    try {\n      await this.page.goto(url, {\n        waitUntil: 'networkidle',\n        timeout: options?.timeout || 30000,\n      });\n\n      if (options?.waitFor) {\n        await this.page.waitForSelector(options.waitFor, { timeout: options?.timeout || 30000 });\n      }\n\n      this.state.url = url;\n      await this.recordAction({\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url, waitFor: options?.waitFor },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  async click(selector: string, options?: { timeout?: number; force?: boolean }): Promise<void> {\n    const start = Date.now();\n    const timeout = options?.timeout || 5000;\n\n    try {\n      // Use locator API with visible filter - targets only visible elements\n      // This is BETTER than waitForSelector which waits for first match to become visible\n      const locator = this.page.locator(selector).filter({ visible: true }).first();\n      await locator.click({ timeout, force: options?.force });\n      await this.recordAction({\n        type: 'click',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'click',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  async type(selector: string, text: string, options?: { delay?: number; timeout?: number; submit?: boolean; waitAfter?: number; append?: boolean }): Promise<void> {\n    const start = Date.now();\n    const timeout = options?.timeout || 5000;\n\n    try {\n      // Use locator API with visible filter - auto-targets visible input\n      const locator = this.page.locator(selector).filter({ visible: true }).first();\n\n      // Clear existing content unless appending\n      if (!options?.append) {\n        await locator.fill('', { timeout });\n      }\n\n      if (options?.delay && options.delay > 0) {\n        // Type character by character with delay\n        if (options?.append) {\n          await locator.focus({ timeout });\n        }\n        await locator.pressSequentially(text, { delay: options.delay, timeout });\n      } else if (options?.append) {\n        // Append mode: focus and type without clearing\n        await locator.focus({ timeout });\n        await locator.pressSequentially(text, { timeout });\n      } else {\n        // Fast fill (default)\n        await locator.fill(text, { timeout });\n      }\n\n      // Submit if requested (press Enter)\n      if (options?.submit) {\n        await locator.press('Enter', { timeout });\n        // Wait for navigation/network after submit\n        if (options?.waitAfter) {\n          await this.page.waitForTimeout(options.waitAfter);\n        } else {\n          // Default: wait for network idle after submit\n          await this.page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});\n        }\n      } else if (options?.waitAfter) {\n        await this.page.waitForTimeout(options.waitAfter);\n      }\n\n      await this.recordAction({\n        type: 'type',\n        timestamp: new Date().toISOString(),\n        params: { selector, text: text.length > 50 ? `${text.slice(0, 50)}...` : text, submit: options?.submit },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'type',\n        timestamp: new Date().toISOString(),\n        params: { selector, text: text.length > 50 ? `${text.slice(0, 50)}...` : text },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  async waitFor(selectorOrTime: string | number, options?: { timeout?: number }): Promise<void> {\n    const start = Date.now();\n\n    try {\n      if (typeof selectorOrTime === 'number') {\n        await this.page.waitForTimeout(selectorOrTime);\n      } else {\n        // Use locator API with visible filter - waits for visible element only\n        const locator = this.page.locator(selectorOrTime).filter({ visible: true }).first();\n        await locator.waitFor({\n          state: 'visible',\n          timeout: options?.timeout || 30000\n        });\n      }\n      await this.recordAction({\n        type: 'wait',\n        timestamp: new Date().toISOString(),\n        params: { target: selectorOrTime },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'wait',\n        timestamp: new Date().toISOString(),\n        params: { target: selectorOrTime },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  async screenshot(options?: { name?: string; fullPage?: boolean; selector?: string }): Promise<{ path: string; elements: EnhancedElement[]; audit: AuditResult }> {\n    const start = Date.now();\n    const screenshotName = options?.name || `screenshot-${Date.now()}`;\n    const outputPath = join(this.sessionDir, `${screenshotName}.png`);\n\n    try {\n      // Disable animations\n      await this.page.addStyleTag({\n        content: `\n          *, *::before, *::after {\n            animation-duration: 0s !important;\n            animation-delay: 0s !important;\n            transition-duration: 0s !important;\n            transition-delay: 0s !important;\n          }\n        `,\n      });\n\n      if (options?.selector) {\n        const element = await this.page.waitForSelector(options.selector, { timeout: 5000 });\n        if (!element) {\n          throw new Error(`Element not found: ${options.selector}`);\n        }\n        await element.screenshot({ path: outputPath, type: 'png' });\n      } else {\n        await this.page.screenshot({\n          path: outputPath,\n          fullPage: options?.fullPage ?? true,\n          type: 'png',\n        });\n      }\n\n      // Extract interactive elements for audit\n      const elements = await extractInteractiveElements(this.page);\n\n      // Analyze for issues (detect mobile by viewport width)\n      const isMobile = this.state.viewport.width < 768;\n      const audit = analyzeElements(elements, isMobile);\n\n      // Store in session state\n      this.state.elements = elements;\n      this.state.audit = audit;\n      await this.saveState();\n\n      await this.recordAction({\n        type: 'screenshot',\n        timestamp: new Date().toISOString(),\n        params: {\n          name: screenshotName,\n          path: outputPath,\n          selector: options?.selector,\n          elementsCount: elements.length,\n          issuesCount: audit.issues.length,\n        },\n        success: true,\n        duration: Date.now() - start,\n      });\n\n      return { path: outputPath, elements, audit };\n    } catch (error) {\n      await this.recordAction({\n        type: 'screenshot',\n        timestamp: new Date().toISOString(),\n        params: { name: screenshotName, selector: options?.selector },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  async press(key: string): Promise<void> {\n    await this.page.keyboard.press(key);\n  }\n\n  /**\n   * Scroll the page or a specific container\n   * @param direction - 'up', 'down', 'left', 'right'\n   * @param amount - pixels to scroll (default: 500)\n   * @param options - optional selector to scroll within a container\n   */\n  async scroll(\n    direction: 'up' | 'down' | 'left' | 'right',\n    amount: number = 500,\n    options?: { selector?: string }\n  ): Promise<{ x: number; y: number }> {\n    const scrollMap = {\n      up: { x: 0, y: -amount },\n      down: { x: 0, y: amount },\n      left: { x: -amount, y: 0 },\n      right: { x: amount, y: 0 },\n    };\n    const { x, y } = scrollMap[direction];\n\n    if (options?.selector) {\n      // Scroll within a specific container (modal, sidebar, etc.)\n      const position = await this.page.evaluate(({ sel, deltaX, deltaY }) => {\n        const el = document.querySelector(sel);\n        if (!el) {\n          throw new Error(`Container not found: ${sel}`);\n        }\n        el.scrollBy(deltaX, deltaY);\n        return { x: el.scrollLeft, y: el.scrollTop };\n      }, { sel: options.selector, deltaX: x, deltaY: y });\n\n      return position;\n    }\n\n    // Default: scroll window\n    const position = await this.page.evaluate(({ deltaX, deltaY }) => {\n      window.scrollBy(deltaX, deltaY);\n      return { x: window.scrollX, y: window.scrollY };\n    }, { deltaX: x, deltaY: y });\n\n    return position;\n  }\n\n  async evaluate<T>(script: string | (() => T)): Promise<T> {\n    return this.page.evaluate(script) as Promise<T>;\n  }\n\n  /**\n   * Detect if a modal is currently open and how to dismiss it\n   */\n  async detectModal(): Promise<{\n    hasModal: boolean;\n    selector?: string;\n    dismissMethod?: 'escape' | 'close-button' | 'backdrop';\n    closeButtonSelector?: string;\n  }> {\n    return this.page.evaluate(() => {\n      // Common modal selectors (Bootstrap, Radix, Headless UI, custom)\n      const modalSelectors = [\n        '[role=\"dialog\"]',\n        '[role=\"alertdialog\"]',\n        '[aria-modal=\"true\"]',\n        '.modal.show',\n        '.modal.open',\n        '.modal[style*=\"display: block\"]',\n        '[data-state=\"open\"][data-modal]',\n        '.fixed.inset-0', // Tailwind modal pattern\n      ];\n\n      for (const sel of modalSelectors) {\n        const modal = document.querySelector(sel);\n        if (modal && getComputedStyle(modal).display !== 'none') {\n          // Check for close button\n          const closeSelectors = [\n            '[aria-label=\"Close\"]',\n            '[aria-label=\"close\"]',\n            '.close',\n            '.btn-close',\n            '[data-dismiss=\"modal\"]',\n            'button[type=\"button\"]:has(svg)', // Icon-only close button\n          ];\n\n          let closeButtonSelector: string | undefined;\n          for (const closeSel of closeSelectors) {\n            const closeBtn = modal.querySelector(closeSel);\n            if (closeBtn) {\n              closeButtonSelector = `${sel} ${closeSel}`;\n              break;\n            }\n          }\n\n          return {\n            hasModal: true,\n            selector: sel,\n            dismissMethod: closeButtonSelector ? 'close-button' : 'escape',\n            closeButtonSelector,\n          };\n        }\n      }\n\n      return { hasModal: false };\n    });\n  }\n\n  async content(): Promise<string> {\n    return this.page.content();\n  }\n\n  async title(): Promise<string> {\n    return this.page.title();\n  }\n\n  /**\n   * Get text content from a specific selector\n   */\n  async textContent(selector: string): Promise<string | null> {\n    return this.page.textContent(selector);\n  }\n\n  /**\n   * Get inner text from a specific selector (visible text only)\n   */\n  async innerText(selector: string): Promise<string> {\n    return this.page.innerText(selector);\n  }\n\n  /**\n   * Get all matching elements' text content\n   */\n  async allTextContent(selector: string): Promise<string[]> {\n    const elements = await this.page.$$(selector);\n    const texts: string[] = [];\n    for (const el of elements) {\n      const text = await el.textContent();\n      if (text) texts.push(text.trim());\n    }\n    return texts;\n  }\n\n  /**\n   * Close just this session (not the browser server)\n   */\n  async close(): Promise<void> {\n    await this.context.close();\n  }\n\n  /**\n   * Get raw Playwright page\n   */\n  getPage(): Page {\n    return this.page;\n  }\n}\n\n/**\n * List active sessions by checking session directories\n */\nexport async function listActiveSessions(outputDir: string): Promise<string[]> {\n  const { sessionsDir } = getPaths(outputDir);\n\n  if (!existsSync(sessionsDir)) {\n    return [];\n  }\n\n  const { readdir } = await import('fs/promises');\n  const entries = await readdir(sessionsDir, { withFileTypes: true });\n\n  const liveSessions: string[] = [];\n\n  for (const entry of entries) {\n    if (entry.isDirectory() && entry.name.startsWith('live_')) {\n      const statePath = join(sessionsDir, entry.name, 'live-session.json');\n      if (existsSync(statePath)) {\n        liveSessions.push(entry.name);\n      }\n    }\n  }\n\n  return liveSessions;\n}\n","import { chromium, type Browser, type BrowserContext, type Page } from 'playwright';\nimport { writeFile, readFile, mkdir } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\nimport { nanoid } from 'nanoid';\nimport { VIEWPORTS, type Viewport } from './schemas.js';\n\n/**\n * Live session state file structure\n */\ninterface LiveSessionState {\n  id: string;\n  url: string;\n  name: string;\n  viewport: Viewport;\n  sandbox: boolean;\n  createdAt: string;\n  actions: ActionRecord[];\n}\n\n/**\n * Recorded action for reproducibility\n */\nexport interface ActionRecord {\n  type: 'navigate' | 'click' | 'type' | 'fill' | 'hover' | 'evaluate' | 'screenshot' | 'wait';\n  timestamp: string;\n  params: Record<string, unknown>;\n  success: boolean;\n  error?: string;\n  duration?: number;\n}\n\n/**\n * Options for creating a live session\n */\nexport interface LiveSessionOptions {\n  url: string;\n  name?: string;\n  viewport?: Viewport;\n  sandbox?: boolean;  // visible browser (default: false = headless)\n  debug?: boolean;    // sandbox + slowMo + devtools\n  timeout?: number;\n}\n\n/**\n * Fill form field definition\n */\nexport interface FormField {\n  selector: string;\n  value: string;\n  type?: 'text' | 'checkbox' | 'radio' | 'select';\n}\n\n/**\n * Screenshot options for live sessions\n */\nexport interface LiveScreenshotOptions {\n  name?: string;\n  fullPage?: boolean;\n  selector?: string;\n}\n\n/**\n * Live interactive browser session\n * Keeps browser alive for sequential interactions\n */\nexport class LiveSession {\n  private browser: Browser | null = null;\n  private context: BrowserContext | null = null;\n  private page: Page | null = null;\n  private state: LiveSessionState;\n  // Output directory kept for potential future directory operations\n  public readonly outputDir: string;\n  private sessionDir: string;\n\n  private constructor(\n    state: LiveSessionState,\n    outputDir: string,\n    browser: Browser,\n    context: BrowserContext,\n    page: Page\n  ) {\n    this.state = state;\n    this.outputDir = outputDir;\n    this.sessionDir = join(outputDir, 'sessions', state.id);\n    this.browser = browser;\n    this.context = context;\n    this.page = page;\n  }\n\n  /**\n   * Create a new live session\n   */\n  static async create(outputDir: string, options: LiveSessionOptions): Promise<LiveSession> {\n    const {\n      url,\n      name,\n      viewport = VIEWPORTS.desktop,\n      sandbox = false,\n      debug = false,\n      timeout = 30000,\n    } = options;\n\n    // Generate session ID\n    const sessionId = `live_${nanoid(10)}`;\n    const sessionDir = join(outputDir, 'sessions', sessionId);\n    await mkdir(sessionDir, { recursive: true });\n\n    // Launch browser with appropriate mode\n    const browser = await chromium.launch({\n      headless: !sandbox && !debug,\n      slowMo: debug ? 100 : 0,\n      devtools: debug,\n    });\n\n    // Create context with viewport\n    const context = await browser.newContext({\n      viewport: {\n        width: viewport.width,\n        height: viewport.height,\n      },\n      reducedMotion: 'reduce',\n    });\n\n    // Create page and navigate\n    const page = await context.newPage();\n\n    const navStart = Date.now();\n    await page.goto(url, {\n      waitUntil: 'networkidle',\n      timeout,\n    });\n    const navDuration = Date.now() - navStart;\n\n    // Initialize state\n    const state: LiveSessionState = {\n      id: sessionId,\n      url,\n      name: name || new URL(url).pathname,\n      viewport,\n      sandbox: sandbox || debug,\n      createdAt: new Date().toISOString(),\n      actions: [{\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url },\n        success: true,\n        duration: navDuration,\n      }],\n    };\n\n    // Save initial state\n    await writeFile(\n      join(sessionDir, 'live-session.json'),\n      JSON.stringify(state, null, 2)\n    );\n\n    // Capture initial screenshot as baseline for UI display\n    await page.screenshot({\n      path: join(sessionDir, 'baseline.png'),\n      fullPage: false,\n    });\n\n    return new LiveSession(state, outputDir, browser, context, page);\n  }\n\n  /**\n   * Resume an existing live session (if browser still running)\n   * Note: This only works within the same process - browser state is not persisted\n   */\n  static async resume(outputDir: string, sessionId: string): Promise<LiveSession | null> {\n    const sessionDir = join(outputDir, 'sessions', sessionId);\n    const statePath = join(sessionDir, 'live-session.json');\n\n    if (!existsSync(statePath)) {\n      return null;\n    }\n\n    // Load state - but browser needs to be recreated\n    const content = await readFile(statePath, 'utf-8');\n    const state = JSON.parse(content) as LiveSessionState;\n\n    // Relaunch browser and navigate to last URL\n    const browser = await chromium.launch({\n      headless: !state.sandbox,\n    });\n\n    const context = await browser.newContext({\n      viewport: {\n        width: state.viewport.width,\n        height: state.viewport.height,\n      },\n      reducedMotion: 'reduce',\n    });\n\n    const page = await context.newPage();\n    await page.goto(state.url, { waitUntil: 'networkidle' });\n\n    return new LiveSession(state, outputDir, browser, context, page);\n  }\n\n  /**\n   * Get session ID\n   */\n  get id(): string {\n    return this.state.id;\n  }\n\n  /**\n   * Get current URL\n   */\n  get url(): string {\n    return this.page?.url() || this.state.url;\n  }\n\n  /**\n   * Get action history\n   */\n  get actions(): ActionRecord[] {\n    return [...this.state.actions];\n  }\n\n  /**\n   * Record an action\n   */\n  private async recordAction(action: ActionRecord): Promise<void> {\n    this.state.actions.push(action);\n    await this.saveState();\n  }\n\n  /**\n   * Save session state\n   */\n  private async saveState(): Promise<void> {\n    await writeFile(\n      join(this.sessionDir, 'live-session.json'),\n      JSON.stringify(this.state, null, 2)\n    );\n  }\n\n  /**\n   * Ensure page is available\n   */\n  private ensurePage(): Page {\n    if (!this.page) {\n      throw new Error('Session is closed. Create a new session.');\n    }\n    return this.page;\n  }\n\n  /**\n   * Navigate to a new URL\n   */\n  async navigate(url: string, options?: { timeout?: number }): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      await page.goto(url, {\n        waitUntil: 'networkidle',\n        timeout: options?.timeout || 30000,\n      });\n      this.state.url = url;\n      await this.recordAction({\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'navigate',\n        timestamp: new Date().toISOString(),\n        params: { url },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Click an element\n   */\n  async click(selector: string, options?: { timeout?: number }): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      await page.click(selector, { timeout: options?.timeout || 5000 });\n      await this.recordAction({\n        type: 'click',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'click',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Type text into an element (clears existing content first)\n   */\n  async type(selector: string, text: string, options?: { delay?: number; timeout?: number }): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      await page.fill(selector, ''); // Clear first\n      await page.type(selector, text, { delay: options?.delay || 0 });\n      await this.recordAction({\n        type: 'type',\n        timestamp: new Date().toISOString(),\n        params: { selector, text: text.length > 50 ? `${text.slice(0, 50)}...` : text },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'type',\n        timestamp: new Date().toISOString(),\n        params: { selector, text: text.length > 50 ? `${text.slice(0, 50)}...` : text },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Fill a form with multiple fields\n   */\n  async fill(fields: FormField[]): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n    const results: { selector: string; success: boolean; error?: string }[] = [];\n\n    for (const field of fields) {\n      try {\n        if (field.type === 'checkbox') {\n          if (field.value === 'true' || field.value === '1') {\n            await page.check(field.selector);\n          } else {\n            await page.uncheck(field.selector);\n          }\n        } else if (field.type === 'select') {\n          await page.selectOption(field.selector, field.value);\n        } else {\n          await page.fill(field.selector, field.value);\n        }\n        results.push({ selector: field.selector, success: true });\n      } catch (error) {\n        results.push({\n          selector: field.selector,\n          success: false,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    const allSuccess = results.every(r => r.success);\n    await this.recordAction({\n      type: 'fill',\n      timestamp: new Date().toISOString(),\n      params: { fields: fields.map(f => ({ selector: f.selector, type: f.type || 'text' })), results },\n      success: allSuccess,\n      error: allSuccess ? undefined : `Failed to fill ${results.filter(r => !r.success).length} field(s)`,\n      duration: Date.now() - start,\n    });\n\n    if (!allSuccess) {\n      const failed = results.filter(r => !r.success);\n      throw new Error(`Failed to fill fields: ${failed.map(f => f.selector).join(', ')}`);\n    }\n  }\n\n  /**\n   * Hover over an element\n   */\n  async hover(selector: string, options?: { timeout?: number }): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      await page.hover(selector, { timeout: options?.timeout || 5000 });\n      await this.recordAction({\n        type: 'hover',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'hover',\n        timestamp: new Date().toISOString(),\n        params: { selector },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute JavaScript in the page context\n   */\n  async evaluate<T>(script: string | (() => T)): Promise<T> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      const result = await page.evaluate(script);\n      await this.recordAction({\n        type: 'evaluate',\n        timestamp: new Date().toISOString(),\n        params: { script: typeof script === 'string' ? script.slice(0, 100) : '[function]' },\n        success: true,\n        duration: Date.now() - start,\n      });\n      return result as T;\n    } catch (error) {\n      await this.recordAction({\n        type: 'evaluate',\n        timestamp: new Date().toISOString(),\n        params: { script: typeof script === 'string' ? script.slice(0, 100) : '[function]' },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Wait for a selector or timeout\n   */\n  async waitFor(selectorOrTime: string | number, options?: { timeout?: number }): Promise<void> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    try {\n      if (typeof selectorOrTime === 'number') {\n        await page.waitForTimeout(selectorOrTime);\n      } else {\n        await page.waitForSelector(selectorOrTime, { timeout: options?.timeout || 30000 });\n      }\n      await this.recordAction({\n        type: 'wait',\n        timestamp: new Date().toISOString(),\n        params: { target: selectorOrTime },\n        success: true,\n        duration: Date.now() - start,\n      });\n    } catch (error) {\n      await this.recordAction({\n        type: 'wait',\n        timestamp: new Date().toISOString(),\n        params: { target: selectorOrTime },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Take a screenshot\n   */\n  async screenshot(options?: LiveScreenshotOptions): Promise<string> {\n    const page = this.ensurePage();\n    const start = Date.now();\n\n    const screenshotName = options?.name || `screenshot-${Date.now()}`;\n    const outputPath = join(this.sessionDir, `${screenshotName}.png`);\n\n    try {\n      // Disable animations\n      await page.addStyleTag({\n        content: `\n          *, *::before, *::after {\n            animation-duration: 0s !important;\n            animation-delay: 0s !important;\n            transition-duration: 0s !important;\n            transition-delay: 0s !important;\n          }\n        `,\n      });\n\n      if (options?.selector) {\n        const element = await page.waitForSelector(options.selector, { timeout: 5000 });\n        if (!element) {\n          throw new Error(`Element not found: ${options.selector}`);\n        }\n        await element.screenshot({ path: outputPath, type: 'png' });\n      } else {\n        await page.screenshot({\n          path: outputPath,\n          fullPage: options?.fullPage ?? true,\n          type: 'png',\n        });\n      }\n\n      await this.recordAction({\n        type: 'screenshot',\n        timestamp: new Date().toISOString(),\n        params: { name: screenshotName, path: outputPath, selector: options?.selector },\n        success: true,\n        duration: Date.now() - start,\n      });\n\n      return outputPath;\n    } catch (error) {\n      await this.recordAction({\n        type: 'screenshot',\n        timestamp: new Date().toISOString(),\n        params: { name: screenshotName, selector: options?.selector },\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        duration: Date.now() - start,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get page content (HTML)\n   */\n  async content(): Promise<string> {\n    const page = this.ensurePage();\n    return page.content();\n  }\n\n  /**\n   * Get page title\n   */\n  async title(): Promise<string> {\n    const page = this.ensurePage();\n    return page.title();\n  }\n\n  /**\n   * Check if an element exists\n   */\n  async exists(selector: string): Promise<boolean> {\n    const page = this.ensurePage();\n    const element = await page.$(selector);\n    return element !== null;\n  }\n\n  /**\n   * Get text content of an element\n   */\n  async textContent(selector: string): Promise<string | null> {\n    const page = this.ensurePage();\n    return page.textContent(selector);\n  }\n\n  /**\n   * Get attribute of an element\n   */\n  async getAttribute(selector: string, attribute: string): Promise<string | null> {\n    const page = this.ensurePage();\n    return page.getAttribute(selector, attribute);\n  }\n\n  /**\n   * Press a keyboard key\n   */\n  async press(key: string): Promise<void> {\n    const page = this.ensurePage();\n    await page.keyboard.press(key);\n  }\n\n  /**\n   * Select option(s) from a dropdown\n   */\n  async select(selector: string, values: string | string[]): Promise<void> {\n    const page = this.ensurePage();\n    await page.selectOption(selector, values);\n  }\n\n  /**\n   * Close the session and browser\n   */\n  async close(): Promise<void> {\n    if (this.context) {\n      await this.context.close();\n      this.context = null;\n    }\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = null;\n    }\n    this.page = null;\n\n    // Mark session as closed in state\n    await this.saveState();\n  }\n\n  /**\n   * Check if session is still active\n   */\n  get isActive(): boolean {\n    return this.browser !== null && this.page !== null;\n  }\n\n  /**\n   * Get underlying Playwright page (for advanced use)\n   */\n  getPage(): Page {\n    return this.ensurePage();\n  }\n}\n\n/**\n * Singleton manager for live sessions\n */\nclass LiveSessionManager {\n  private sessions: Map<string, LiveSession> = new Map();\n\n  /**\n   * Create a new live session\n   */\n  async create(outputDir: string, options: LiveSessionOptions): Promise<LiveSession> {\n    const session = await LiveSession.create(outputDir, options);\n    this.sessions.set(session.id, session);\n    return session;\n  }\n\n  /**\n   * Get an active session by ID\n   */\n  get(sessionId: string): LiveSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  /**\n   * Close a session\n   */\n  async close(sessionId: string): Promise<boolean> {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      await session.close();\n      this.sessions.delete(sessionId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Close all sessions\n   */\n  async closeAll(): Promise<void> {\n    for (const session of this.sessions.values()) {\n      await session.close();\n    }\n    this.sessions.clear();\n  }\n\n  /**\n   * List active session IDs\n   */\n  list(): string[] {\n    return Array.from(this.sessions.keys());\n  }\n}\n\n// Export singleton manager\nexport const liveSessionManager = new LiveSessionManager();\n","/**\n * Screenshot Manager\n *\n * Handles screenshot storage, cleanup, and metadata management.\n * Prevents disk bloat with configurable retention policies.\n */\n\nimport type { Page } from 'playwright';\nimport { writeFile, readFile, readdir, stat, unlink, mkdir } from 'fs/promises';\nimport { existsSync } from 'fs';\nimport { join, basename, dirname } from 'path';\n\n/**\n * Configuration for screenshot retention\n */\nexport interface ScreenshotConfig {\n  /** Days before auto-cleanup (default: 7) */\n  maxAgeDays: number;\n  /** Max total storage in bytes (default: 500MB) */\n  maxSizeBytes: number;\n  /** Retention policy: age, size, or both */\n  retentionPolicy: 'age' | 'size' | 'both';\n}\n\n/**\n * Information about a single screenshot\n */\nexport interface ScreenshotInfo {\n  /** File path */\n  path: string;\n  /** File name */\n  name: string;\n  /** File size in bytes */\n  size: number;\n  /** Creation timestamp */\n  createdAt: Date;\n  /** Age in milliseconds */\n  ageMs: number;\n  /** Associated session ID */\n  sessionId?: string;\n  /** Step name if from search flow */\n  step?: string;\n}\n\n/**\n * Screenshot metadata for UI display\n */\nexport interface ScreenshotMetadata {\n  path: string;\n  name: string;\n  size: number;\n  createdAt: string;\n  width?: number;\n  height?: number;\n  sessionId?: string;\n  step?: string;\n  query?: string;\n  userIntent?: string;\n}\n\n/**\n * Report from cleanup operation\n */\nexport interface CleanupReport {\n  /** Total files scanned */\n  scanned: number;\n  /** Files deleted */\n  deleted: number;\n  /** Bytes freed */\n  bytesFreed: number;\n  /** Files kept */\n  kept: number;\n  /** Errors encountered */\n  errors: string[];\n  /** Dry run mode */\n  dryRun: boolean;\n}\n\n/**\n * Default configuration\n */\nconst DEFAULT_CONFIG: ScreenshotConfig = {\n  maxAgeDays: 7,\n  maxSizeBytes: 500 * 1024 * 1024, // 500MB\n  retentionPolicy: 'both',\n};\n\n/**\n * Screenshot Manager class\n *\n * Manages screenshot capture, storage, and cleanup for UI testing.\n */\nexport class ScreenshotManager {\n  private outputDir: string;\n  private config: ScreenshotConfig;\n\n  constructor(outputDir: string, config: Partial<ScreenshotConfig> = {}) {\n    this.outputDir = outputDir;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Capture a screenshot from a Playwright page\n   */\n  async capture(\n    page: Page,\n    name: string,\n    options: {\n      sessionId?: string;\n      fullPage?: boolean;\n      selector?: string;\n    } = {}\n  ): Promise<string> {\n    const { sessionId, fullPage = false, selector } = options;\n\n    // Determine output path\n    let outputPath: string;\n    if (sessionId) {\n      const sessionDir = join(this.outputDir, 'sessions', sessionId);\n      await mkdir(sessionDir, { recursive: true });\n      outputPath = join(sessionDir, `${name}.png`);\n    } else {\n      await mkdir(this.outputDir, { recursive: true });\n      outputPath = join(this.outputDir, `${name}.png`);\n    }\n\n    // Disable animations\n    await page.addStyleTag({\n      content: `\n        *, *::before, *::after {\n          animation-duration: 0s !important;\n          animation-delay: 0s !important;\n          transition-duration: 0s !important;\n          transition-delay: 0s !important;\n        }\n      `,\n    });\n\n    // Capture screenshot\n    if (selector) {\n      const element = await page.$(selector);\n      if (!element) {\n        throw new Error(`Element not found: ${selector}`);\n      }\n      await element.screenshot({ path: outputPath, type: 'png' });\n    } else {\n      await page.screenshot({\n        path: outputPath,\n        fullPage,\n        type: 'png',\n      });\n    }\n\n    return outputPath;\n  }\n\n  /**\n   * List all screenshots for a session\n   */\n  async list(sessionId: string): Promise<ScreenshotInfo[]> {\n    const sessionDir = join(this.outputDir, 'sessions', sessionId);\n    if (!existsSync(sessionDir)) {\n      return [];\n    }\n\n    const screenshots: ScreenshotInfo[] = [];\n    await this.scanDirectory(sessionDir, sessionId, screenshots);\n\n    // Sort by creation time, newest first\n    screenshots.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n    return screenshots;\n  }\n\n  /**\n   * List all screenshots across all sessions\n   */\n  async listAll(): Promise<ScreenshotInfo[]> {\n    const sessionsDir = join(this.outputDir, 'sessions');\n    if (!existsSync(sessionsDir)) {\n      return [];\n    }\n\n    const screenshots: ScreenshotInfo[] = [];\n    const sessions = await readdir(sessionsDir);\n\n    for (const sessionId of sessions) {\n      const sessionDir = join(sessionsDir, sessionId);\n      const stats = await stat(sessionDir);\n      if (stats.isDirectory()) {\n        await this.scanDirectory(sessionDir, sessionId, screenshots);\n      }\n    }\n\n    // Sort by creation time, newest first\n    screenshots.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n    return screenshots;\n  }\n\n  /**\n   * Scan a directory for PNG files\n   */\n  private async scanDirectory(\n    dir: string,\n    sessionId: string,\n    results: ScreenshotInfo[]\n  ): Promise<void> {\n    const entries = await readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Recurse into subdirectories (e.g., search-xxx directories)\n        await this.scanDirectory(fullPath, sessionId, results);\n      } else if (entry.name.endsWith('.png')) {\n        const stats = await stat(fullPath);\n        const now = Date.now();\n\n        // Parse step name from filename (e.g., \"01-before.png\" -> \"before\")\n        const stepMatch = entry.name.match(/^\\d+-(.+)\\.png$/);\n        const step = stepMatch ? stepMatch[1] : undefined;\n\n        results.push({\n          path: fullPath,\n          name: entry.name,\n          size: stats.size,\n          createdAt: stats.birthtime,\n          ageMs: now - stats.birthtime.getTime(),\n          sessionId,\n          step,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get metadata for a specific screenshot\n   */\n  async getMetadata(path: string): Promise<ScreenshotMetadata | null> {\n    if (!existsSync(path)) {\n      return null;\n    }\n\n    const stats = await stat(path);\n    const name = basename(path);\n    const dir = dirname(path);\n\n    // Try to parse step from filename\n    const stepMatch = name.match(/^\\d+-(.+)\\.png$/);\n    const step = stepMatch ? stepMatch[1] : undefined;\n\n    // Try to get session ID from path\n    const sessionMatch = dir.match(/sessions[/\\\\]([^/\\\\]+)/);\n    const sessionId = sessionMatch ? sessionMatch[1] : undefined;\n\n    // Try to load associated results.json for query/intent\n    let query: string | undefined;\n    let userIntent: string | undefined;\n\n    const resultsPath = join(dir, 'results.json');\n    if (existsSync(resultsPath)) {\n      try {\n        const resultsContent = await readFile(resultsPath, 'utf-8');\n        const results = JSON.parse(resultsContent);\n        query = results.query;\n        userIntent = results.userIntent;\n      } catch {\n        // Ignore parse errors\n      }\n    }\n\n    return {\n      path,\n      name,\n      size: stats.size,\n      createdAt: stats.birthtime.toISOString(),\n      sessionId,\n      step,\n      query,\n      userIntent,\n    };\n  }\n\n  /**\n   * Cleanup old screenshots based on retention policy\n   */\n  async cleanup(options: { dryRun?: boolean } = {}): Promise<CleanupReport> {\n    const { dryRun = false } = options;\n    const report: CleanupReport = {\n      scanned: 0,\n      deleted: 0,\n      bytesFreed: 0,\n      kept: 0,\n      errors: [],\n      dryRun,\n    };\n\n    // Get all screenshots\n    const screenshots = await this.listAll();\n    report.scanned = screenshots.length;\n\n    if (screenshots.length === 0) {\n      return report;\n    }\n\n    const toDelete: ScreenshotInfo[] = [];\n    const maxAgeMs = this.config.maxAgeDays * 24 * 60 * 60 * 1000;\n\n    // Determine which files to delete based on policy\n    if (this.config.retentionPolicy === 'age' || this.config.retentionPolicy === 'both') {\n      // Delete files older than maxAge\n      for (const shot of screenshots) {\n        if (shot.ageMs > maxAgeMs && !toDelete.includes(shot)) {\n          toDelete.push(shot);\n        }\n      }\n    }\n\n    if (this.config.retentionPolicy === 'size' || this.config.retentionPolicy === 'both') {\n      // Calculate total size\n      let totalSize = screenshots.reduce((sum, s) => sum + s.size, 0);\n\n      // Delete oldest files until under limit\n      // Sort by age (oldest first) for deletion\n      const sortedByAge = [...screenshots].sort((a, b) => b.ageMs - a.ageMs);\n\n      for (const shot of sortedByAge) {\n        if (totalSize <= this.config.maxSizeBytes) break;\n        if (!toDelete.includes(shot)) {\n          toDelete.push(shot);\n          totalSize -= shot.size;\n        }\n      }\n    }\n\n    // Delete files\n    for (const shot of toDelete) {\n      try {\n        if (!dryRun) {\n          await unlink(shot.path);\n        }\n        report.deleted++;\n        report.bytesFreed += shot.size;\n      } catch (error) {\n        report.errors.push(`Failed to delete ${shot.path}: ${error}`);\n      }\n    }\n\n    report.kept = report.scanned - report.deleted;\n    return report;\n  }\n\n  /**\n   * Get total storage used by screenshots\n   */\n  async getStorageUsage(): Promise<{\n    totalBytes: number;\n    fileCount: number;\n    oldestFile?: Date;\n    newestFile?: Date;\n  }> {\n    const screenshots = await this.listAll();\n\n    if (screenshots.length === 0) {\n      return { totalBytes: 0, fileCount: 0 };\n    }\n\n    const totalBytes = screenshots.reduce((sum, s) => sum + s.size, 0);\n    const sorted = [...screenshots].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n    return {\n      totalBytes,\n      fileCount: screenshots.length,\n      oldestFile: sorted[0].createdAt,\n      newestFile: sorted[sorted.length - 1].createdAt,\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<ScreenshotConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  /**\n   * Save configuration to file\n   */\n  async saveConfig(): Promise<void> {\n    const configPath = join(this.outputDir, 'screenshot-config.json');\n    await writeFile(configPath, JSON.stringify(this.config, null, 2));\n  }\n\n  /**\n   * Load configuration from file\n   */\n  async loadConfig(): Promise<void> {\n    const configPath = join(this.outputDir, 'screenshot-config.json');\n    if (existsSync(configPath)) {\n      try {\n        const content = await readFile(configPath, 'utf-8');\n        const loaded = JSON.parse(content);\n        this.config = { ...DEFAULT_CONFIG, ...loaded };\n      } catch {\n        // Use default config on error\n      }\n    }\n  }\n}\n\n/**\n * Format bytes to human-readable string\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n}\n\n/**\n * Format duration to human-readable string\n */\nexport function formatAge(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (days > 0) return `${days}d ago`;\n  if (hours > 0) return `${hours}h ago`;\n  if (minutes > 0) return `${minutes}m ago`;\n  return `${seconds}s ago`;\n}\n","import { Command } from 'commander';\nimport { readFile } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\nimport {\n  InterfaceBuiltRight,\n  formatReportText,\n  formatReportJson,\n  formatReportMinimal,\n  formatSessionSummary,\n  VIEWPORTS,\n  type Config,\n} from '../index.js';\nimport {\n  registerOperation,\n  completeOperation,\n  getPendingOperations,\n  waitForCompletion,\n  formatPendingOperations,\n  type OperationType,\n} from '../operation-tracker.js';\n\nconst program = new Command();\n\n// Load config from .ibrrc.json if it exists\nasync function loadConfig(): Promise<Partial<Config>> {\n  const configPath = join(process.cwd(), '.ibrrc.json');\n  if (existsSync(configPath)) {\n    try {\n      const content = await readFile(configPath, 'utf-8');\n      return JSON.parse(content);\n    } catch {\n      // Ignore config errors\n    }\n  }\n  return {};\n}\n\n// Default IBR UI port\nconst IBR_DEFAULT_PORT = 4200;\n\n// Check if a port is available\nasync function isPortAvailable(port: number): Promise<boolean> {\n  return new Promise((resolve) => {\n    import('net').then(({ createServer }) => {\n      const server = createServer();\n      server.once('error', () => resolve(false));\n      server.once('listening', () => {\n        server.close();\n        resolve(true);\n      });\n      server.listen(port, '127.0.0.1');\n    });\n  });\n}\n\n// Find an available port starting from the given port\nasync function findAvailablePort(startPort: number, maxAttempts = 10): Promise<number> {\n  for (let i = 0; i < maxAttempts; i++) {\n    const port = startPort + i;\n    if (await isPortAvailable(port)) {\n      return port;\n    }\n  }\n  throw new Error(`No available ports found in range ${startPort}-${startPort + maxAttempts - 1}`);\n}\n\n// Create IBR instance with config\nasync function createIBR(options: Record<string, unknown> = {}): Promise<InterfaceBuiltRight> {\n  const config = await loadConfig();\n\n  // Merge CLI options with config\n  const merged: Partial<Config> = {\n    ...config,\n    ...(options.baseUrl ? { baseUrl: String(options.baseUrl) } : {}),\n    ...(options.output ? { outputDir: String(options.output) } : {}),\n    ...(options.viewport ? { viewport: VIEWPORTS[options.viewport as keyof typeof VIEWPORTS] } : {}),\n    ...(options.threshold ? { threshold: Number(options.threshold) } : {}),\n    ...(options.fullPage !== undefined ? { fullPage: Boolean(options.fullPage) } : {}),\n  };\n\n  return new InterfaceBuiltRight(merged);\n}\n\nprogram\n  .name('ibr')\n  .description('Visual regression testing for Claude Code')\n  .version('0.4.1');\n\n// Global options\nprogram\n  .option('-b, --base-url <url>', 'Base URL for the application')\n  .option('-o, --output <dir>', 'Output directory', './.ibr')\n  .option('-v, --viewport <name>', 'Viewport: desktop, mobile, tablet', 'desktop')\n  .option('-t, --threshold <percent>', 'Diff threshold percentage', '1.0');\n\n// Start command\nprogram\n  .command('start [url]')\n  .description('Capture a baseline screenshot (auto-detects dev server if no URL)')\n  .option('-n, --name <name>', 'Session name')\n  .option('-s, --selector <css>', 'CSS selector to capture specific element')\n  .option('-w, --wait-for <selector>', 'Wait for selector before screenshot')\n  .option('--no-full-page', 'Capture only the viewport, not full page')\n  .option('--sandbox', 'Show visible browser window (default: headless)')\n  .option('--debug', 'Visible browser + slow motion + devtools')\n  .action(async (url: string | undefined, options: { name?: string; fullPage?: boolean; selector?: string; waitFor?: string; sandbox?: boolean; debug?: boolean }) => {\n    try {\n      const resolvedUrl = await resolveBaseUrl(url);\n      const ibr = await createIBR(program.opts());\n      const result = await ibr.startSession(resolvedUrl, {\n        name: options.name,\n        fullPage: options.fullPage,\n        selector: options.selector,\n        waitFor: options.waitFor,\n      });\n\n      console.log(`Session started: ${result.sessionId}`);\n      console.log(`Baseline: ${result.baseline}`);\n      console.log(`URL: ${result.session.url}`);\n      console.log('');\n      console.log('Next: Make your changes, then run:');\n      console.log(`  npx ibr check ${result.sessionId}`);\n\n      await ibr.close();\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Auto command - zero-config workflow\nprogram\n  .command('auto')\n  .description('Zero-config: detect server, scan pages, open viewer')\n  .option('-n, --max-pages <count>', 'Maximum pages to scan', '5')\n  .option('--nav-only', 'Only scan navigation links (faster)')\n  .option('--no-open', 'Do not open browser automatically')\n  .action(async (options: { maxPages: string; navOnly?: boolean; open?: boolean }) => {\n    try {\n      // 1. Detect dev server\n      const baseUrl = await detectDevServer();\n      if (!baseUrl) {\n        console.log('No dev server detected.');\n        console.log('');\n        console.log('Start your dev server, then run:');\n        console.log('  npx ibr auto');\n        console.log('');\n        console.log('Or specify a URL:');\n        console.log('  npx ibr scan-start http://localhost:3000');\n        return;\n      }\n\n      console.log(`Detected: ${baseUrl}`);\n      console.log('');\n\n      // 2. Discover and capture pages\n      const { discoverPages, getNavigationLinks } = await import('../crawl.js');\n      const ibr = await createIBR(program.opts());\n\n      let pages;\n      if (options.navOnly) {\n        pages = await getNavigationLinks(baseUrl);\n        console.log(`Found ${pages.length} navigation links.`);\n      } else {\n        const result = await discoverPages({\n          url: baseUrl,\n          maxPages: parseInt(options.maxPages, 10),\n        });\n        pages = result.pages;\n        console.log(`Discovered ${pages.length} pages.`);\n      }\n\n      if (pages.length === 0) {\n        console.log('No pages found to capture.');\n        await ibr.close();\n        return;\n      }\n\n      console.log('Capturing baselines...');\n      console.log('');\n\n      let captured = 0;\n      for (const page of pages) {\n        try {\n          const result = await ibr.startSession(page.url, {\n            name: page.title.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase().slice(0, 50),\n          });\n          captured++;\n          console.log(`  ${page.path} -> ${result.sessionId}`);\n        } catch {\n          console.log(`  ${page.path} -> failed`);\n        }\n      }\n\n      await ibr.close();\n\n      console.log('');\n      console.log(`Captured ${captured}/${pages.length} pages.`);\n      console.log('');\n      console.log('Next steps:');\n      console.log('  1. Make your UI changes');\n      console.log('  2. Run: npx ibr scan-check');\n      console.log('  3. View: npx ibr serve');\n\n      // 3. Optionally open viewer\n      if (options.open !== false && captured > 0) {\n        console.log('');\n        console.log('Opening viewer...');\n        const { spawn } = await import('child_process');\n        spawn('npx', ['ibr', 'serve'], {\n          stdio: 'inherit',\n          shell: true,\n          detached: true,\n        }).unref();\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Check command\nprogram\n  .command('check [sessionId]')\n  .description('Compare current state against baseline')\n  .option('-f, --format <format>', 'Output format: json, text, minimal', 'text')\n  .action(async (sessionId: string | undefined, options: { format: string }) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const report = await ibr.check(sessionId);\n\n      switch (options.format) {\n        case 'json':\n          console.log(formatReportJson(report));\n          break;\n        case 'minimal':\n          console.log(formatReportMinimal(report));\n          break;\n        default:\n          console.log(formatReportText(report));\n      }\n\n      // Contextual tips based on verdict\n      if (options.format === 'text') {\n        console.log('');\n        if (report.analysis.verdict === 'MATCH') {\n          console.log('All good! To capture more pages: npx ibr scan');\n        } else if (report.analysis.verdict === 'EXPECTED_CHANGE') {\n          console.log('To accept as new baseline: npx ibr update');\n        } else if (report.analysis.verdict === 'UNEXPECTED_CHANGE' || report.analysis.verdict === 'LAYOUT_BROKEN') {\n          console.log('View diff in browser: npx ibr serve');\n        }\n      }\n\n      await ibr.close();\n\n      // Exit with error code if not matching and not expected\n      if (!report.comparison.match &&\n          (report.analysis.verdict === 'UNEXPECTED_CHANGE' ||\n           report.analysis.verdict === 'LAYOUT_BROKEN')) {\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Audit command - context-aware UI audit with visual and semantic checks\nprogram\n  .command('audit [url]')\n  .description('Full audit: functional checks + visual comparison + semantic verification')\n  .option('-r, --rules <preset>', 'Override with preset (minimal). Auto-detects from CLAUDE.md by default')\n  .option('--show-framework', 'Display detected design framework')\n  .option('--check-apis [dir]', 'Cross-reference UI API calls against backend routes')\n  .option('--visual', 'Include visual comparison against most recent baseline')\n  .option('--baseline <session>', 'Compare against specific baseline session')\n  .option('--semantic', 'Include semantic verification (expected elements, page intent)')\n  .option('--full', 'Run all checks: functional + visual + semantic (default)')\n  .option('--json', 'Output as JSON')\n  .option('--fail-on <level>', 'Exit non-zero on errors/warnings', 'error')\n  .action(async (url: string | undefined, options: { rules?: string; showFramework?: boolean; checkApis?: string | boolean; visual?: boolean; baseline?: string; semantic?: boolean; full?: boolean; json?: boolean; failOn: string }) => {\n    try {\n      const resolvedUrl = await resolveBaseUrl(url);\n      const globalOpts = program.opts();\n\n      // Import modules\n      const { loadRulesConfig, runRules, createAuditResult, formatAuditResult, registerPreset } = await import('../rules/engine.js');\n      const { register } = await import('../rules/presets/minimal.js');\n      const { extractInteractiveElements } = await import('../extract.js');\n      const { chromium } = await import('playwright');\n      const { discoverUserContext, formatContextSummary } = await import('../context-loader.js');\n      const { generateRulesFromFramework, createPresetFromFramework } = await import('../rules/dynamic-rules.js');\n\n      // Register built-in presets\n      register();\n\n      // Discover user context (design framework from CLAUDE.md)\n      const userContext = await discoverUserContext(process.cwd());\n\n      // Show framework info if requested\n      if (options.showFramework) {\n        console.log(formatContextSummary(userContext));\n        console.log('');\n        if (!url) return; // Exit if just showing framework\n      }\n\n      // Load rules config\n      const rulesConfig = await loadRulesConfig(process.cwd());\n\n      // Priority: CLI flag > config file > detected framework > minimal\n      if (options.rules) {\n        // CLI flag overrides everything\n        rulesConfig.extends = [options.rules];\n        console.log(`Using preset: ${options.rules}`);\n      } else if (rulesConfig.extends && rulesConfig.extends.length > 0) {\n        // Config file has explicit rules\n        console.log(`Using configured presets: ${rulesConfig.extends.join(', ')}`);\n      } else if (userContext.framework) {\n        // Auto-detect from CLAUDE.md\n        const preset = createPresetFromFramework(userContext.framework);\n        registerPreset(preset);\n        rulesConfig.extends = [preset.name];\n        console.log(`Detected: ${userContext.framework.name}`);\n        console.log(`Source: ${userContext.framework.source}`);\n        console.log(`Generated ${preset.rules.length} rules from ${userContext.framework.principles.length} principles`);\n      } else {\n        // No framework detected - show guidance\n        console.log('No design framework detected in CLAUDE.md.');\n        console.log('Running basic interactivity checks only.');\n        console.log('');\n        console.log('To enable design validation:');\n        console.log('  Add your framework to ~/.claude/CLAUDE.md or .claude/CLAUDE.md');\n        console.log('  Or use --rules minimal for basic checks');\n        rulesConfig.extends = ['minimal'];\n      }\n\n      console.log('');\n      console.log(`Auditing ${resolvedUrl}...`);\n      console.log('');\n\n      // Launch browser for audit\n      const browser = await chromium.launch({ headless: true });\n      const viewport = VIEWPORTS[globalOpts.viewport as keyof typeof VIEWPORTS] || VIEWPORTS.desktop;\n\n      const context = await browser.newContext({\n        viewport: { width: viewport.width, height: viewport.height },\n        reducedMotion: 'reduce',\n      });\n\n      const page = await context.newPage();\n      await page.goto(resolvedUrl, { waitUntil: 'networkidle', timeout: 30000 });\n\n      // Wait for React/Vue/Angular hydration\n      await page.waitForTimeout(1000);\n\n      // Extract elements\n      const elements = await extractInteractiveElements(page);\n\n      // Run rules\n      const isMobile = viewport.width < 768;\n      const violations = runRules(elements, {\n        isMobile,\n        viewportWidth: viewport.width,\n        viewportHeight: viewport.height,\n        url: resolvedUrl,\n        allElements: elements,\n      }, rulesConfig);\n\n      // Create result\n      const result = createAuditResult(resolvedUrl, elements, violations);\n\n      // Determine which checks to run (default: all if --full or no specific flags)\n      const runVisual = options.full || options.visual || options.baseline || (!options.semantic && !options.checkApis);\n      const runSemantic = options.full || options.semantic || (!options.visual && !options.baseline && !options.checkApis);\n\n      // --- VISUAL COMPARISON ---\n      let visualResult: {\n        hasBaseline: boolean;\n        verdict?: string;\n        diffPercent?: number;\n        baselineSession?: string;\n        currentPath?: string;\n        diffPath?: string;\n      } | null = null;\n\n      if (runVisual) {\n        const { compareImages, analyzeComparison } = await import('../compare.js');\n        const { listSessions, getSessionPaths, getMostRecentSession } = await import('../session.js');\n        const { mkdir, access } = await import('fs/promises');\n        const { join } = await import('path');\n\n        // Find baseline for this URL\n        const outputDir = globalOpts.outputDir || '.ibr';\n        const sessions = await listSessions(outputDir);\n\n        // Find matching baseline (same URL path)\n        const urlPath = new URL(resolvedUrl).pathname;\n        let baselineSession = options.baseline\n          ? sessions.find(s => s.id === options.baseline)\n          : sessions\n              .filter(s => new URL(s.url).pathname === urlPath && s.status !== 'compared')\n              .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0];\n\n        if (baselineSession) {\n          const paths = getSessionPaths(outputDir, baselineSession.id);\n\n          // Capture current screenshot\n          const currentPath = paths.current;\n          await mkdir(join(outputDir, 'sessions', baselineSession.id), { recursive: true });\n          await page.screenshot({ path: currentPath, fullPage: true });\n\n          // Check if baseline exists\n          try {\n            await access(paths.baseline);\n\n            // Compare\n            const comparison = await compareImages({\n              baselinePath: paths.baseline,\n              currentPath: currentPath,\n              diffPath: paths.diff,\n              threshold: 0.01,\n            });\n\n            const analysis = analyzeComparison(comparison, 1.0);\n\n            visualResult = {\n              hasBaseline: true,\n              verdict: analysis.verdict,\n              diffPercent: comparison.diffPercent,\n              baselineSession: baselineSession.id,\n              currentPath,\n              diffPath: comparison.diffPercent > 0 ? paths.diff : undefined,\n            };\n          } catch {\n            visualResult = { hasBaseline: false };\n          }\n        } else {\n          visualResult = { hasBaseline: false };\n        }\n      }\n\n      // --- SEMANTIC VERIFICATION ---\n      let semanticResult: {\n        pageIntent: string;\n        confidence: number;\n        authenticated: boolean | null;\n        loading: boolean;\n        hasErrors: boolean;\n        ready: boolean;\n        expectedElements: Array<{ element: string; found: boolean }>;\n        issues: Array<{ type: string; problem: string }>;\n      } | null = null;\n\n      if (runSemantic) {\n        const { getSemanticOutput, detectLandmarks, compareLandmarks, getExpectedLandmarksForIntent, getExpectedLandmarksFromContext, LANDMARK_SELECTORS } = await import('../semantic/index.js');\n        const { listSessions } = await import('../session.js');\n        const { readFile } = await import('fs/promises');\n        const { join } = await import('path');\n\n        const semantic = await getSemanticOutput(page);\n\n        // --- HYBRID APPROACH: Baseline landmarks OR inferred from intent ---\n        const outputDir = globalOpts.outputDir || '.ibr';\n        const sessions = await listSessions(outputDir);\n        const urlPath = new URL(resolvedUrl).pathname;\n\n        // Find baseline session with landmark elements\n        const baselineSession = sessions\n          .filter(s => new URL(s.url).pathname === urlPath && s.landmarkElements && s.landmarkElements.length > 0)\n          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0];\n\n        let elementChecks: Array<{ element: string; found: boolean; source: 'baseline' | 'inferred' }> = [];\n\n        if (baselineSession && baselineSession.landmarkElements) {\n          // APPROACH 1: Compare against baseline landmarks\n          const currentLandmarks = await detectLandmarks(page);\n          const comparison = compareLandmarks(baselineSession.landmarkElements, currentLandmarks);\n\n          // Check which baseline elements are now missing\n          for (const landmark of baselineSession.landmarkElements) {\n            if (landmark.found) {\n              const stillExists = currentLandmarks.find(l => l.name === landmark.name && l.found);\n              elementChecks.push({\n                element: landmark.name.charAt(0).toUpperCase() + landmark.name.slice(1),\n                found: !!stillExists,\n                source: 'baseline',\n              });\n            }\n          }\n        } else {\n          // APPROACH 2: Infer expected elements from page intent + user context\n          const pageIntent = semantic.pageIntent.intent;\n          const intentLandmarks = getExpectedLandmarksForIntent(pageIntent as any);\n\n          // Try to load user context (CLAUDE.md design framework)\n          let contextLandmarks: string[] = [];\n          try {\n            const claudeMdPath = join(process.cwd(), 'CLAUDE.md');\n            const content = await readFile(claudeMdPath, 'utf-8');\n            // Simple parsing - look for principles or requirements\n            contextLandmarks = getExpectedLandmarksFromContext({ principles: [content] }) as any;\n          } catch {\n            // No CLAUDE.md, that's fine\n          }\n\n          // Combine intent + context landmarks (dedupe)\n          const expectedLandmarkTypes = [...new Set([...intentLandmarks, ...contextLandmarks])];\n\n          // Check each expected landmark on the current page\n          for (const landmarkType of expectedLandmarkTypes) {\n            const selector = LANDMARK_SELECTORS[landmarkType as keyof typeof LANDMARK_SELECTORS];\n            if (selector) {\n              const found = await page.$(selector);\n              elementChecks.push({\n                element: landmarkType.charAt(0).toUpperCase() + landmarkType.slice(1),\n                found: !!found,\n                source: 'inferred',\n              });\n            }\n          }\n        }\n\n        // Collect semantic issues\n        const semanticIssues: Array<{ type: string; problem: string }> = [];\n\n        // Missing expected elements\n        for (const check of elementChecks) {\n          if (!check.found) {\n            semanticIssues.push({\n              type: 'missing-element',\n              problem: `Expected ${check.element} not found (${check.source} from ${check.source === 'baseline' ? 'previous capture' : 'page intent'})`,\n            });\n          }\n        }\n\n        // Add issues from semantic analysis\n        for (const issue of semantic.issues) {\n          semanticIssues.push({\n            type: issue.type,\n            problem: issue.problem,\n          });\n        }\n\n        semanticResult = {\n          pageIntent: semantic.pageIntent.intent,\n          confidence: semantic.confidence,\n          authenticated: semantic.state.auth.authenticated,\n          loading: semantic.state.loading.loading,\n          hasErrors: semantic.state.errors.hasErrors,\n          ready: semantic.state.ready,\n          expectedElements: elementChecks.map(e => ({ element: e.element, found: e.found })),\n          issues: semanticIssues,\n        };\n      }\n\n      await context.close();\n      await browser.close();\n\n      // Run integration checks if requested\n      let integrationResult: { orphanCount: number; orphans: Array<{ endpoint: string; method: string; file: string; line?: number }> } | null = null;\n\n      if (options.checkApis) {\n        const { scanDirectoryForApiCalls, discoverApiRoutes, findOrphanEndpoints } = await import('../integration.js');\n\n        const projectDir = typeof options.checkApis === 'string' ? options.checkApis : process.cwd();\n\n        const [apiCalls, apiRoutes] = await Promise.all([\n          scanDirectoryForApiCalls(projectDir),\n          discoverApiRoutes(projectDir),\n        ]);\n\n        const orphans = findOrphanEndpoints(apiCalls, apiRoutes);\n\n        integrationResult = {\n          orphanCount: orphans.length,\n          orphans: orphans.map(o => ({\n            endpoint: o.call.endpoint,\n            method: o.call.method,\n            file: o.call.sourceFile,\n            line: o.call.lineNumber,\n          })),\n        };\n      }\n\n      // Output\n      if (options.json) {\n        console.log(JSON.stringify({\n          ...result,\n          visual: visualResult,\n          semantic: semanticResult,\n          integration: integrationResult,\n        }, null, 2));\n      } else {\n        console.log(formatAuditResult(result));\n\n        // Print visual results\n        if (visualResult) {\n          console.log('');\n          console.log('Visual Comparison:');\n          if (visualResult.hasBaseline) {\n            const verdictColor = visualResult.verdict === 'MATCH' ? '\\x1b[32m' : // green\n                                 visualResult.verdict === 'EXPECTED_CHANGE' ? '\\x1b[33m' : // yellow\n                                 '\\x1b[31m'; // red\n            console.log(`  Verdict: ${verdictColor}${visualResult.verdict}\\x1b[0m`);\n            console.log(`  Diff: ${visualResult.diffPercent?.toFixed(2)}%`);\n            console.log(`  Baseline: ${visualResult.baselineSession}`);\n            if (visualResult.diffPath) {\n              console.log(`  Diff image: ${visualResult.diffPath}`);\n            }\n          } else {\n            console.log('  No baseline found for this URL.');\n            console.log('  Run: npx ibr start <url> --name \"feature\" to capture baseline first.');\n          }\n        }\n\n        // Print semantic results\n        if (semanticResult) {\n          console.log('');\n          console.log('Semantic Verification:');\n          console.log(`  Page type: ${semanticResult.pageIntent} (${Math.round(semanticResult.confidence * 100)}% confidence)`);\n          console.log(`  Ready: ${semanticResult.ready ? 'Yes' : 'No'}`);\n\n          // Expected elements\n          const missing = semanticResult.expectedElements.filter(e => !e.found);\n          const found = semanticResult.expectedElements.filter(e => e.found);\n\n          if (missing.length > 0) {\n            console.log('');\n            console.log('  Missing expected elements:');\n            for (const el of missing) {\n              console.log(`    \\x1b[31m!\\x1b[0m ${el.element}`);\n            }\n          }\n\n          if (found.length > 0) {\n            console.log('');\n            console.log('  Found elements:');\n            for (const el of found) {\n              console.log(`    \\x1b[32m‚úì\\x1b[0m ${el.element}`);\n            }\n          }\n\n          // Semantic issues\n          if (semanticResult.issues.length > 0) {\n            console.log('');\n            console.log('  Semantic issues:');\n            for (const issue of semanticResult.issues) {\n              console.log(`    ! ${issue.problem}`);\n            }\n          }\n        }\n\n        // Print integration results if available\n        if (integrationResult && integrationResult.orphanCount > 0) {\n          console.log('');\n          console.log('Integration Issues:');\n          console.log(`  ${integrationResult.orphanCount} orphan API calls (UI calls backend that doesn't exist):`);\n          console.log('');\n\n          for (const orphan of integrationResult.orphans) {\n            console.log(`  ! ${orphan.method} ${orphan.endpoint}`);\n            console.log(`    Called from: ${orphan.file}${orphan.line ? `:${orphan.line}` : ''}`);\n          }\n        } else if (integrationResult) {\n          console.log('');\n          console.log('Integration: All API calls have matching backend routes.');\n        }\n      }\n\n      // Exit code based on --fail-on\n      const hasIntegrationErrors = integrationResult && integrationResult.orphanCount > 0;\n      const hasVisualRegression = visualResult?.hasBaseline &&\n        visualResult.verdict !== 'MATCH' &&\n        visualResult.verdict !== 'EXPECTED_CHANGE';\n      const hasSemanticIssues = semanticResult && semanticResult.issues.length > 0;\n      const hasMissingElements = semanticResult &&\n        semanticResult.expectedElements.some(e => !e.found);\n\n      if (options.failOn === 'error' && (\n        result.summary.errors > 0 ||\n        hasIntegrationErrors ||\n        hasVisualRegression ||\n        hasMissingElements\n      )) {\n        process.exit(1);\n      } else if (options.failOn === 'warning' && (\n        result.summary.errors > 0 ||\n        result.summary.warnings > 0 ||\n        hasIntegrationErrors ||\n        hasVisualRegression ||\n        hasSemanticIssues\n      )) {\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Status command - show pending baselines\nprogram\n  .command('status')\n  .description('Show sessions awaiting comparison (baselines without checks)')\n  .action(async () => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const sessions = await ibr.listSessions();\n\n      // Filter to baseline-only sessions (not yet compared)\n      const pending = sessions.filter(s => s.status === 'baseline');\n\n      if (pending.length === 0) {\n        console.log('No pending visual checks.');\n        console.log('');\n        console.log('To capture a baseline:');\n        console.log('  npx ibr start <url> --name \"feature-name\"');\n        return;\n      }\n\n      console.log('Pending visual checks:');\n      console.log('');\n\n      for (const session of pending) {\n        const age = Date.now() - new Date(session.createdAt).getTime();\n        const ageStr = age < 60000 ? 'just now' :\n                       age < 3600000 ? `${Math.floor(age / 60000)}m ago` :\n                       age < 86400000 ? `${Math.floor(age / 3600000)}h ago` :\n                       `${Math.floor(age / 86400000)}d ago`;\n\n        const urlPath = new URL(session.url).pathname;\n        console.log(`  ${session.id}  ${urlPath.padEnd(20)}  ${ageStr.padEnd(10)}  ${session.name || ''}`);\n      }\n\n      console.log('');\n      console.log('Run comparison:');\n      console.log('  npx ibr check              # checks most recent');\n      console.log('  npx ibr check <session-id> # checks specific session');\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// List command\nprogram\n  .command('list')\n  .description('List all sessions')\n  .option('-f, --format <format>', 'Output format: json, text', 'text')\n  .option('--by-app', 'Group sessions by app/branch (git context)')\n  .action(async (options: { format: string; byApp?: boolean }) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const sessions = await ibr.listSessions();\n\n      if (sessions.length === 0) {\n        console.log('No sessions found.');\n        return;\n      }\n\n      if (options.format === 'json') {\n        console.log(JSON.stringify(sessions, null, 2));\n      } else if (options.byApp) {\n        // Group by app context\n        const { getAppContext } = await import('../git-context.js');\n        const context = await getAppContext(process.cwd()).catch(() => null);\n        const currentApp = context?.appName || 'unknown';\n        const currentBranch = context?.branch || 'unknown';\n\n        // Group sessions by URL domain or infer from session paths\n        const groups: Map<string, typeof sessions> = new Map();\n\n        for (const session of sessions) {\n          let groupKey = 'Other';\n          try {\n            if (session.url) {\n              const url = new URL(session.url);\n              groupKey = url.hostname;\n            }\n          } catch {\n            groupKey = 'Other';\n          }\n\n          if (!groups.has(groupKey)) {\n            groups.set(groupKey, []);\n          }\n          groups.get(groupKey)!.push(session);\n        }\n\n        console.log(`Current App: ${currentApp} (${currentBranch})`);\n        console.log('');\n\n        for (const [groupName, groupSessions] of groups) {\n          console.log(`${groupName} (${groupSessions.length} sessions)`);\n          console.log('-'.repeat(50));\n          for (const session of groupSessions) {\n            console.log(`  ${formatSessionSummary(session)}`);\n          }\n          console.log('');\n        }\n      } else {\n        console.log('Sessions:');\n        console.log('');\n        console.log('ID              STATUS    VIEWPORT  DATE        NAME');\n        console.log('-'.repeat(70));\n        for (const session of sessions) {\n          console.log(formatSessionSummary(session));\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Update command\nprogram\n  .command('update [sessionId]')\n  .alias('approve')\n  .description('Update baseline with current screenshot (alias: approve)')\n  .action(async (sessionId: string | undefined) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const session = await ibr.updateBaseline(sessionId);\n\n      console.log(`Baseline updated for session: ${session.id}`);\n      console.log(`URL: ${session.url}`);\n\n      await ibr.close();\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Clean command\nprogram\n  .command('clean')\n  .description('Clean old sessions')\n  .option('--older-than <duration>', 'Delete sessions older than duration (e.g., 7d, 24h)')\n  .option('--keep-last <count>', 'Keep the last N sessions', '0')\n  .option('--dry-run', 'Show what would be deleted without deleting')\n  .action(async (options: { olderThan?: string; keepLast: string; dryRun?: boolean }) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const result = await ibr.clean({\n        olderThan: options.olderThan,\n        keepLast: parseInt(options.keepLast, 10),\n        dryRun: options.dryRun,\n      });\n\n      if (options.dryRun) {\n        console.log('Dry run - would delete:');\n      } else {\n        console.log('Cleaned:');\n      }\n\n      if (result.deleted.length === 0) {\n        console.log('  No sessions to delete.');\n      } else {\n        for (const id of result.deleted) {\n          console.log(`  - ${id}`);\n        }\n      }\n\n      console.log(`\\nKept: ${result.kept.length} sessions`);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Delete command\nprogram\n  .command('delete <sessionId>')\n  .description('Delete a specific session')\n  .action(async (sessionId: string) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const deleted = await ibr.deleteSession(sessionId);\n\n      if (deleted) {\n        console.log(`Deleted session: ${sessionId}`);\n      } else {\n        console.log(`Session not found: ${sessionId}`);\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Serve command (placeholder - will be implemented with web-ui)\nprogram\n  .command('serve')\n  .description('Start the comparison viewer web UI')\n  .option('-p, --port <port>', `Port number (default: ${IBR_DEFAULT_PORT}, auto-scans for available)`)\n  .option('--no-open', 'Do not open browser automatically')\n  .action(async (options: { port?: string; open?: boolean }) => {\n    const { spawn } = await import('child_process');\n    const { resolve } = await import('path');\n\n    // Find web-ui directory relative to package root\n    // In CJS build, use process.cwd() or resolve from known location\n    const packageRoot = resolve(process.cwd());\n    let webUiDir = join(packageRoot, 'web-ui');\n\n    // If not found in cwd, try relative to node_modules install\n    if (!existsSync(webUiDir)) {\n      // Try finding it relative to this package when installed as dependency\n      const possiblePaths = [\n        join(packageRoot, 'node_modules', 'interface-built-right', 'web-ui'),\n        join(packageRoot, '..', 'interface-built-right', 'web-ui'),\n      ];\n      for (const p of possiblePaths) {\n        if (existsSync(p)) {\n          webUiDir = p;\n          break;\n        }\n      }\n    }\n\n    // Check if web-ui exists\n    if (!existsSync(webUiDir)) {\n      console.log('Web UI not found. Please ensure web-ui directory exists.');\n      console.log('');\n      console.log('For now, you can view the comparison images directly:');\n\n      try {\n        const ibr = await createIBR(program.opts());\n        const session = await ibr.getMostRecentSession();\n\n        if (session) {\n          const config = ibr.getConfig();\n          console.log(`  Baseline: ${config.outputDir}/sessions/${session.id}/baseline.png`);\n          console.log(`  Current:  ${config.outputDir}/sessions/${session.id}/current.png`);\n          console.log(`  Diff:     ${config.outputDir}/sessions/${session.id}/diff.png`);\n        }\n      } catch {\n        // Ignore errors\n      }\n      return;\n    }\n\n    // Determine port: use specified, or find available starting from default\n    let port: number;\n    if (options.port) {\n      port = parseInt(options.port, 10);\n      // Check if specified port is available\n      if (!(await isPortAvailable(port))) {\n        console.log(`Port ${port} is already in use.`);\n        try {\n          port = await findAvailablePort(port + 1);\n          console.log(`Using next available port: ${port}`);\n        } catch (e) {\n          console.error(e instanceof Error ? e.message : 'Failed to find available port');\n          process.exit(1);\n        }\n      }\n    } else {\n      // Auto-find available port starting from default\n      try {\n        port = await findAvailablePort(IBR_DEFAULT_PORT);\n        if (port !== IBR_DEFAULT_PORT) {\n          console.log(`Default port ${IBR_DEFAULT_PORT} in use, using port ${port}`);\n        }\n      } catch (e) {\n        console.error(e instanceof Error ? e.message : 'Failed to find available port');\n        process.exit(1);\n      }\n    }\n\n    console.log(`Starting web UI on http://localhost:${port}`);\n    console.log('Press Ctrl+C to stop the server.');\n    console.log('');\n\n    // Start Next.js dev server\n    const server = spawn('npm', ['run', 'dev', '--', '-p', String(port)], {\n      cwd: webUiDir,\n      stdio: 'inherit',\n      shell: true,\n    });\n\n    // Open browser after a short delay (if --no-open not specified)\n    if (options.open !== false) {\n      setTimeout(async () => {\n        const open = (await import('child_process')).exec;\n        const url = `http://localhost:${port}`;\n        // Cross-platform open command\n        const cmd = process.platform === 'darwin' ? 'open' :\n                    process.platform === 'win32' ? 'start' : 'xdg-open';\n        open(`${cmd} ${url}`);\n      }, 3000);\n    }\n\n    // Handle server exit\n    server.on('close', (code) => {\n      if (code !== 0) {\n        console.log(`Web UI server exited with code ${code}`);\n      }\n    });\n  });\n\n// Login command - save auth state for authenticated captures\nprogram\n  .command('login <url>')\n  .description('Open browser for manual login, then save auth state for future captures')\n  .option('--timeout <ms>', 'Timeout in milliseconds (default: 5 minutes)', '300000')\n  .action(async (url: string, options: { timeout: string }) => {\n    try {\n      const { performLogin } = await import('../auth.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      await performLogin({\n        url,\n        outputDir,\n        timeout: parseInt(options.timeout, 10),\n      });\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Logout command - clear saved auth state\nprogram\n  .command('logout')\n  .description('Clear saved authentication state')\n  .action(async () => {\n    try {\n      const { clearAuthState } = await import('../auth.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      await clearAuthState(outputDir);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// ============================================================\n// LIVE SESSION COMMANDS - Interactive browser sessions\n// ============================================================\n// Uses Browser Server mode for persistent sessions across CLI invocations.\n// The first session:start launches a headless browser server that persists\n// until session:close all is called.\n\n// Session start command - create interactive session with persistent browser\nprogram\n  .command('session:start [url]')\n  .description('Start an interactive browser session (browser persists across commands)')\n  .option('-n, --name <name>', 'Session name')\n  .option('-w, --wait-for <selector>', 'Wait for selector before considering page ready')\n  .option('--sandbox', 'Show visible browser window (default: headless)')\n  .option('--debug', 'Visible browser + slow motion + devtools')\n  .option('--low-memory', 'Reduce memory usage for lower-powered machines (4GB RAM)')\n  .action(async (url: string | undefined, options: { name?: string; waitFor?: string; sandbox?: boolean; debug?: boolean; lowMemory?: boolean }) => {\n    try {\n      const {\n        startBrowserServer,\n        isServerRunning,\n        PersistentSession,\n      } = await import('../browser-server.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const resolvedUrl = await resolveBaseUrl(url);\n      const headless = !options.sandbox && !options.debug;\n\n      // Check if browser server is already running\n      const serverRunning = await isServerRunning(outputDir);\n\n      if (!serverRunning) {\n        // First session - launch browser server and keep process alive\n        const modeLabel = options.lowMemory ? ' (low-memory mode)' : '';\n        console.log(headless ? `Starting headless browser server${modeLabel}...` : `Starting visible browser server${modeLabel}...`);\n\n        const { server } = await startBrowserServer(outputDir, {\n          headless,\n          debug: options.debug,\n          isolated: true,  // Prevents conflicts with Playwright MCP\n          lowMemory: options.lowMemory,\n        });\n\n        // Create the session\n        const session = await PersistentSession.create(outputDir, {\n          url: resolvedUrl,\n          name: options.name,\n          waitFor: options.waitFor,\n          viewport: VIEWPORTS[globalOpts.viewport as keyof typeof VIEWPORTS] || VIEWPORTS.desktop,\n        });\n\n        console.log('');\n        console.log(`Session started: ${session.id}`);\n        console.log(`URL: ${session.url}`);\n        console.log('');\n        console.log('Available commands (run in another terminal):');\n        console.log(`  npx ibr session:click ${session.id} \"<selector>\"`);\n        console.log(`  npx ibr session:type ${session.id} \"<selector>\" \"<text>\"`);\n        console.log(`  npx ibr session:screenshot ${session.id}`);\n        console.log(`  npx ibr session:wait ${session.id} \"<selector>\"`);\n        console.log('');\n        console.log('To close: npx ibr session:close all');\n        console.log('');\n        console.log('Browser server running. Press Ctrl+C to stop.');\n\n        // Keep process alive until SIGINT\n        await new Promise<void>((resolve) => {\n          const cleanup = async () => {\n            console.log('\\nShutting down browser server...');\n            server.close();\n            resolve();\n          };\n          process.on('SIGINT', cleanup);\n          process.on('SIGTERM', cleanup);\n        });\n      } else {\n        // Browser server already running - just create new session\n        console.log('Connecting to existing browser server...');\n\n        const session = await PersistentSession.create(outputDir, {\n          url: resolvedUrl,\n          name: options.name,\n          waitFor: options.waitFor,\n          viewport: VIEWPORTS[globalOpts.viewport as keyof typeof VIEWPORTS] || VIEWPORTS.desktop,\n        });\n\n        console.log('');\n        console.log(`Session started: ${session.id}`);\n        console.log(`URL: ${session.url}`);\n        console.log('');\n        console.log('Use session commands to interact:');\n        console.log(`  npx ibr session:type ${session.id} \"<selector>\" \"<text>\"`);\n        console.log(`  npx ibr session:click ${session.id} \"<selector>\"`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Helper for session commands that need to connect\nasync function getSession(outputDir: string, sessionId: string) {\n  const { PersistentSession, isServerRunning } = await import('../browser-server.js');\n\n  if (!(await isServerRunning(outputDir))) {\n    console.error('No browser server running.');\n    console.log('');\n    console.log('Start one with:');\n    console.log('  npx ibr session:start <url>');\n    console.log('');\n    console.log('The first session:start launches the server and keeps it alive.');\n    console.log('Run session commands in a separate terminal.');\n    process.exit(1);\n  }\n\n  const session = await PersistentSession.get(outputDir, sessionId);\n  if (!session) {\n    console.error(`Session not found: ${sessionId}`);\n    console.log('');\n    console.log('This can happen if:');\n    console.log('  1. The session ID is incorrect');\n    console.log('  2. The session was created with a different browser server');\n    console.log('');\n    console.log('List sessions with: npx ibr session:list');\n    process.exit(1);\n  }\n\n  return session;\n}\n\n// Session click command\nprogram\n  .command('session:click <sessionId> <selector>')\n  .description('Click an element in an active session (auto-targets visible elements)')\n  .option('--force', 'Force click, bypassing overlay interception checks')\n  .action(async (sessionId: string, selector: string, options: { force?: boolean }) => {\n    const globalOpts = program.opts();\n    const outputDir = globalOpts.output || './.ibr';\n    const opId = await registerOperation(outputDir, {\n      type: 'click',\n      sessionId,\n      command: `session:click ${sessionId} \"${selector}\"${options.force ? ' --force' : ''}`,\n    });\n\n    try {\n      const session = await getSession(outputDir, sessionId);\n\n      await session.click(selector, { force: options.force });\n      console.log(`Clicked: ${selector}${options.force ? ' (forced)' : ''}`);\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      console.error('Error:', msg);\n      console.log('');\n      if (msg.includes('intercept') || msg.includes('pointer-events')) {\n        console.log('Tip: Element is blocked by an overlay (modal, backdrop, etc.)');\n        console.log('     Use --force to click through, or dismiss the overlay first');\n        console.log('     npx ibr session:click ' + sessionId + ' \"' + selector + '\" --force');\n      } else if (msg.includes('not visible') || msg.includes('Timeout')) {\n        console.log('Tip: IBR auto-filters to visible elements. Element may be:');\n        console.log('     - Hidden by CSS (display:none, visibility:hidden)');\n        console.log('     - Off-screen or zero-sized');\n        console.log('     Use session:html --selector \"' + selector + '\" to inspect');\n      } else {\n        console.log('Tip: Session is still active. Use session:html to inspect the DOM.');\n      }\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  });\n\n// Session type command\nprogram\n  .command('session:type <sessionId> <selector> <text>')\n  .description('Type text into an element in an active session')\n  .option('--delay <ms>', 'Delay between keystrokes', '0')\n  .option('--submit', 'Press Enter after typing (waits for network idle)')\n  .option('--wait-after <ms>', 'Wait this long after typing/submitting before next command')\n  .option('--append', 'Append to existing content without clearing')\n  .action(async (sessionId: string, selector: string, text: string, options: { delay: string; submit?: boolean; waitAfter?: string; append?: boolean }) => {\n    const globalOpts = program.opts();\n    const outputDir = globalOpts.output || './.ibr';\n    const opId = await registerOperation(outputDir, {\n      type: 'type',\n      sessionId,\n      command: `session:type ${sessionId} \"${selector}\" \"${text.slice(0, 20)}...\"`,\n    });\n\n    try {\n      const session = await getSession(outputDir, sessionId);\n\n      await session.type(selector, text, {\n        delay: parseInt(options.delay, 10),\n        submit: options.submit,\n        waitAfter: options.waitAfter ? parseInt(options.waitAfter, 10) : undefined,\n        append: options.append,\n      });\n\n      const action = options.append ? 'Appended' : (options.submit ? 'Typed and submitted' : 'Typed');\n      console.log(`${action}: \"${text.length > 20 ? text.slice(0, 20) + '...' : text}\" into: ${selector}`);\n      if (options.submit) {\n        console.log('Waited for network idle after submit');\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      console.error('Error:', msg);\n      console.log('');\n      // Smart error suggestions\n      if (msg.includes('not visible') || msg.includes('multiple elements')) {\n        console.log('Tip: IBR auto-filters to visible elements. If still failing:');\n        console.log('     - Use session:html to inspect the DOM');\n        console.log('     - Try a more specific selector (add class, id, or attribute)');\n      } else {\n        console.log('Tip: Session is still active. Use session:html to inspect the page.');\n      }\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  });\n\n// Session press command - keyboard key press\nprogram\n  .command('session:press <sessionId> <key>')\n  .description('Press a keyboard key (Enter, Tab, Escape, ArrowDown, etc.)')\n  .action(async (sessionId: string, key: string) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      await session.press(key);\n      console.log(`Pressed: ${key}`);\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      console.error('Error:', msg);\n      console.log('');\n      console.log('Tip: Valid keys include: Enter, Tab, Escape, ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Backspace, Delete, Space');\n    }\n  });\n\n// Session scroll command\nprogram\n  .command('session:scroll <sessionId> <direction> [amount]')\n  .description('Scroll the page or a container (direction: up, down, left, right)')\n  .option('-s, --selector <css>', 'Scroll within a specific container (modal, sidebar, etc.)')\n  .action(async (sessionId: string, direction: string, amount?: string, options?: { selector?: string }) => {\n    const validDirections = ['up', 'down', 'left', 'right'];\n    if (!validDirections.includes(direction)) {\n      console.error(`Error: Invalid direction \"${direction}\"`);\n      console.log(`Valid directions: ${validDirections.join(', ')}`);\n      process.exit(1);\n    }\n\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      const pixels = amount ? parseInt(amount, 10) : 500;\n      const position = await session.scroll(direction as 'up' | 'down' | 'left' | 'right', pixels, { selector: options?.selector });\n\n      if (options?.selector) {\n        console.log(`Scrolled ${direction} ${pixels}px in: ${options.selector}`);\n      } else {\n        console.log(`Scrolled ${direction} ${pixels}px`);\n      }\n      console.log(`Position: x=${position.x}, y=${position.y}`);\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      console.error('Error:', msg);\n      if (options?.selector) {\n        console.log('');\n        console.log('Tip: The container may not exist or may not be scrollable.');\n        console.log('     Check: overflow-y: auto/scroll, or that content exceeds container bounds.');\n      }\n    }\n  });\n\n// Session screenshot command\nprogram\n  .command('session:screenshot <sessionId>')\n  .description('Take a screenshot and audit interactive elements')\n  .option('-n, --name <name>', 'Screenshot name')\n  .option('-s, --selector <css>', 'CSS selector to capture specific element')\n  .option('--no-full-page', 'Capture only the viewport')\n  .option('--viewport-only', 'Capture only viewport (alias for --no-full-page)')\n  .option('--json', 'Output audit results as JSON')\n  .action(async (sessionId: string, options: { name?: string; selector?: string; fullPage?: boolean; viewportOnly?: boolean; json?: boolean }) => {\n    const globalOpts = program.opts();\n    const outputDir = globalOpts.output || './.ibr';\n    const opId = await registerOperation(outputDir, {\n      type: 'screenshot',\n      sessionId,\n      command: `session:screenshot ${sessionId}${options.name ? ` --name ${options.name}` : ''}`,\n    });\n\n    try {\n      const session = await getSession(outputDir, sessionId);\n\n      // Handle --viewport-only as alias for --no-full-page\n      const fullPage = options.viewportOnly ? false : options.fullPage;\n\n      const { path, elements, audit } = await session.screenshot({\n        name: options.name,\n        selector: options.selector,\n        fullPage,\n      });\n\n      if (options.json) {\n        console.log(JSON.stringify({ path, elements, audit }, null, 2));\n      } else {\n        console.log(`Screenshot saved: ${path}`);\n        console.log('');\n        console.log('Element Audit:');\n        console.log(`  Total elements: ${audit.totalElements}`);\n        console.log(`  Interactive: ${audit.interactiveCount}`);\n        console.log(`  With handlers: ${audit.withHandlers}`);\n        console.log(`  Without handlers: ${audit.withoutHandlers}`);\n\n        if (audit.issues.length > 0) {\n          console.log('');\n          console.log('Issues detected:');\n          for (const issue of audit.issues) {\n            const icon = issue.severity === 'error' ? '‚úó' : issue.severity === 'warning' ? '!' : 'i';\n            console.log(`  ${icon} [${issue.type}] ${issue.message}`);\n          }\n        } else {\n          console.log('');\n          console.log('No issues detected.');\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      console.log('');\n      console.log('Tip: Session is still active. Try without --selector for full page.');\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  });\n\n// Session wait command\nprogram\n  .command('session:wait <sessionId> <selectorOrMs>')\n  .description('Wait for a selector to appear or a duration (in ms)')\n  .action(async (sessionId: string, selectorOrMs: string) => {\n    const globalOpts = program.opts();\n    const outputDir = globalOpts.output || './.ibr';\n    const opId = await registerOperation(outputDir, {\n      type: 'wait',\n      sessionId,\n      command: `session:wait ${sessionId} \"${selectorOrMs}\"`,\n    });\n\n    try {\n      const session = await getSession(outputDir, sessionId);\n\n      const isNumber = /^\\d+$/.test(selectorOrMs);\n      if (isNumber) {\n        await session.waitFor(parseInt(selectorOrMs, 10));\n        console.log(`Waited ${selectorOrMs}ms`);\n      } else {\n        await session.waitFor(selectorOrMs);\n        console.log(`Found: ${selectorOrMs}`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      console.log('');\n      console.log('Tip: Session is still active. Element may not exist yet or selector is wrong.');\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  });\n\n// Session navigate command\nprogram\n  .command('session:navigate <sessionId> <url>')\n  .description('Navigate to a new URL in an active session')\n  .option('-w, --wait-for <selector>', 'Wait for selector after navigation')\n  .action(async (sessionId: string, url: string, options: { waitFor?: string }) => {\n    const globalOpts = program.opts();\n    const outputDir = globalOpts.output || './.ibr';\n    const opId = await registerOperation(outputDir, {\n      type: 'navigate',\n      sessionId,\n      command: `session:navigate ${sessionId} \"${url}\"`,\n    });\n\n    try {\n      const session = await getSession(outputDir, sessionId);\n\n      await session.navigate(url, { waitFor: options.waitFor });\n      console.log(`Navigated to: ${url}`);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      console.log('');\n      console.log('Tip: Session is still active. Check URL or try without --wait-for.');\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  });\n\n// Session list command\nprogram\n  .command('session:list')\n  .description('List all active interactive sessions')\n  .action(async () => {\n    try {\n      const { isServerRunning, listActiveSessions } = await import('../browser-server.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      const serverRunning = await isServerRunning(outputDir);\n      const sessions = await listActiveSessions(outputDir);\n\n      console.log(`Browser server: ${serverRunning ? 'running' : 'not running'}`);\n      console.log('');\n\n      if (sessions.length === 0) {\n        console.log('No sessions found.');\n        console.log('');\n        console.log('Start one with:');\n        console.log('  npx ibr session:start <url>');\n        return;\n      }\n\n      console.log('Sessions:');\n      for (const id of sessions) {\n        console.log(`  ${id}`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session pending command - list pending operations\nprogram\n  .command('session:pending')\n  .description('List pending operations (useful before session:close all)')\n  .option('--json', 'Output as JSON')\n  .action(async (options: { json?: boolean }) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      const pending = await getPendingOperations(outputDir);\n\n      if (options.json) {\n        console.log(JSON.stringify(pending, null, 2));\n        return;\n      }\n\n      if (pending.length === 0) {\n        console.log('No pending operations.');\n        console.log('');\n        console.log('Safe to close browser server:');\n        console.log('  npx ibr session:close all');\n        return;\n      }\n\n      console.log(`${pending.length} pending operation(s):`);\n      console.log('');\n      console.log(formatPendingOperations(pending));\n      console.log('');\n      console.log('Wait for these to complete, or use:');\n      console.log('  npx ibr session:close all --force');\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session close command\nprogram\n  .command('session:close <sessionId>')\n  .description('Close a session (use \"all\" to stop browser server)')\n  .option('--force', 'Skip waiting for pending operations')\n  .option('--wait-timeout <ms>', 'Max wait time for pending operations (default: 30000)', '30000')\n  .action(async (sessionId: string, options: { force?: boolean; waitTimeout: string }) => {\n    try {\n      const { stopBrowserServer, PersistentSession, isServerRunning } = await import('../browser-server.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      if (sessionId === 'all') {\n        // Check for pending operations before closing\n        const pending = await getPendingOperations(outputDir);\n\n        if (pending.length > 0 && !options.force) {\n          console.log(`Found ${pending.length} pending operation(s):`);\n          console.log(formatPendingOperations(pending));\n          console.log('');\n          console.log(`Waiting for completion (timeout: ${options.waitTimeout}ms)...`);\n          console.log('Use --force to skip waiting');\n          console.log('');\n\n          const completed = await waitForCompletion(outputDir, {\n            timeout: parseInt(options.waitTimeout, 10),\n            onProgress: (remaining) => {\n              process.stdout.write(`\\rWaiting for ${remaining} operation(s)...`);\n            },\n          });\n\n          console.log(''); // Clear line\n\n          if (!completed) {\n            const remaining = await getPendingOperations(outputDir);\n            console.log(`Timeout reached. ${remaining.length} operation(s) still pending.`);\n            console.log('Use --force to close anyway, or wait for operations to complete.');\n            process.exit(1);\n          }\n\n          console.log('All operations completed.');\n        }\n\n        const stopped = await stopBrowserServer(outputDir);\n        if (stopped) {\n          console.log('Browser server stopped. All sessions closed.');\n        } else {\n          console.log('No browser server running.');\n        }\n        return;\n      }\n\n      // Close individual session\n      if (!(await isServerRunning(outputDir))) {\n        console.log('No browser server running.');\n        return;\n      }\n\n      const session = await PersistentSession.get(outputDir, sessionId);\n      if (session) {\n        await session.close();\n        console.log(`Session closed: ${sessionId}`);\n      } else {\n        console.log(`Session not found: ${sessionId}`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session HTML command - get page DOM\nprogram\n  .command('session:html <sessionId>')\n  .description('Get the full page HTML/DOM structure')\n  .option('-s, --selector <css>', 'Get HTML of specific element only')\n  .action(async (sessionId: string, options: { selector?: string }) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      if (options.selector) {\n        // Get outer HTML of specific element\n        const escapedSelector = options.selector.replace(/'/g, \"\\\\'\");\n        const html = await session.evaluate(`(() => {\n          const el = document.querySelector('${escapedSelector}');\n          return el ? el.outerHTML : null;\n        })()`);\n        if (html) {\n          console.log(html);\n        } else {\n          console.error(`Element not found: ${options.selector}`);\n          process.exit(1);\n        }\n      } else {\n        const html = await session.content();\n        console.log(html);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session text command - get text content\nprogram\n  .command('session:text <sessionId> <selector>')\n  .description('Get text content from a specific element')\n  .option('-a, --all', 'Get text from all matching elements')\n  .action(async (sessionId: string, selector: string, options: { all?: boolean }) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      if (options.all) {\n        const texts = await session.allTextContent(selector);\n        if (texts.length === 0) {\n          console.error(`No elements found: ${selector}`);\n          process.exit(1);\n        }\n        texts.forEach((text, i) => {\n          console.log(`[${i + 1}] ${text}`);\n        });\n      } else {\n        const text = await session.textContent(selector);\n        if (text === null) {\n          console.error(`Element not found: ${selector}`);\n          process.exit(1);\n        }\n        console.log(text.trim());\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session eval command - execute JavaScript in browser context\nprogram\n  .command('session:eval <sessionId> <script>')\n  .description('Execute JavaScript in the browser context')\n  .option('--json', 'Output result as JSON')\n  .action(async (sessionId: string, script: string, options: { json?: boolean }) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      const result = await session.evaluate(script);\n\n      if (options.json) {\n        console.log(JSON.stringify(result, null, 2));\n      } else if (result === undefined) {\n        console.log('[undefined]');\n      } else if (result === null) {\n        console.log('[null]');\n      } else if (typeof result === 'object') {\n        console.log(JSON.stringify(result, null, 2));\n      } else {\n        console.log(result);\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      console.error('Error:', msg);\n      console.log('');\n      console.log('Tip: Script must be valid JavaScript. Examples:');\n      console.log('  npx ibr session:eval <id> \"document.title\"');\n      console.log('  npx ibr session:eval <id> \"document.querySelectorAll(\\'.item\\').length\"');\n      console.log('  npx ibr session:eval <id> \"window.scrollY\"');\n      process.exit(1);\n    }\n  });\n\n// Session actions command - show action history\nprogram\n  .command('session:actions <sessionId>')\n  .description('Show action history for a session')\n  .action(async (sessionId: string) => {\n    try {\n      const { liveSessionManager } = await import('../live-session.js');\n      const session = liveSessionManager.get(sessionId);\n\n      if (!session) {\n        console.error(`Session not found or not active: ${sessionId}`);\n        process.exit(1);\n      }\n\n      const actions = session.actions;\n      console.log(`Actions for ${sessionId}:`);\n      console.log('');\n\n      for (const action of actions) {\n        const icon = action.success ? '‚úì' : '‚úó';\n        const duration = action.duration ? `(${action.duration}ms)` : '';\n        console.log(`  ${icon} ${action.type} ${duration}`);\n        if (action.params) {\n          const params = Object.entries(action.params)\n            .map(([k, v]) => `${k}=${typeof v === 'string' ? v : JSON.stringify(v)}`)\n            .join(', ');\n          console.log(`      ${params}`);\n        }\n        if (!action.success && action.error) {\n          console.log(`      Error: ${action.error}`);\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Session modal command - detect and dismiss modals\nprogram\n  .command('session:modal <sessionId>')\n  .description('Detect and optionally dismiss active modals')\n  .option('--dismiss', 'Attempt to dismiss the modal')\n  .action(async (sessionId: string, options: { dismiss?: boolean }) => {\n    try {\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const session = await getSession(outputDir, sessionId);\n\n      const modal = await session.detectModal();\n\n      if (!modal.hasModal) {\n        console.log('No modal detected');\n        return;\n      }\n\n      console.log(`Modal detected: ${modal.selector}`);\n      console.log(`Dismiss method: ${modal.dismissMethod}`);\n      if (modal.closeButtonSelector) {\n        console.log(`Close button: ${modal.closeButtonSelector}`);\n      }\n\n      if (options.dismiss) {\n        console.log('');\n        console.log('Attempting to dismiss...');\n\n        if (modal.dismissMethod === 'close-button' && modal.closeButtonSelector) {\n          await session.click(modal.closeButtonSelector, { force: true });\n        } else {\n          await session.press('Escape');\n        }\n\n        // Verify dismissal\n        await session.waitFor(300);\n        const stillOpen = await session.detectModal();\n        if (stillOpen.hasModal) {\n          console.log('Warning: Modal may still be open. Try:');\n          console.log(`  npx ibr session:press ${sessionId} Escape`);\n          console.log(`  npx ibr session:click ${sessionId} \".backdrop\" --force`);\n        } else {\n          console.log('Modal dismissed successfully');\n        }\n      } else {\n        console.log('');\n        console.log('To dismiss, run:');\n        console.log(`  npx ibr session:modal ${sessionId} --dismiss`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// ============================================================\n// SCREENSHOT MANAGEMENT COMMANDS\n// ============================================================\n\n// Screenshots list command\nprogram\n  .command('screenshots:list [sessionId]')\n  .description('List screenshots for a session or all sessions')\n  .option('--json', 'Output as JSON')\n  .action(async (sessionId: string | undefined, options: { json?: boolean }) => {\n    try {\n      const { ScreenshotManager, formatBytes, formatAge } = await import('../screenshot-manager.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      const manager = new ScreenshotManager(outputDir);\n\n      const screenshots = sessionId\n        ? await manager.list(sessionId)\n        : await manager.listAll();\n\n      if (screenshots.length === 0) {\n        console.log('No screenshots found.');\n        return;\n      }\n\n      if (options.json) {\n        console.log(JSON.stringify(screenshots, null, 2));\n        return;\n      }\n\n      console.log(`Found ${screenshots.length} screenshot(s):`);\n      console.log('');\n      console.log('PATH                                           SIZE       AGE');\n      console.log('-'.repeat(70));\n\n      for (const shot of screenshots) {\n        const shortPath = shot.path.length > 45 ? '...' + shot.path.slice(-42) : shot.path.padEnd(45);\n        console.log(`${shortPath} ${formatBytes(shot.size).padStart(10)} ${formatAge(shot.ageMs).padStart(10)}`);\n      }\n\n      // Show storage usage\n      const usage = await manager.getStorageUsage();\n      console.log('');\n      console.log(`Total: ${formatBytes(usage.totalBytes)} across ${usage.fileCount} files`);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Screenshots cleanup command\nprogram\n  .command('screenshots:cleanup')\n  .description('Clean up old screenshots based on retention policy')\n  .option('--max-age <days>', 'Delete screenshots older than N days', '7')\n  .option('--max-size <mb>', 'Max total storage in MB', '500')\n  .option('--dry-run', 'Show what would be deleted without deleting')\n  .action(async (options: { maxAge: string; maxSize: string; dryRun?: boolean }) => {\n    try {\n      const { ScreenshotManager, formatBytes } = await import('../screenshot-manager.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      const manager = new ScreenshotManager(outputDir, {\n        maxAgeDays: parseInt(options.maxAge, 10),\n        maxSizeBytes: parseInt(options.maxSize, 10) * 1024 * 1024,\n        retentionPolicy: 'both',\n      });\n\n      console.log(`Cleanup policy: max ${options.maxAge} days, max ${options.maxSize}MB`);\n      console.log('');\n\n      const report = await manager.cleanup({ dryRun: options.dryRun });\n\n      if (options.dryRun) {\n        console.log('DRY RUN - no files deleted');\n        console.log('');\n      }\n\n      console.log(`Scanned: ${report.scanned} files`);\n      console.log(`${options.dryRun ? 'Would delete' : 'Deleted'}: ${report.deleted} files`);\n      console.log(`Space ${options.dryRun ? 'to be freed' : 'freed'}: ${formatBytes(report.bytesFreed)}`);\n      console.log(`Kept: ${report.kept} files`);\n\n      if (report.errors.length > 0) {\n        console.log('');\n        console.log('Errors:');\n        for (const err of report.errors) {\n          console.log(`  ${err}`);\n        }\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Screenshots view command\nprogram\n  .command('screenshots:view <path>')\n  .description('View a screenshot with metadata')\n  .action(async (path: string) => {\n    try {\n      const { ScreenshotManager, formatBytes } = await import('../screenshot-manager.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n\n      const manager = new ScreenshotManager(outputDir);\n      const metadata = await manager.getMetadata(path);\n\n      if (!metadata) {\n        console.error(`Screenshot not found: ${path}`);\n        process.exit(1);\n      }\n\n      console.log('Screenshot Metadata:');\n      console.log(`  Path: ${metadata.path}`);\n      console.log(`  Size: ${formatBytes(metadata.size)}`);\n      console.log(`  Created: ${metadata.createdAt}`);\n      if (metadata.sessionId) console.log(`  Session: ${metadata.sessionId}`);\n      if (metadata.step) console.log(`  Step: ${metadata.step}`);\n      if (metadata.query) console.log(`  Query: ${metadata.query}`);\n      if (metadata.userIntent) console.log(`  Intent: ${metadata.userIntent}`);\n      console.log('');\n\n      // Try to open in default viewer\n      const { exec } = await import('child_process');\n      const cmd = process.platform === 'darwin' ? 'open' :\n                  process.platform === 'win32' ? 'start' : 'xdg-open';\n\n      exec(`${cmd} \"${path}\"`, (err) => {\n        if (err) {\n          console.log('Could not open image viewer. File path above.');\n        }\n      });\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// AI Search test command\nprogram\n  .command('search-test <url>')\n  .description('Run AI search test with screenshots and validation context')\n  .option('-q, --query <query>', 'Search query to test', 'test')\n  .option('-i, --intent <intent>', 'User intent for validation')\n  .option('--results-selector <css>', 'CSS selector for results')\n  .option('--no-screenshots', 'Skip capturing screenshots')\n  .option('--json', 'Output as JSON')\n  .action(async (url: string, options: {\n    query: string;\n    intent?: string;\n    resultsSelector?: string;\n    screenshots?: boolean;\n    json?: boolean;\n  }) => {\n    try {\n      const { chromium } = await import('playwright');\n      const { aiSearchFlow } = await import('../flows/search.js');\n      const { generateValidationContext, generateValidationPrompt, analyzeForObviousIssues } = await import('../flows/search-validation.js');\n      const globalOpts = program.opts();\n      const outputDir = globalOpts.output || './.ibr';\n      const { mkdir } = await import('fs/promises');\n\n      console.log(`Testing search on ${url}...`);\n      console.log(`Query: \"${options.query}\"`);\n      if (options.intent) console.log(`Intent: ${options.intent}`);\n      console.log('');\n\n      // Launch browser\n      const browser = await chromium.launch({ headless: true });\n      const viewport = VIEWPORTS[globalOpts.viewport as keyof typeof VIEWPORTS] || VIEWPORTS.desktop;\n\n      const context = await browser.newContext({\n        viewport: { width: viewport.width, height: viewport.height },\n        reducedMotion: 'reduce',\n      });\n\n      const page = await context.newPage();\n      await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });\n\n      // Create session directory for artifacts\n      const sessionDir = join(outputDir, 'sessions', `search-${Date.now()}`);\n      await mkdir(sessionDir, { recursive: true });\n\n      // Run AI search flow\n      const result = await aiSearchFlow(page, {\n        query: options.query,\n        userIntent: options.intent || `Find results related to: ${options.query}`,\n        resultsSelector: options.resultsSelector,\n        captureSteps: options.screenshots !== false,\n        extractContent: true,\n        sessionDir,\n      });\n\n      await context.close();\n      await browser.close();\n\n      // Generate validation context\n      const validationContext = generateValidationContext(result);\n      const obvIssues = analyzeForObviousIssues(validationContext);\n\n      if (options.json) {\n        console.log(JSON.stringify({\n          result,\n          validationContext,\n          obviousIssues: obvIssues,\n        }, null, 2));\n        return;\n      }\n\n      // Display results\n      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      console.log('  SEARCH TEST RESULTS');\n      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      console.log('');\n      console.log(`Status: ${result.success ? 'SUCCESS' : 'FAILED'}`);\n      console.log(`Results found: ${result.resultCount}`);\n      console.log('');\n      console.log('Timing:');\n      console.log(`  Typing: ${result.timing.typing}ms`);\n      console.log(`  Waiting: ${result.timing.waiting}ms`);\n      console.log(`  Rendering: ${result.timing.rendering}ms`);\n      console.log(`  Total: ${result.timing.total}ms`);\n\n      if (result.screenshots.length > 0) {\n        console.log('');\n        console.log('Screenshots:');\n        for (const shot of result.screenshots) {\n          console.log(`  ${shot.step}: ${shot.path}`);\n        }\n      }\n\n      if (result.extractedResults.length > 0) {\n        console.log('');\n        console.log(`Extracted Results (${result.extractedResults.length}):`);\n        for (const r of result.extractedResults.slice(0, 5)) {\n          const title = r.title || r.fullText.slice(0, 50);\n          console.log(`  ${r.index + 1}. ${title}`);\n        }\n        if (result.extractedResults.length > 5) {\n          console.log(`  ... and ${result.extractedResults.length - 5} more`);\n        }\n      }\n\n      if (obvIssues.length > 0) {\n        console.log('');\n        console.log('Potential Issues:');\n        for (const issue of obvIssues) {\n          const severity = issue.severity.toUpperCase();\n          console.log(`  [${severity}] ${issue.description}`);\n        }\n      }\n\n      // Output validation prompt for Claude Code\n      console.log('');\n      console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n      console.log('VALIDATION CONTEXT FOR CLAUDE CODE:');\n      console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n      console.log('');\n      console.log(generateValidationPrompt(validationContext));\n\n      if (result.artifactDir) {\n        console.log('');\n        console.log(`Artifacts saved to: ${result.artifactDir}`);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Scan command - discover and test multiple pages\nprogram\n  .command('scan [url]')\n  .description('Discover pages (auto-detects dev server if no URL)')\n  .option('-n, --max-pages <count>', 'Maximum pages to discover', '5')\n  .option('-p, --prefix <path>', 'Only scan pages under this path prefix')\n  .option('--nav-only', 'Only scan navigation links (faster)')\n  .option('-f, --format <format>', 'Output format: json, text', 'text')\n  .action(async (url: string | undefined, options: { maxPages: string; prefix?: string; navOnly?: boolean; format: string }) => {\n    try {\n      const resolvedUrl = await resolveBaseUrl(url);\n      const { discoverPages, getNavigationLinks } = await import('../crawl.js');\n\n      console.log(`Scanning ${resolvedUrl}...`);\n      console.log('');\n\n      let pages;\n\n      if (options.navOnly) {\n        // Quick nav-only scan\n        pages = await getNavigationLinks(resolvedUrl);\n        console.log(`Found ${pages.length} navigation links:`);\n      } else {\n        // Full crawl\n        const result = await discoverPages({\n          url: resolvedUrl,\n          maxPages: parseInt(options.maxPages, 10),\n          pathPrefix: options.prefix,\n        });\n        pages = result.pages;\n        console.log(`Discovered ${pages.length} pages (${result.crawlTime}ms):`);\n      }\n\n      console.log('');\n\n      if (options.format === 'json') {\n        console.log(JSON.stringify(pages, null, 2));\n      } else {\n        for (const page of pages) {\n          console.log(`  ${page.path}`);\n          console.log(`    Title: ${page.title}`);\n          if (page.linkText && page.linkText !== page.title) {\n            console.log(`    Link: ${page.linkText}`);\n          }\n          console.log('');\n        }\n      }\n\n      // Contextual tip\n      console.log('To capture baselines for these pages:');\n      console.log(`  npx ibr scan-start`);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Scan-start command - discover and capture baselines for multiple pages\nprogram\n  .command('scan-start [url]')\n  .description('Discover pages and capture baselines (auto-detects dev server if no URL)')\n  .option('-n, --max-pages <count>', 'Maximum pages to discover', '5')\n  .option('-p, --prefix <path>', 'Only scan pages under this path prefix')\n  .option('--nav-only', 'Only scan navigation links (faster)')\n  .action(async (url: string | undefined, options: { maxPages: string; prefix?: string; navOnly?: boolean }) => {\n    try {\n      const resolvedUrl = await resolveBaseUrl(url);\n      const { discoverPages, getNavigationLinks } = await import('../crawl.js');\n      const ibr = await createIBR(program.opts());\n\n      console.log(`Scanning ${resolvedUrl}...`);\n\n      let pages;\n\n      if (options.navOnly) {\n        pages = await getNavigationLinks(resolvedUrl);\n      } else {\n        const result = await discoverPages({\n          url: resolvedUrl,\n          maxPages: parseInt(options.maxPages, 10),\n          pathPrefix: options.prefix,\n        });\n        pages = result.pages;\n      }\n\n      console.log(`Found ${pages.length} pages. Capturing baselines...`);\n      console.log('');\n\n      const sessions = [];\n\n      for (const page of pages) {\n        try {\n          console.log(`Capturing: ${page.path}`);\n          const result = await ibr.startSession(page.url, {\n            name: page.title.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase().slice(0, 50),\n          });\n          sessions.push({ page, sessionId: result.sessionId });\n          console.log(`  Done: ${result.sessionId}`);\n        } catch (error) {\n          console.log(`  Failed: ${error instanceof Error ? error.message : error}`);\n        }\n      }\n\n      console.log('');\n      console.log(`Captured ${sessions.length}/${pages.length} pages.`);\n      console.log('');\n      console.log('Next: Make your changes, then run:');\n      console.log('  npx ibr scan-check');\n\n      await ibr.close();\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Scan-check command - compare all recent sessions\nprogram\n  .command('scan-check')\n  .description('Compare all sessions from the last scan-start')\n  .option('-f, --format <format>', 'Output format: json, text, minimal', 'text')\n  .action(async (_options: { format: string }) => {\n    try {\n      const ibr = await createIBR(program.opts());\n      const sessions = await ibr.listSessions();\n\n      // Get sessions from the last hour (likely from same scan)\n      const recentSessions = sessions.filter(s => {\n        const age = Date.now() - new Date(s.createdAt).getTime();\n        return age < 60 * 60 * 1000 && s.status === 'baseline';\n      });\n\n      if (recentSessions.length === 0) {\n        console.log('No recent baseline sessions found. Run scan-start first.');\n        return;\n      }\n\n      console.log(`Checking ${recentSessions.length} sessions...`);\n      console.log('');\n\n      const results = [];\n\n      for (const session of recentSessions) {\n        try {\n          console.log(`Checking: ${session.name}`);\n          const report = await ibr.check(session.id);\n          results.push({ session, report });\n\n          const icon = report.analysis.verdict === 'MATCH' ? '‚úì' :\n                       report.analysis.verdict === 'EXPECTED_CHANGE' ? '~' :\n                       report.analysis.verdict === 'UNEXPECTED_CHANGE' ? '!' : '‚úó';\n          console.log(`  ${icon} ${report.analysis.verdict}: ${report.analysis.summary}`);\n        } catch (error) {\n          console.log(`  ‚úó Failed: ${error instanceof Error ? error.message : error}`);\n        }\n      }\n\n      console.log('');\n\n      // Summary\n      const matches = results.filter(r => r.report.analysis.verdict === 'MATCH').length;\n      const expected = results.filter(r => r.report.analysis.verdict === 'EXPECTED_CHANGE').length;\n      const unexpected = results.filter(r => r.report.analysis.verdict === 'UNEXPECTED_CHANGE').length;\n      const broken = results.filter(r => r.report.analysis.verdict === 'LAYOUT_BROKEN').length;\n\n      console.log('Summary:');\n      console.log(`  ‚úì Match: ${matches}`);\n      console.log(`  ~ Expected: ${expected}`);\n      console.log(`  ! Unexpected: ${unexpected}`);\n      console.log(`  ‚úó Broken: ${broken}`);\n\n      if (unexpected > 0 || broken > 0) {\n        console.log('');\n        console.log('Issues detected. View in UI:');\n        console.log('  npx ibr serve');\n      }\n\n      await ibr.close();\n\n      // Exit with error if issues\n      if (broken > 0) process.exit(1);\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Consistency check command - compare UI consistency across pages\nprogram\n  .command('consistency <url>')\n  .description('Check UI consistency across multiple pages (opt-in)')\n  .option('-n, --max-pages <count>', 'Maximum pages to check', '5')\n  .option('--nav-only', 'Only check navigation links (faster)')\n  .option('--ignore <types>', 'Ignore certain checks (layout,typography,color,spacing)', '')\n  .option('-f, --format <format>', 'Output format: json, text', 'text')\n  .option('--confirm', 'Skip confirmation prompt (for automation/Claude Code)')\n  .action(async (url: string, options: {\n    maxPages: string;\n    navOnly?: boolean;\n    ignore: string;\n    format: string;\n    confirm?: boolean;\n  }) => {\n    try {\n      // Permission check - require explicit confirmation unless --confirm flag\n      if (!options.confirm) {\n        console.log('');\n        console.log('‚ö†Ô∏è  Consistency Check');\n        console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n        console.log('This will analyze UI styles across multiple pages to');\n        console.log('detect potential inconsistencies (fonts, colors, spacing).');\n        console.log('');\n        console.log('Note: Some style differences may be intentional.');\n        console.log('');\n        console.log('To proceed, run with --confirm flag:');\n        console.log(`  npx ibr consistency ${url} --confirm`);\n        console.log('');\n        console.log('Or for Claude Code automation:');\n        console.log(`  npx ibr consistency ${url} --confirm --format json`);\n        return;\n      }\n\n      const { discoverPages, getNavigationLinks } = await import('../crawl.js');\n      const { checkConsistency, formatConsistencyReport } = await import('../consistency.js');\n\n      console.log(`Discovering pages from ${url}...`);\n\n      let pages;\n      if (options.navOnly) {\n        pages = await getNavigationLinks(url);\n      } else {\n        const result = await discoverPages({\n          url,\n          maxPages: parseInt(options.maxPages, 10),\n        });\n        pages = result.pages;\n      }\n\n      if (pages.length < 2) {\n        console.log('Need at least 2 pages to check consistency.');\n        return;\n      }\n\n      console.log(`Found ${pages.length} pages. Analyzing styles...`);\n      console.log('');\n\n      const urls = pages.map(p => p.url);\n      const ignore = options.ignore ? options.ignore.split(',') as Array<'layout' | 'typography' | 'color' | 'spacing'> : [];\n\n      const result = await checkConsistency({\n        urls,\n        ignore,\n      });\n\n      if (options.format === 'json') {\n        console.log(JSON.stringify(result, null, 2));\n      } else {\n        console.log(formatConsistencyReport(result));\n      }\n\n      // Exit with error if score is low\n      if (result.score < 50) {\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Diagnose command - enhanced error diagnostics for a URL\nprogram\n  .command('diagnose [url]')\n  .description('Diagnose page load issues (auto-detects dev server if no URL)')\n  .option('--timeout <ms>', 'Timeout in milliseconds', '30000')\n  .action(async (url: string | undefined, options: { timeout: string }) => {\n    try {\n      const resolvedUrl = await resolveBaseUrl(url);\n      const { captureWithDiagnostics, closeBrowser } = await import('../capture.js');\n      const { join } = await import('path');\n      const outputDir = program.opts().output || './.ibr';\n\n      console.log(`Diagnosing ${resolvedUrl}...`);\n      console.log('');\n\n      const result = await captureWithDiagnostics({\n        url: resolvedUrl,\n        outputPath: join(outputDir, 'diagnose', 'test.png'),\n        timeout: parseInt(options.timeout, 10),\n        outputDir,\n      });\n\n      await closeBrowser();\n\n      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      console.log('  PAGE DIAGNOSTICS');\n      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n      console.log('');\n\n      if (result.success) {\n        console.log('‚úì Page loaded successfully');\n        console.log('');\n      } else {\n        console.log('‚úó Page failed to load');\n        console.log(`  Error: ${result.error?.message}`);\n        console.log(`  Suggestion: ${result.error?.suggestion}`);\n        console.log('');\n      }\n\n      console.log('Timing:');\n      console.log(`  Navigation: ${result.timing.navigationMs}ms`);\n      console.log(`  Render: ${result.timing.renderMs}ms`);\n      console.log(`  Total: ${result.timing.totalMs}ms`);\n      console.log('');\n\n      if (result.diagnostics.httpStatus) {\n        console.log(`HTTP Status: ${result.diagnostics.httpStatus}`);\n      }\n\n      if (result.diagnostics.consoleErrors.length > 0) {\n        console.log('');\n        console.log('Console Errors:');\n        for (const err of result.diagnostics.consoleErrors.slice(0, 5)) {\n          console.log(`  ‚Ä¢ ${err.substring(0, 100)}${err.length > 100 ? '...' : ''}`);\n        }\n        if (result.diagnostics.consoleErrors.length > 5) {\n          console.log(`  ... and ${result.diagnostics.consoleErrors.length - 5} more`);\n        }\n      }\n\n      if (result.diagnostics.networkErrors.length > 0) {\n        console.log('');\n        console.log('Network Errors:');\n        for (const err of result.diagnostics.networkErrors.slice(0, 5)) {\n          console.log(`  ‚Ä¢ ${err.substring(0, 100)}${err.length > 100 ? '...' : ''}`);\n        }\n        if (result.diagnostics.networkErrors.length > 5) {\n          console.log(`  ... and ${result.diagnostics.networkErrors.length - 5} more`);\n        }\n      }\n\n      if (result.diagnostics.suggestions.length > 0) {\n        console.log('');\n        console.log('Suggestions:');\n        for (const suggestion of result.diagnostics.suggestions) {\n          console.log(`  ‚Üí ${suggestion}`);\n        }\n      }\n\n      if (!result.success) {\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error instanceof Error ? error.message : error);\n      process.exit(1);\n    }\n  });\n\n// Helper to check if port is in use\nasync function isPortInUse(port: number): Promise<boolean> {\n  return new Promise((resolve) => {\n    const net = require('net');\n    const server = net.createServer();\n    server.once('error', () => resolve(true));\n    server.once('listening', () => {\n      server.close();\n      resolve(false);\n    });\n    server.listen(port, '127.0.0.1');\n  });\n}\n\n// Find available port from list\nasync function findAvailablePortFromList(ports: number[]): Promise<number | null> {\n  for (const port of ports) {\n    if (!(await isPortInUse(port))) {\n      return port;\n    }\n  }\n  return null;\n}\n\n// Common dev server ports (ordered by likelihood)\nconst DEV_SERVER_PORTS = [3000, 3001, 5173, 5174, 4200, 8080, 8000, 5000, 3100, 4321];\n\n// Detect running dev server by checking common ports\nasync function detectDevServer(): Promise<string | null> {\n  for (const port of DEV_SERVER_PORTS) {\n    if (await isPortInUse(port)) {\n      // Verify it responds to HTTP\n      try {\n        const controller = new AbortController();\n        const timeout = setTimeout(() => controller.abort(), 1000);\n        await fetch(`http://localhost:${port}`, {\n          signal: controller.signal,\n          method: 'HEAD'\n        });\n        clearTimeout(timeout);\n        return `http://localhost:${port}`;\n      } catch {\n        // Port in use but not HTTP, try next\n        continue;\n      }\n    }\n  }\n  return null;\n}\n\n// Resolve URL: use provided, or from config, or auto-detect\nasync function resolveBaseUrl(providedUrl?: string): Promise<string> {\n  if (providedUrl) {\n    return providedUrl;\n  }\n\n  const config = await loadConfig();\n  if (config.baseUrl) {\n    return config.baseUrl;\n  }\n\n  const detected = await detectDevServer();\n  if (detected) {\n    console.log(`Auto-detected dev server: ${detected}`);\n    return detected;\n  }\n\n  throw new Error('No URL provided and no dev server detected. Start your dev server or specify a URL.');\n}\n\n// Init command\nprogram\n  .command('init')\n  .description('Initialize IBR config and optionally register Claude Code plugin')\n  .option('-p, --port <port>', 'Port for baseUrl (auto-detects available port if not specified)')\n  .option('-u, --url <url>', 'Full base URL (overrides port)')\n  .option('--skip-plugin', 'Skip Claude Code plugin registration prompt')\n  .action(async (options: { port?: string; url?: string; skipPlugin?: boolean }) => {\n    const { writeFile, readFile, mkdir } = await import('fs/promises');\n    const configPath = join(process.cwd(), '.ibrrc.json');\n    const claudeSettingsPath = join(process.cwd(), '.claude', 'settings.json');\n\n    // --- Step 1: Create .ibrrc.json if needed ---\n    let configCreated = false;\n    if (!existsSync(configPath)) {\n      let baseUrl: string;\n\n      if (options.url) {\n        baseUrl = options.url;\n      } else if (options.port) {\n        baseUrl = `http://localhost:${options.port}`;\n      } else {\n        const preferredPort = 5000;\n        const fallbackPorts = [5050, 5555, 4200, 4321, 6789, 7777];\n\n        if (!(await isPortInUse(preferredPort))) {\n          baseUrl = `http://localhost:${preferredPort}`;\n          console.log(`Using default port ${preferredPort}`);\n        } else {\n          console.log(`Port ${preferredPort} in use, finding alternative...`);\n          const availablePort = await findAvailablePortFromList(fallbackPorts);\n\n          if (availablePort) {\n            baseUrl = `http://localhost:${availablePort}`;\n            console.log(`Auto-selected port ${availablePort}`);\n          } else {\n            baseUrl = 'http://localhost:YOUR_PORT';\n            console.log('All candidate ports in use. Please edit baseUrl in .ibrrc.json');\n          }\n        }\n      }\n\n      const config = {\n        baseUrl,\n        outputDir: './.ibr',\n        viewport: 'desktop',\n        threshold: 1.0,\n        fullPage: true,\n        retention: {\n          maxSessions: 20,\n          maxAgeDays: 7,\n          keepFailed: true,\n          autoClean: true,\n        },\n      };\n\n      await writeFile(configPath, JSON.stringify(config, null, 2));\n      configCreated = true;\n\n      console.log('');\n      console.log('Created .ibrrc.json');\n      console.log('');\n      console.log('Configuration:');\n      console.log(JSON.stringify(config, null, 2));\n    } else {\n      console.log('.ibrrc.json already exists.');\n    }\n\n    // --- Step 2: Claude Code plugin registration ---\n    if (options.skipPlugin) {\n      if (configCreated) {\n        console.log('');\n        console.log('Edit baseUrl to match your dev server.');\n      }\n      return;\n    }\n\n    // Check if Claude Code is present (look for .claude directory or settings)\n    const claudeDirExists = existsSync(join(process.cwd(), '.claude'));\n    const hasClaudeSettings = existsSync(claudeSettingsPath);\n\n    // Find the IBR plugin path\n    const possiblePluginPaths = [\n      'node_modules/@tyroneross/interface-built-right/plugin',\n      'node_modules/interface-built-right/plugin',\n      './plugin', // if running from IBR repo\n    ];\n\n    let pluginPath: string | null = null;\n    for (const p of possiblePluginPaths) {\n      if (existsSync(join(process.cwd(), p))) {\n        pluginPath = p;\n        break;\n      }\n    }\n\n    if (!pluginPath) {\n      console.log('');\n      console.log('IBR plugin path not found. Skipping Claude Code integration.');\n      if (configCreated) {\n        console.log('');\n        console.log('Edit baseUrl to match your dev server.');\n      }\n      return;\n    }\n\n    // Check if already registered\n    let settings: { plugins?: string[] } = { plugins: [] };\n    if (hasClaudeSettings) {\n      try {\n        const content = await readFile(claudeSettingsPath, 'utf-8');\n        settings = JSON.parse(content);\n        if (!settings.plugins) {\n          settings.plugins = [];\n        }\n      } catch {\n        settings = { plugins: [] };\n      }\n\n      // Check if already registered\n      const alreadyRegistered = settings.plugins.some(p =>\n        p.includes('interface-built-right/plugin') || p === pluginPath\n      );\n\n      if (alreadyRegistered) {\n        console.log('');\n        console.log('IBR plugin already registered in Claude Code.');\n        if (configCreated) {\n          console.log('');\n          console.log('Edit baseUrl to match your dev server.');\n        }\n        return;\n      }\n    }\n\n    // Show plugin benefits and prompt\n    console.log('');\n    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n    console.log('  CLAUDE CODE PLUGIN');\n    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n    console.log('');\n    console.log('IBR includes a Claude Code plugin for AI-assisted visual testing:');\n    console.log('');\n    console.log('  /ibr:snapshot  - Capture baseline with one command');\n    console.log('  /ibr:compare   - Visual diff without leaving conversation');\n    console.log('  /ibr:ui        - Open comparison viewer');\n    console.log('');\n    console.log('Benefits:');\n    console.log('  ‚Ä¢ Instant visual regression checks during development');\n    console.log('  ‚Ä¢ AI understands page semantics (intent, state, landmarks)');\n    console.log('  ‚Ä¢ Automatic suggestions when UI files change');\n    console.log('');\n\n    // Simple prompt using readline\n    const readline = await import('readline');\n    const rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n    });\n\n    const answer = await new Promise<string>((resolve) => {\n      rl.question('Register IBR plugin for Claude Code? [Y/n] ', (ans) => {\n        rl.close();\n        resolve(ans.trim().toLowerCase());\n      });\n    });\n\n    if (answer === 'n' || answer === 'no') {\n      console.log('');\n      console.log('Skipped plugin registration.');\n      console.log('');\n      console.log('To register later, add to .claude/settings.json:');\n      console.log(`  \"plugins\": [\"${pluginPath}\"]`);\n      if (configCreated) {\n        console.log('');\n        console.log('Edit baseUrl in .ibrrc.json to match your dev server.');\n      }\n      return;\n    }\n\n    // Register the plugin\n    try {\n      // Ensure .claude directory exists\n      if (!claudeDirExists) {\n        await mkdir(join(process.cwd(), '.claude'), { recursive: true });\n      }\n\n      settings.plugins = settings.plugins || [];\n      settings.plugins.push(pluginPath);\n\n      await writeFile(claudeSettingsPath, JSON.stringify(settings, null, 2));\n\n      console.log('');\n      console.log('IBR plugin registered.');\n      console.log('');\n      console.log('Restart Claude Code to activate. Then use:');\n      console.log('  /ibr:snapshot <url>  - Capture baseline');\n      console.log('  /ibr:compare         - Compare after changes');\n\n    } catch (err) {\n      console.log('');\n      console.log('Failed to register plugin:', err instanceof Error ? err.message : err);\n      console.log('');\n      console.log('To register manually, add to .claude/settings.json:');\n      console.log(`  \"plugins\": [\"${pluginPath}\"]`);\n    }\n\n    if (configCreated) {\n      console.log('');\n      console.log('Edit baseUrl in .ibrrc.json to match your dev server.');\n    }\n  });\n\n// ============================================================================\n// MEMORY COMMANDS\n// ============================================================================\n\nconst memoryCmd = program\n  .command('memory')\n  .description('Manage UI/UX preferences and memory');\n\nmemoryCmd\n  .command('add <description>')\n  .description('Add a UI/UX preference')\n  .option('--category <category>', 'Category: color, layout, typography, navigation, component, spacing, interaction, content', 'component')\n  .option('--component <type>', 'Component type (e.g., button, nav, card)')\n  .option('--property <property>', 'CSS property or semantic key', 'background-color')\n  .option('--operator <op>', 'Comparison: equals, contains, matches, gte, lte', 'equals')\n  .option('--value <value>', 'Expected value')\n  .option('--route <route>', 'Scope to route pattern')\n  .action(async (description: string, opts: any) => {\n    const { addPreference, formatPreference } = await import('../memory.js');\n    if (!opts.value) {\n      console.error('Error: --value is required');\n      process.exit(1);\n    }\n    const pref = await addPreference(program.opts().output || './.ibr', {\n      description,\n      category: opts.category,\n      componentType: opts.component,\n      property: opts.property,\n      operator: opts.operator,\n      value: opts.value,\n      route: opts.route,\n    });\n    console.log('Preference added:');\n    console.log(formatPreference(pref));\n  });\n\nmemoryCmd\n  .command('list')\n  .description('List all preferences')\n  .option('--category <category>', 'Filter by category')\n  .option('--route <route>', 'Filter by route')\n  .action(async (opts: any) => {\n    const { listPreferences } = await import('../memory.js');\n    const prefs = await listPreferences(program.opts().output || './.ibr', {\n      category: opts.category,\n      route: opts.route,\n    });\n    if (prefs.length === 0) {\n      console.log('No preferences stored.');\n      return;\n    }\n    for (const pref of prefs) {\n      const scope = pref.route ? ` (${pref.route})` : ' (global)';\n      const conf = pref.confidence < 1.0 ? ` [${Math.round(pref.confidence * 100)}%]` : '';\n      console.log(`  ${pref.id}: ${pref.description}${scope}${conf}`);\n    }\n  });\n\nmemoryCmd\n  .command('remove <id>')\n  .description('Remove a preference')\n  .action(async (id: string) => {\n    const { removePreference } = await import('../memory.js');\n    const removed = await removePreference(program.opts().output || './.ibr', id);\n    console.log(removed ? `Removed: ${id}` : `Not found: ${id}`);\n  });\n\nmemoryCmd\n  .command('show <id>')\n  .description('Show full preference detail')\n  .action(async (id: string) => {\n    const { getPreference, formatPreference } = await import('../memory.js');\n    const pref = await getPreference(program.opts().output || './.ibr', id);\n    if (!pref) {\n      console.log(`Not found: ${id}`);\n      return;\n    }\n    console.log(formatPreference(pref));\n  });\n\nmemoryCmd\n  .command('summary')\n  .description('Show memory summary and stats')\n  .action(async () => {\n    const { loadSummary, formatMemorySummary } = await import('../memory.js');\n    const summary = await loadSummary(program.opts().output || './.ibr');\n    console.log(formatMemorySummary(summary));\n  });\n\nmemoryCmd\n  .command('rebuild')\n  .description('Force rebuild summary from preference files')\n  .action(async () => {\n    const { rebuildSummary, formatMemorySummary } = await import('../memory.js');\n    const summary = await rebuildSummary(program.opts().output || './.ibr');\n    console.log('Summary rebuilt:');\n    console.log(formatMemorySummary(summary));\n  });\n\nmemoryCmd\n  .command('learned')\n  .description('Show learned expectations pending promotion')\n  .action(async () => {\n    const { listLearned } = await import('../memory.js');\n    const items = await listLearned(program.opts().output || './.ibr');\n    if (items.length === 0) {\n      console.log('No learned expectations yet.');\n      console.log('Approve sessions with ibr check to start learning.');\n      return;\n    }\n    for (const item of items) {\n      console.log(`  ${item.id} (from ${item.sessionId}):`);\n      for (const obs of item.observations) {\n        console.log(`    ${obs.category}: ${obs.description}`);\n      }\n    }\n  });\n\nmemoryCmd\n  .command('promote <learnedId>')\n  .description('Promote learned expectation to preference')\n  .action(async (learnedId: string) => {\n    const { promoteToPreference, formatPreference } = await import('../memory.js');\n    const pref = await promoteToPreference(program.opts().output || './.ibr', learnedId);\n    if (!pref) {\n      console.log(`Not found or empty: ${learnedId}`);\n      return;\n    }\n    console.log('Promoted to preference:');\n    console.log(formatPreference(pref));\n  });\n\nprogram.parse();\n","import { ConfigSchema, VIEWPORTS, type Config, type Session, type SessionQuery, type ComparisonReport, type Viewport } from './schemas.js';\nimport { captureScreenshot, captureWithLandmarks, closeBrowser } from './capture.js';\nimport { compareImages, analyzeComparison } from './compare.js';\nimport {\n  createSession,\n  getSession,\n  updateSession,\n  markSessionCompared,\n  listSessions,\n  getMostRecentSession,\n  deleteSession,\n  cleanSessions,\n  getSessionPaths,\n  findSessions,\n  getTimeline,\n  getSessionsByRoute,\n  getSessionStats,\n} from './session.js';\nimport { generateReport } from './report.js';\nimport type { StartSessionOptions, StartSessionResult, CleanOptions } from './types.js';\nimport { getSemanticOutput, formatSemanticText, type SemanticResult } from './semantic/index.js';\nimport { loginFlow, searchFlow, formFlow, type FlowLoginOptions, type FlowSearchOptions, type FlowFormOptions } from './flows/index.js';\nimport { chromium, type Page, type Browser, type BrowserContext } from 'playwright';\nimport { mkdir, access } from 'fs/promises';\nimport { join, dirname } from 'path';\nimport { tmpdir } from 'os';\nimport { maybeAutoClean } from './cleanup.js';\n\n// ============================================================================\n// STANDALONE PROGRAMMATIC API\n// These functions provide first-class programmatic comparison without\n// requiring session management or CLI wrappers.\n// ============================================================================\n\n/**\n * Options for standalone compare function\n */\nexport interface CompareInput {\n  /** URL to capture and compare (will auto-capture current state) */\n  url?: string;\n  /** Path to baseline image (required if no url) */\n  baselinePath?: string;\n  /** Path to current image (auto-captured if url provided) */\n  currentPath?: string;\n  /** Pixel difference threshold (0-100, default 1.0) */\n  threshold?: number;\n  /** Output directory for diff and temp files */\n  outputDir?: string;\n  /** Viewport configuration */\n  viewport?: 'desktop' | 'mobile' | 'tablet' | Viewport;\n  /** Capture full page */\n  fullPage?: boolean;\n  /** Wait for network idle before capture */\n  waitForNetworkIdle?: boolean;\n  /** Capture timeout in ms */\n  timeout?: number;\n}\n\n/**\n * Result from standalone compare function\n */\nexport interface CompareResult {\n  /** Whether images match within threshold */\n  match: boolean;\n  /** Percentage of pixels that differ */\n  diffPercent: number;\n  /** Number of differing pixels */\n  diffPixels: number;\n  /** Total pixels compared */\n  totalPixels: number;\n  /** Analysis verdict: MATCH, EXPECTED_CHANGE, UNEXPECTED_CHANGE, LAYOUT_BROKEN */\n  verdict: string;\n  /** Human-readable summary */\n  summary: string;\n  /** Regions with changes */\n  changedRegions: Array<{\n    location: string;\n    description: string;\n    severity: 'expected' | 'unexpected' | 'critical';\n  }>;\n  /** Recommendation for fixing issues */\n  recommendation: string | null;\n  /** Path to diff image (if generated) */\n  diffPath?: string;\n  /** Path to baseline used */\n  baselinePath: string;\n  /** Path to current image used */\n  currentPath: string;\n}\n\n/**\n * Standalone compare function - compare images without session management\n *\n * @example\n * ```typescript\n * // Compare by URL (auto-captures current state)\n * const result = await compare({\n *   url: 'http://localhost:3000',\n *   baselinePath: './baseline.png'\n * });\n *\n * // Compare two existing images\n * const result = await compare({\n *   baselinePath: './baseline.png',\n *   currentPath: './current.png'\n * });\n *\n * // Compare URL with auto threshold\n * const result = await compare({\n *   url: 'http://localhost:3000',\n *   baselinePath: './baseline.png',\n *   threshold: 0.5  // 0.5% difference allowed\n * });\n * ```\n */\nexport async function compare(options: CompareInput): Promise<CompareResult> {\n  const {\n    url,\n    baselinePath,\n    currentPath,\n    threshold = 1.0,\n    outputDir = join(tmpdir(), 'ibr-compare'),\n    viewport = 'desktop',\n    fullPage = true,\n    waitForNetworkIdle = true,\n    timeout = 30000,\n  } = options;\n\n  // Validate inputs\n  if (!baselinePath && !url) {\n    throw new Error('Either baselinePath or url must be provided');\n  }\n\n  // Resolve viewport\n  const resolvedViewport: Viewport = typeof viewport === 'string'\n    ? VIEWPORTS[viewport] || VIEWPORTS.desktop\n    : viewport;\n\n  // Create output directory\n  await mkdir(outputDir, { recursive: true });\n\n  // Determine paths\n  const timestamp = Date.now();\n  const actualBaselinePath = baselinePath || join(outputDir, `baseline-${timestamp}.png`);\n  let actualCurrentPath = currentPath || join(outputDir, `current-${timestamp}.png`);\n  const diffPath = join(outputDir, `diff-${timestamp}.png`);\n\n  // If URL provided but no baseline, capture baseline first\n  if (url && !baselinePath) {\n    await captureScreenshot({\n      url,\n      outputPath: actualBaselinePath,\n      viewport: resolvedViewport,\n      fullPage,\n      waitForNetworkIdle,\n      timeout,\n    });\n  }\n\n  // If URL provided, capture current state\n  if (url && !currentPath) {\n    await captureScreenshot({\n      url,\n      outputPath: actualCurrentPath,\n      viewport: resolvedViewport,\n      fullPage,\n      waitForNetworkIdle,\n      timeout,\n    });\n  }\n\n  // Verify files exist\n  try {\n    await access(actualBaselinePath);\n  } catch {\n    throw new Error(`Baseline image not found: ${actualBaselinePath}`);\n  }\n  try {\n    await access(actualCurrentPath);\n  } catch {\n    throw new Error(`Current image not found: ${actualCurrentPath}`);\n  }\n\n  // Compare images\n  const comparison = await compareImages({\n    baselinePath: actualBaselinePath,\n    currentPath: actualCurrentPath,\n    diffPath,\n    threshold: threshold / 100, // Convert percentage to 0-1 for pixelmatch\n  });\n\n  // Analyze results\n  const analysis = analyzeComparison(comparison, threshold);\n\n  // Close browser if we opened one\n  await closeBrowser();\n\n  return {\n    match: comparison.match,\n    diffPercent: comparison.diffPercent,\n    diffPixels: comparison.diffPixels,\n    totalPixels: comparison.totalPixels,\n    verdict: analysis.verdict,\n    summary: analysis.summary,\n    changedRegions: analysis.changedRegions.map(r => ({\n      location: r.location,\n      description: r.description,\n      severity: r.severity,\n    })),\n    recommendation: analysis.recommendation,\n    diffPath: comparison.match ? undefined : diffPath,\n    baselinePath: actualBaselinePath,\n    currentPath: actualCurrentPath,\n  };\n}\n\n/**\n * Options for batch comparison\n */\nexport interface CompareAllInput {\n  /** Session ID to compare (uses most recent if not provided) */\n  sessionId?: string;\n  /** Output directory (defaults to .ibr) */\n  outputDir?: string;\n  /** Only compare sessions matching this URL pattern */\n  urlPattern?: string | RegExp;\n  /** Only compare sessions with these statuses */\n  statuses?: Array<'baseline' | 'compared' | 'pending'>;\n  /** Maximum number of sessions to compare */\n  limit?: number;\n}\n\n/**\n * Batch compare all sessions or a filtered subset\n *\n * @example\n * ```typescript\n * // Compare all sessions\n * const results = await compareAll();\n *\n * // Compare sessions matching URL\n * const results = await compareAll({\n *   urlPattern: /\\/dashboard/\n * });\n *\n * // Compare specific session\n * const results = await compareAll({\n *   sessionId: 'sess_abc123'\n * });\n * ```\n */\nexport async function compareAll(options: CompareAllInput = {}): Promise<CompareResult[]> {\n  const {\n    sessionId,\n    outputDir = './.ibr',\n    urlPattern,\n    statuses = ['baseline'],\n    limit = 50,\n  } = options;\n\n  const results: CompareResult[] = [];\n\n  if (sessionId) {\n    // Compare single session\n    const session = await getSession(outputDir, sessionId);\n    if (!session) {\n      throw new Error(`Session not found: ${sessionId}`);\n    }\n    const paths = getSessionPaths(outputDir, session.id);\n\n    const result = await compare({\n      url: session.url,\n      baselinePath: paths.baseline,\n      outputDir: dirname(paths.diff),\n      viewport: session.viewport,\n    });\n\n    results.push(result);\n  } else {\n    // Get all matching sessions\n    let sessions = await listSessions(outputDir);\n\n    // Filter by status\n    sessions = sessions.filter(s => statuses.includes(s.status as 'baseline' | 'compared' | 'pending'));\n\n    // Filter by URL pattern\n    if (urlPattern) {\n      const pattern = typeof urlPattern === 'string' ? new RegExp(urlPattern) : urlPattern;\n      sessions = sessions.filter(s => pattern.test(s.url));\n    }\n\n    // Apply limit\n    sessions = sessions.slice(0, limit);\n\n    // Compare each session\n    for (const session of sessions) {\n      try {\n        const paths = getSessionPaths(outputDir, session.id);\n        const result = await compare({\n          url: session.url,\n          baselinePath: paths.baseline,\n          outputDir: dirname(paths.diff),\n          viewport: session.viewport,\n        });\n        results.push(result);\n      } catch (err) {\n        // Continue on individual session failures\n        console.warn(`Failed to compare session ${session.id}: ${err}`);\n      }\n    }\n  }\n\n  // Close browser after all comparisons\n  await closeBrowser();\n\n  return results;\n}\n\n// ============================================================================\n// CLASS-BASED API (Original)\n// ============================================================================\n\nexport class InterfaceBuiltRight {\n  private config: Config;\n\n  constructor(options: Partial<Config> = {}) {\n    // Validate and merge with defaults\n    this.config = ConfigSchema.parse(options);\n  }\n\n  /**\n   * Start a visual session by capturing a baseline screenshot\n   */\n  async startSession(path: string, options: StartSessionOptions = {}): Promise<StartSessionResult> {\n    const {\n      name = this.generateSessionName(path),\n      viewport = this.config.viewport,\n      fullPage = this.config.fullPage,\n      selector,\n      waitFor,\n    } = options;\n\n    const url = this.resolveUrl(path);\n\n    // Create session\n    const session = await createSession(this.config.outputDir, url, name, viewport);\n    const paths = getSessionPaths(this.config.outputDir, session.id);\n\n    // Capture baseline with landmark detection (outputDir enables auth state loading)\n    const captureResult = await captureWithLandmarks({\n      url,\n      outputPath: paths.baseline,\n      viewport,\n      fullPage,\n      waitForNetworkIdle: this.config.waitForNetworkIdle,\n      timeout: this.config.timeout,\n      outputDir: this.config.outputDir,\n      selector,\n      waitFor,\n    });\n\n    // Update session with detected landmarks and page intent\n    const updatedSession = await updateSession(this.config.outputDir, session.id, {\n      landmarkElements: captureResult.landmarkElements,\n      pageIntent: captureResult.pageIntent,\n    });\n\n    // Run auto-cleanup if enabled in retention config\n    await maybeAutoClean(this.config.outputDir);\n\n    return {\n      sessionId: session.id,\n      baseline: paths.baseline,\n      session: updatedSession,\n    };\n  }\n\n  /**\n   * Check current state against baseline\n   */\n  async check(sessionId?: string): Promise<ComparisonReport> {\n    // Get session\n    const session = sessionId\n      ? await getSession(this.config.outputDir, sessionId)\n      : await getMostRecentSession(this.config.outputDir);\n\n    if (!session) {\n      throw new Error(sessionId\n        ? `Session not found: ${sessionId}`\n        : 'No sessions found. Run startSession first.');\n    }\n\n    const paths = getSessionPaths(this.config.outputDir, session.id);\n\n    // Capture current screenshot (outputDir enables auth state loading)\n    await captureScreenshot({\n      url: session.url,\n      outputPath: paths.current,\n      viewport: session.viewport,\n      fullPage: this.config.fullPage,\n      waitForNetworkIdle: this.config.waitForNetworkIdle,\n      timeout: this.config.timeout,\n      outputDir: this.config.outputDir,\n    });\n\n    // Compare images\n    const comparison = await compareImages({\n      baselinePath: paths.baseline,\n      currentPath: paths.current,\n      diffPath: paths.diff,\n      threshold: this.config.threshold / 100, // Convert percentage to 0-1 range for pixelmatch\n    });\n\n    // Analyze results\n    const analysis = analyzeComparison(comparison, this.config.threshold);\n\n    // Update session\n    await markSessionCompared(this.config.outputDir, session.id, comparison, analysis);\n\n    // Generate report\n    return generateReport(session, comparison, analysis, this.config.outputDir);\n  }\n\n  /**\n   * Get a session by ID\n   */\n  async getSession(sessionId: string): Promise<Session | null> {\n    return getSession(this.config.outputDir, sessionId);\n  }\n\n  /**\n   * Get the most recent session\n   */\n  async getMostRecentSession(): Promise<Session | null> {\n    return getMostRecentSession(this.config.outputDir);\n  }\n\n  /**\n   * List all sessions\n   */\n  async listSessions(): Promise<Session[]> {\n    return listSessions(this.config.outputDir);\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(sessionId: string): Promise<boolean> {\n    return deleteSession(this.config.outputDir, sessionId);\n  }\n\n  /**\n   * Clean old sessions\n   */\n  async clean(options: CleanOptions = {}): Promise<{ deleted: string[]; kept: string[] }> {\n    return cleanSessions(this.config.outputDir, options);\n  }\n\n  /**\n   * Find sessions matching query criteria\n   */\n  async find(query: Partial<SessionQuery> = {}): Promise<Session[]> {\n    return findSessions(this.config.outputDir, query);\n  }\n\n  /**\n   * Get timeline of sessions for a specific route\n   * Returns sessions in chronological order (oldest first)\n   */\n  async getTimeline(route: string, limit: number = 10): Promise<Session[]> {\n    return getTimeline(this.config.outputDir, route, limit);\n  }\n\n  /**\n   * Get sessions grouped by route\n   */\n  async getSessionsByRoute(): Promise<Record<string, Session[]>> {\n    return getSessionsByRoute(this.config.outputDir);\n  }\n\n  /**\n   * Get session statistics\n   */\n  async getStats(): Promise<{\n    total: number;\n    byStatus: Record<string, number>;\n    byViewport: Record<string, number>;\n    byVerdict: Record<string, number>;\n  }> {\n    return getSessionStats(this.config.outputDir);\n  }\n\n  /**\n   * Update baseline with current screenshot\n   */\n  async updateBaseline(sessionId?: string): Promise<Session> {\n    const session = sessionId\n      ? await getSession(this.config.outputDir, sessionId)\n      : await getMostRecentSession(this.config.outputDir);\n\n    if (!session) {\n      throw new Error(sessionId\n        ? `Session not found: ${sessionId}`\n        : 'No sessions found.');\n    }\n\n    const paths = getSessionPaths(this.config.outputDir, session.id);\n\n    // Capture new baseline (outputDir enables auth state loading)\n    await captureScreenshot({\n      url: session.url,\n      outputPath: paths.baseline,\n      viewport: session.viewport,\n      fullPage: this.config.fullPage,\n      waitForNetworkIdle: this.config.waitForNetworkIdle,\n      timeout: this.config.timeout,\n      outputDir: this.config.outputDir,\n    });\n\n    // Reset session status\n    return updateSession(this.config.outputDir, session.id, {\n      status: 'baseline',\n      comparison: undefined,\n      analysis: undefined,\n    });\n  }\n\n  /**\n   * Start a simplified session with semantic understanding\n   *\n   * This is the new simpler API - one line to start:\n   * ```typescript\n   * const session = await ibr.start('http://localhost:3000');\n   * const understanding = await session.understand();\n   * ```\n   */\n  async start(url: string, options: {\n    viewport?: 'desktop' | 'mobile' | 'tablet';\n    waitFor?: string;\n    timeout?: number;\n  } = {}): Promise<IBRSession> {\n    const fullUrl = this.resolveUrl(url);\n    const viewportName = options.viewport || 'desktop';\n    const viewport = VIEWPORTS[viewportName];\n\n    // Launch browser\n    const browser = await chromium.launch({ headless: true });\n    const context = await browser.newContext({\n      viewport,\n      userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',\n    });\n    const page = await context.newPage();\n\n    // Navigate\n    await page.goto(fullUrl, {\n      waitUntil: 'domcontentloaded',\n      timeout: options.timeout || this.config.timeout,\n    });\n\n    // Wait for network idle\n    if (this.config.waitForNetworkIdle) {\n      await page.waitForLoadState('networkidle', { timeout: 10000 }).catch(() => {});\n    }\n\n    // Wait for specific selector if provided\n    if (options.waitFor) {\n      await page.waitForSelector(options.waitFor, { timeout: 10000 }).catch(() => {});\n    }\n\n    return new IBRSession(page, browser, context, this.config);\n  }\n\n  /**\n   * Close the browser instance\n   */\n  async close(): Promise<void> {\n    await closeBrowser();\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): Config {\n    return { ...this.config };\n  }\n\n  /**\n   * Resolve a path to full URL\n   */\n  private resolveUrl(path: string): string {\n    if (path.startsWith('http://') || path.startsWith('https://')) {\n      return path;\n    }\n    return `${this.config.baseUrl}${path.startsWith('/') ? path : `/${path}`}`;\n  }\n\n  /**\n   * Generate a session name from path\n   */\n  private generateSessionName(path: string): string {\n    // Remove leading slash and replace remaining slashes with dashes\n    return path\n      .replace(/^\\/+/, '')\n      .replace(/\\//g, '-')\n      .replace(/[^a-zA-Z0-9-_]/g, '')\n      || 'homepage';\n  }\n}\n\n/**\n * IBRSession - Simplified session with semantic understanding\n *\n * Provides a cleaner API for interacting with pages and getting\n * AI-friendly semantic output.\n */\nexport class IBRSession {\n  /** Raw Playwright page for advanced use */\n  readonly page: Page;\n\n  private browser: Browser;\n  private context: BrowserContext;\n  private config: Config;\n\n  constructor(page: Page, browser: Browser, context: BrowserContext, config: Config) {\n    this.page = page;\n    this.browser = browser;\n    this.context = context;\n    this.config = config;\n  }\n\n  /**\n   * Get semantic understanding of the current page\n   */\n  async understand(): Promise<SemanticResult> {\n    return getSemanticOutput(this.page);\n  }\n\n  /**\n   * Get semantic understanding as formatted text\n   */\n  async understandText(): Promise<string> {\n    const result = await getSemanticOutput(this.page);\n    return formatSemanticText(result);\n  }\n\n  /**\n   * Click an element by selector\n   */\n  async click(selector: string): Promise<void> {\n    await this.page.click(selector);\n  }\n\n  /**\n   * Type text into an element\n   */\n  async type(selector: string, text: string): Promise<void> {\n    await this.page.fill(selector, text);\n  }\n\n  /**\n   * Navigate to a new URL\n   */\n  async goto(url: string): Promise<void> {\n    await this.page.goto(url, {\n      waitUntil: 'domcontentloaded',\n      timeout: this.config.timeout,\n    });\n  }\n\n  /**\n   * Wait for a selector to appear\n   */\n  async waitFor(selector: string, timeout = 10000): Promise<void> {\n    await this.page.waitForSelector(selector, { timeout });\n  }\n\n  /**\n   * Take a screenshot\n   */\n  async screenshot(path?: string): Promise<Buffer> {\n    return this.page.screenshot({\n      path,\n      fullPage: this.config.fullPage,\n    });\n  }\n\n  /**\n   * Mock a network request (thin wrapper on page.route)\n   */\n  async mock(pattern: string | RegExp, response: {\n    status?: number;\n    body?: string | object;\n    headers?: Record<string, string>;\n  }): Promise<void> {\n    await this.page.route(pattern, async (route) => {\n      const body = typeof response.body === 'object'\n        ? JSON.stringify(response.body)\n        : response.body || '';\n\n      await route.fulfill({\n        status: response.status || 200,\n        body,\n        headers: {\n          'Content-Type': typeof response.body === 'object'\n            ? 'application/json'\n            : 'text/plain',\n          ...response.headers,\n        },\n      });\n    });\n  }\n\n  /**\n   * Built-in flows for common automation patterns\n   */\n  readonly flow = {\n    /**\n     * Login with email/password\n     * @example\n     * const result = await session.flow.login({ email: 'test@test.com', password: 'secret' });\n     */\n    login: (options: Omit<FlowLoginOptions, 'timeout'>) =>\n      loginFlow(this.page, { ...options, timeout: this.config.timeout }),\n\n    /**\n     * Search for content\n     * @example\n     * const result = await session.flow.search({ query: 'test' });\n     */\n    search: (options: Omit<FlowSearchOptions, 'timeout'>) =>\n      searchFlow(this.page, { ...options, timeout: this.config.timeout }),\n\n    /**\n     * Fill and submit a form\n     * @example\n     * const result = await session.flow.form({\n     *   fields: [{ name: 'email', value: 'test@test.com' }]\n     * });\n     */\n    form: (options: Omit<FlowFormOptions, 'timeout'>) =>\n      formFlow(this.page, { ...options, timeout: this.config.timeout }),\n  };\n\n  /**\n   * Measure Web Vitals performance metrics\n   * @example\n   * const result = await session.measurePerformance();\n   * console.log(result.ratings.LCP); // { value: 1200, rating: 'good' }\n   */\n  async measurePerformance() {\n    const { measurePerformance: mp } = await import('./performance.js');\n    return mp(this.page);\n  }\n\n  /**\n   * Test interactivity of buttons, links, and forms\n   * @example\n   * const result = await session.testInteractivity();\n   * console.log(result.issues); // List of issues with buttons/links\n   */\n  async testInteractivity() {\n    const { testInteractivity: ti } = await import('./interactivity.js');\n    return ti(this.page);\n  }\n\n  /**\n   * Start tracking API request timing\n   * Call before actions, then call stop() to get results\n   * @example\n   * const tracker = session.trackApiTiming({ filter: /\\/api\\// });\n   * tracker.start();\n   * await session.click('button');\n   * const result = tracker.stop();\n   */\n  trackApiTiming(options?: { filter?: RegExp; includeStatic?: boolean; minDuration?: number }) {\n    // Import synchronously for tracker creation\n    const createTracker = async () => {\n      const { createApiTracker } = await import('./api-timing.js');\n      return createApiTracker(this.page, options);\n    };\n    // Return a promise that resolves to the tracker\n    return createTracker();\n  }\n\n  /**\n   * Close the session and browser\n   */\n  async close(): Promise<void> {\n    await this.context.close();\n    await this.browser.close();\n  }\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\n// Standalone programmatic API (recommended for most users)\n// compare() and compareAll() are exported inline above\n// Types re-exported for convenience\n\n// Export everything for programmatic use\nexport * from './schemas.js';\nexport * from './types.js';\nexport { DEFAULT_DYNAMIC_SELECTORS } from './types.js';\nexport type { MaskOptions } from './types.js';\nexport { captureScreenshot, closeBrowser, getViewport, captureWithDiagnostics } from './capture.js';\nexport type { CaptureResult } from './capture.js';\nexport { checkConsistency, formatConsistencyReport } from './consistency.js';\nexport type { ConsistencyOptions, ConsistencyResult, PageMetrics, Inconsistency } from './consistency.js';\nexport { compareImages, analyzeComparison, getVerdictDescription, detectChangedRegions } from './compare.js';\nexport type { ExtendedComparisonResult } from './compare.js';\nexport { discoverPages, getNavigationLinks } from './crawl.js';\nexport type { CrawlOptions, CrawlResult, DiscoveredPage } from './crawl.js';\nexport {\n  createSession,\n  getSession,\n  updateSession,\n  markSessionCompared,\n  listSessions,\n  getMostRecentSession,\n  deleteSession,\n  cleanSessions,\n  getSessionPaths,\n  generateSessionId,\n  findSessions,\n  getTimeline,\n  getSessionsByRoute,\n  getSessionStats,\n} from './session.js';\nexport { generateReport, formatReportText, formatReportJson, formatReportMinimal, formatSessionSummary } from './report.js';\nexport {\n  extractApiCalls,\n  scanDirectoryForApiCalls,\n  discoverApiRoutes,\n  filePathToRoute,\n  findOrphanEndpoints,\n  groupByEndpoint,\n  groupByFile,\n  filterByMethod,\n  filterByEndpoint,\n} from './integration.js';\nexport type { ApiCall, ApiRoute } from './integration.js';\nexport { VIEWPORTS };\nexport {\n  registerOperation,\n  completeOperation,\n  getPendingOperations,\n  waitForCompletion,\n  formatPendingOperations,\n  withOperationTracking,\n} from './operation-tracker.js';\nexport type { PendingOperation, OperationState, OperationType } from './operation-tracker.js';\n\n// Semantic layer exports\nexport * from './semantic/index.js';\n\n// Flows exports\nexport * from './flows/index.js';\n\n// Cleanup and retention exports\nexport {\n  enforceRetentionPolicy,\n  maybeAutoClean,\n  getRetentionStatus,\n  formatRetentionStatus,\n  loadRetentionConfig,\n  DEFAULT_RETENTION,\n} from './cleanup.js';\nexport type { RetentionConfig, RetentionResult } from './cleanup.js';\n\n// Performance testing exports\nexport {\n  measureWebVitals,\n  measurePerformance,\n  formatPerformanceResult,\n  PERFORMANCE_THRESHOLDS,\n} from './performance.js';\nexport type {\n  WebVitals,\n  PerformanceResult,\n  PerformanceRating,\n  RatedMetric,\n} from './performance.js';\n\n// Interactivity testing exports\nexport {\n  testInteractivity,\n  formatInteractivityResult,\n} from './interactivity.js';\nexport type {\n  InteractivityResult,\n  InteractiveElement,\n  ButtonInfo,\n  LinkInfo,\n  FormInfo,\n  FormFieldInfo,\n  InteractivityIssue,\n} from './interactivity.js';\n\n// API timing exports\nexport {\n  measureApiTiming,\n  createApiTracker,\n  formatApiTimingResult,\n} from './api-timing.js';\nexport type {\n  ApiTimingResult,\n  ApiRequestTiming,\n  ApiTimingOptions,\n} from './api-timing.js';\n\n// Responsive testing exports\nexport {\n  testResponsive,\n  formatResponsiveResult,\n} from './responsive.js';\nexport type {\n  ResponsiveResult,\n  ViewportResult,\n  LayoutIssue,\n  TouchTargetIssue,\n  TextIssue,\n  ResponsiveTestOptions,\n} from './responsive.js';\n\n// Memory system exports\nexport {\n  initMemory,\n  loadSummary,\n  saveSummary,\n  addPreference,\n  getPreference,\n  removePreference,\n  listPreferences,\n  learnFromSession,\n  listLearned,\n  promoteToPreference,\n  rebuildSummary,\n  archiveSummary,\n  queryMemory,\n  preferencesToRules,\n  createMemoryPreset,\n  formatMemorySummary,\n  formatPreference,\n} from './memory.js';\n\n// Decision context system exports\nexport {\n  recordDecision,\n  getDecisionsByRoute,\n  queryDecisions,\n  getDecision,\n  getTrackedRoutes,\n  getDecisionStats,\n  getDecisionsSize,\n} from './decision-tracker.js';\nexport type { RecordDecisionOptions, QueryDecisionsOptions } from './decision-tracker.js';\n\nexport {\n  loadCompactContext,\n  saveCompactContext,\n  updateCompactContext,\n  compactContext,\n  setActiveRoute,\n  addKnownIssue,\n  isCompactContextOversize,\n} from './context/compact.js';\n\nexport * from './context/types.js';\n","import type { Session, ComparisonResult, Analysis, ComparisonReport } from './schemas.js';\nimport { getSessionPaths } from './session.js';\n\n/**\n * Generate a full comparison report\n */\nexport function generateReport(\n  session: Session,\n  comparison: ComparisonResult,\n  analysis: Analysis,\n  outputDir: string,\n  webViewPort?: number\n): ComparisonReport {\n  const paths = getSessionPaths(outputDir, session.id);\n\n  const report: ComparisonReport = {\n    sessionId: session.id,\n    sessionName: session.name,\n    url: session.url,\n    timestamp: new Date().toISOString(),\n    viewport: session.viewport,\n    comparison,\n    analysis,\n    files: {\n      baseline: paths.baseline,\n      current: paths.current,\n      diff: paths.diff,\n    },\n  };\n\n  if (webViewPort) {\n    report.webViewUrl = `http://localhost:${webViewPort}/sessions/${session.id}`;\n  }\n\n  return report;\n}\n\n/**\n * Get verdict indicator (text-based, no emojis)\n */\nfunction getVerdictIndicator(verdict: string): { symbol: string; label: string } {\n  switch (verdict) {\n    case 'MATCH':\n      return { symbol: '[PASS]', label: 'No visual changes detected' };\n    case 'EXPECTED_CHANGE':\n      return { symbol: '[OK]  ', label: 'Changes detected, appear intentional' };\n    case 'UNEXPECTED_CHANGE':\n      return { symbol: '[WARN]', label: 'Unexpected changes - investigate' };\n    case 'LAYOUT_BROKEN':\n      return { symbol: '[FAIL]', label: 'Layout broken - fix required' };\n    default:\n      return { symbol: '[????]', label: 'Unknown verdict' };\n  }\n}\n\n/**\n * Format report as human-readable text\n */\nexport function formatReportText(report: ComparisonReport): string {\n  const lines: string[] = [];\n  const { symbol, label } = getVerdictIndicator(report.analysis.verdict);\n\n  // Verdict first - most important info\n  lines.push('');\n  lines.push(`${symbol} ${report.analysis.verdict} - ${label}`);\n  lines.push('');\n  lines.push(`Diff: ${report.comparison.diffPercent}% (${report.comparison.diffPixels.toLocaleString()} pixels)`);\n  lines.push('');\n  lines.push('---');\n  lines.push('');\n  lines.push(`Session: ${report.sessionName} (${report.sessionId})`);\n  lines.push(`URL: ${report.url}`);\n  lines.push(`Viewport: ${report.viewport.name} (${report.viewport.width}x${report.viewport.height})`);\n  lines.push('');\n  lines.push(`Summary: ${report.analysis.summary}`);\n\n  if (report.analysis.recommendation) {\n    lines.push('');\n    lines.push(`Recommendation: ${report.analysis.recommendation}`);\n  }\n\n  if (report.analysis.unexpectedChanges.length > 0) {\n    lines.push('');\n    lines.push('Unexpected Changes:');\n    for (const change of report.analysis.unexpectedChanges) {\n      lines.push(`  - ${change.location}: ${change.description}`);\n    }\n  }\n\n  lines.push('');\n  lines.push('Files:');\n  lines.push(`  Baseline: ${report.files.baseline}`);\n  lines.push(`  Current: ${report.files.current}`);\n  lines.push(`  Diff: ${report.files.diff}`);\n\n  if (report.webViewUrl) {\n    lines.push('');\n    lines.push(`View in browser: ${report.webViewUrl}`);\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format report as minimal output (for scripts)\n */\nexport function formatReportMinimal(report: ComparisonReport): string {\n  const status = report.comparison.match ? 'PASS' : 'FAIL';\n  return `${status} ${report.sessionId} ${report.analysis.verdict} ${report.comparison.diffPercent}%`;\n}\n\n/**\n * Format report as JSON\n */\nexport function formatReportJson(report: ComparisonReport): string {\n  return JSON.stringify(report, null, 2);\n}\n\n/**\n * Generate a summary line for session listing\n */\nexport function formatSessionSummary(session: Session): string {\n  const status = session.status.padEnd(8);\n  const viewport = `${session.viewport.name}`.padEnd(8);\n  const date = new Date(session.createdAt).toLocaleDateString();\n\n  let diffInfo = '';\n  if (session.comparison) {\n    diffInfo = session.comparison.match\n      ? ' (no diff)'\n      : ` (${session.comparison.diffPercent}% diff)`;\n  }\n\n  return `${session.id}  ${status}  ${viewport}  ${date}  ${session.name}${diffInfo}`;\n}\n","/**\n * Login Flow\n *\n * Handles common login patterns with semantic field detection.\n */\n\nimport type { Page } from 'playwright';\nimport { findFieldByLabel, findButton, waitForNavigation, type FlowResult, type FlowStep, type FlowOptions } from './types.js';\nimport { detectAuthState } from '../semantic/state-detector.js';\n\nexport interface FlowLoginOptions extends FlowOptions {\n  /** Email or username */\n  email: string;\n  /** Password */\n  password: string;\n  /** What indicates successful login (intent like 'dashboard' or selector) */\n  successIndicator?: string;\n  /** Whether to check \"remember me\" if present */\n  rememberMe?: boolean;\n}\n\nexport interface LoginResult extends FlowResult {\n  /** Whether user is now authenticated */\n  authenticated: boolean;\n  /** Detected username after login */\n  username?: string;\n}\n\n/**\n * Execute login flow\n */\nexport async function loginFlow(\n  page: Page,\n  options: FlowLoginOptions\n): Promise<LoginResult> {\n  const startTime = Date.now();\n  const steps: FlowStep[] = [];\n  const timeout = options.timeout || 30000;\n\n  try {\n    // Step 1: Find email/username field\n    const emailField = await findFieldByLabel(page, [\n      'email',\n      'username',\n      'login',\n      'user',\n      'mail',\n    ]);\n\n    if (!emailField) {\n      return {\n        success: false,\n        authenticated: false,\n        steps,\n        error: 'Could not find email/username field',\n        duration: Date.now() - startTime,\n      };\n    }\n\n    await emailField.fill(options.email);\n    steps.push({ action: 'fill email/username', success: true });\n\n    // Step 2: Find password field\n    const passwordField = await page.$('input[type=\"password\"]');\n\n    if (!passwordField) {\n      return {\n        success: false,\n        authenticated: false,\n        steps,\n        error: 'Could not find password field',\n        duration: Date.now() - startTime,\n      };\n    }\n\n    await passwordField.fill(options.password);\n    steps.push({ action: 'fill password', success: true });\n\n    // Step 3: Handle remember me (optional)\n    if (options.rememberMe) {\n      const rememberCheckbox = await page.$(\n        'input[type=\"checkbox\"][name*=\"remember\"], ' +\n        'input[type=\"checkbox\"][id*=\"remember\"], ' +\n        'label:has-text(\"remember\") input[type=\"checkbox\"]'\n      );\n      if (rememberCheckbox) {\n        await rememberCheckbox.check();\n        steps.push({ action: 'check remember me', success: true });\n      }\n    }\n\n    // Step 4: Find and click submit button\n    const submitButton = await findButton(page, [\n      'login',\n      'sign in',\n      'log in',\n      'submit',\n      'continue',\n    ]);\n\n    if (!submitButton) {\n      return {\n        success: false,\n        authenticated: false,\n        steps,\n        error: 'Could not find submit button',\n        duration: Date.now() - startTime,\n      };\n    }\n\n    await submitButton.click();\n    steps.push({ action: 'click submit', success: true });\n\n    // Step 5: Wait for navigation/response\n    await waitForNavigation(page, timeout);\n    steps.push({ action: 'wait for response', success: true });\n\n    // Step 6: Verify authentication\n    const authState = await detectAuthState(page);\n    const authenticated = authState.authenticated === true;\n\n    // Check for success indicator if provided\n    let successVerified = authenticated;\n    if (options.successIndicator && authenticated) {\n      // Check if it's a selector or an intent\n      if (options.successIndicator.startsWith('.') ||\n          options.successIndicator.startsWith('#') ||\n          options.successIndicator.startsWith('[')) {\n        // It's a selector\n        const indicator = await page.$(options.successIndicator);\n        successVerified = !!indicator;\n      }\n      // For intents, we'd need to check page intent - simplified for now\n    }\n\n    steps.push({\n      action: 'verify authentication',\n      success: successVerified,\n    });\n\n    return {\n      success: successVerified,\n      authenticated: successVerified,\n      username: authState.username,\n      steps,\n      duration: Date.now() - startTime,\n    };\n\n  } catch (error) {\n    return {\n      success: false,\n      authenticated: false,\n      steps,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      duration: Date.now() - startTime,\n    };\n  }\n}\n","/**\n * IBR Built-in Flows\n *\n * Common automation patterns as single commands:\n * - login: Authenticate with email/password\n * - search: Search and verify results\n * - form: Fill and submit forms\n */\n\nexport {\n  loginFlow,\n  type FlowLoginOptions,\n  type LoginResult,\n} from './login.js';\n\nexport {\n  searchFlow,\n  aiSearchFlow,\n  type FlowSearchOptions,\n  type SearchResult,\n} from './search.js';\n\nexport {\n  formFlow,\n  type FlowFormOptions,\n  type FormField,\n  type FormResult,\n} from './form.js';\n\nexport {\n  findFieldByLabel,\n  findButton,\n  waitForNavigation,\n  type FlowResult,\n  type FlowStep,\n  type FlowOptions,\n  type AISearchOptions,\n  type AISearchResult,\n  type StepScreenshot,\n  type ExtractedResult,\n  type SearchTiming,\n} from './types.js';\n\nexport {\n  generateValidationContext,\n  generateValidationPrompt,\n  generateQuickSummary,\n  analyzeForObviousIssues,\n  formatValidationResult,\n  generateDevModePrompt,\n  type ValidationContext,\n  type ValidationResult,\n  type ValidationIssue,\n} from './search-validation.js';\n\n// Flow registry for dynamic access\nimport { loginFlow } from './login.js';\nimport { searchFlow, aiSearchFlow } from './search.js';\nimport { formFlow } from './form.js';\n\nexport const flows = {\n  login: loginFlow,\n  search: searchFlow,\n  aiSearch: aiSearchFlow,\n  form: formFlow,\n} as const;\n\nexport type FlowName = keyof typeof flows;\n","/**\n * Form Submit Flow\n *\n * Handles generic form submission with field detection.\n */\n\nimport type { Page } from 'playwright';\nimport { findFieldByLabel, findButton, waitForNavigation, type FlowResult, type FlowStep, type FlowOptions } from './types.js';\n\nexport interface FormField {\n  /** Field name or label to search for */\n  name: string;\n  /** Value to fill */\n  value: string;\n  /** Field type (defaults to 'text') */\n  type?: 'text' | 'select' | 'checkbox' | 'radio' | 'textarea';\n}\n\nexport interface FlowFormOptions extends FlowOptions {\n  /** Fields to fill */\n  fields: FormField[];\n  /** Button text to click (defaults to 'submit') */\n  submitButton?: string;\n  /** Selector for success message */\n  successSelector?: string;\n}\n\nexport interface FormResult extends FlowResult {\n  /** Which fields were successfully filled */\n  filledFields: string[];\n  /** Which fields failed */\n  failedFields: string[];\n}\n\n/**\n * Execute form submission flow\n */\nexport async function formFlow(\n  page: Page,\n  options: FlowFormOptions\n): Promise<FormResult> {\n  const startTime = Date.now();\n  const steps: FlowStep[] = [];\n  const filledFields: string[] = [];\n  const failedFields: string[] = [];\n  const timeout = options.timeout || 10000;\n\n  try {\n    // Step 1: Fill each field\n    for (const field of options.fields) {\n      const fieldType = field.type || 'text';\n\n      let element;\n\n      if (fieldType === 'textarea') {\n        element = await page.$(`textarea[name*=\"${field.name}\" i], textarea[id*=\"${field.name}\" i]`);\n      } else if (fieldType === 'select') {\n        element = await page.$(`select[name*=\"${field.name}\" i], select[id*=\"${field.name}\" i]`);\n      } else if (fieldType === 'checkbox' || fieldType === 'radio') {\n        element = await page.$(\n          `input[type=\"${fieldType}\"][name*=\"${field.name}\" i], ` +\n          `input[type=\"${fieldType}\"][id*=\"${field.name}\" i]`\n        );\n      } else {\n        element = await findFieldByLabel(page, [field.name]);\n      }\n\n      if (element) {\n        try {\n          if (fieldType === 'select') {\n            await element.selectOption(field.value);\n          } else if (fieldType === 'checkbox') {\n            if (field.value === 'true' || field.value === '1') {\n              await element.check();\n            } else {\n              await element.uncheck();\n            }\n          } else if (fieldType === 'radio') {\n            await element.check();\n          } else {\n            await element.fill(field.value);\n          }\n          filledFields.push(field.name);\n          steps.push({ action: `fill ${field.name}`, success: true });\n        } catch (err) {\n          failedFields.push(field.name);\n          steps.push({\n            action: `fill ${field.name}`,\n            success: false,\n            error: err instanceof Error ? err.message : 'Unknown error',\n          });\n        }\n      } else {\n        failedFields.push(field.name);\n        steps.push({\n          action: `fill ${field.name}`,\n          success: false,\n          error: 'Field not found',\n        });\n      }\n    }\n\n    // Step 2: Submit the form\n    const submitPatterns = options.submitButton\n      ? [options.submitButton]\n      : ['submit', 'save', 'send', 'continue', 'confirm'];\n\n    const submitButton = await findButton(page, submitPatterns);\n\n    if (!submitButton) {\n      return {\n        success: false,\n        filledFields,\n        failedFields,\n        steps,\n        error: 'Could not find submit button',\n        duration: Date.now() - startTime,\n      };\n    }\n\n    await submitButton.click();\n    steps.push({ action: 'click submit', success: true });\n\n    // Step 3: Wait for response\n    await waitForNavigation(page, timeout);\n    steps.push({ action: 'wait for response', success: true });\n\n    // Step 4: Check for success indicator\n    let success = true;\n    if (options.successSelector) {\n      const successElement = await page.$(options.successSelector);\n      success = !!successElement;\n      steps.push({\n        action: 'verify success',\n        success,\n      });\n    }\n\n    // Also check for error indicators\n    const errorElement = await page.$(\n      '[class*=\"error\"]:not([class*=\"error-boundary\"]), ' +\n      '[role=\"alert\"][class*=\"error\"], ' +\n      '.form-error, .validation-error'\n    );\n\n    if (errorElement) {\n      const errorText = await errorElement.textContent();\n      success = false;\n      steps.push({\n        action: 'check for errors',\n        success: false,\n        error: errorText?.trim() || 'Form has errors',\n      });\n    }\n\n    return {\n      success: success && failedFields.length === 0,\n      filledFields,\n      failedFields,\n      steps,\n      duration: Date.now() - startTime,\n    };\n\n  } catch (error) {\n    return {\n      success: false,\n      filledFields,\n      failedFields,\n      steps,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      duration: Date.now() - startTime,\n    };\n  }\n}\n","import { readFile, access } from 'fs/promises';\nimport { join } from 'path';\nimport { listSessions, deleteSession } from './session.js';\nimport type { Session } from './schemas.js';\n\n/**\n * Retention policy configuration\n * Add to .ibrrc.json to enable auto-cleanup\n */\nexport interface RetentionConfig {\n  /** Maximum number of sessions to keep (default: no limit) */\n  maxSessions?: number;\n  /** Maximum age of sessions in days (default: no limit) */\n  maxAgeDays?: number;\n  /** Keep sessions that have failed comparisons (default: true) */\n  keepFailed?: boolean;\n  /** Enable automatic cleanup on session creation (default: false) */\n  autoClean?: boolean;\n}\n\n/**\n * Default retention configuration\n */\nexport const DEFAULT_RETENTION: RetentionConfig = {\n  maxSessions: undefined,\n  maxAgeDays: undefined,\n  keepFailed: true,\n  autoClean: false,\n};\n\n/**\n * Result of retention policy enforcement\n */\nexport interface RetentionResult {\n  /** Sessions that were deleted */\n  deleted: string[];\n  /** Sessions that were kept */\n  kept: string[];\n  /** Sessions kept because they failed (if keepFailed is true) */\n  keptFailed: string[];\n  /** Total sessions before cleanup */\n  totalBefore: number;\n  /** Total sessions after cleanup */\n  totalAfter: number;\n}\n\n/**\n * Load retention config from .ibrrc.json\n */\nexport async function loadRetentionConfig(outputDir: string): Promise<RetentionConfig> {\n  const configPath = join(outputDir, '..', '.ibrrc.json');\n\n  try {\n    await access(configPath);\n    const content = await readFile(configPath, 'utf-8');\n    const config = JSON.parse(content);\n    return {\n      ...DEFAULT_RETENTION,\n      ...config.retention,\n    };\n  } catch {\n    return DEFAULT_RETENTION;\n  }\n}\n\n/**\n * Check if a session should be kept due to failed status\n */\nfunction isFailedSession(session: Session): boolean {\n  return session.analysis?.verdict === 'LAYOUT_BROKEN' ||\n         session.analysis?.verdict === 'UNEXPECTED_CHANGE';\n}\n\n/**\n * Enforce retention policy on sessions\n *\n * @example\n * ```typescript\n * // Enforce with config from .ibrrc.json\n * const result = await enforceRetentionPolicy('./.ibr');\n * console.log(`Deleted ${result.deleted.length} sessions`);\n *\n * // Enforce with explicit config\n * const result = await enforceRetentionPolicy('./.ibr', {\n *   maxSessions: 20,\n *   maxAgeDays: 7,\n *   keepFailed: true\n * });\n * ```\n */\nexport async function enforceRetentionPolicy(\n  outputDir: string,\n  config?: RetentionConfig\n): Promise<RetentionResult> {\n  // Load config if not provided\n  const retentionConfig = config || await loadRetentionConfig(outputDir);\n\n  // If no retention limits set, nothing to do\n  if (!retentionConfig.maxSessions && !retentionConfig.maxAgeDays) {\n    const sessions = await listSessions(outputDir);\n    return {\n      deleted: [],\n      kept: sessions.map(s => s.id),\n      keptFailed: [],\n      totalBefore: sessions.length,\n      totalAfter: sessions.length,\n    };\n  }\n\n  // Get all sessions sorted by creation date (newest first)\n  const sessions = await listSessions(outputDir);\n  const totalBefore = sessions.length;\n\n  const deleted: string[] = [];\n  const kept: string[] = [];\n  const keptFailed: string[] = [];\n\n  // Calculate cutoff time if maxAgeDays is set\n  const cutoffTime = retentionConfig.maxAgeDays\n    ? Date.now() - (retentionConfig.maxAgeDays * 24 * 60 * 60 * 1000)\n    : 0;\n\n  // Track how many non-failed sessions we've kept\n  let keptCount = 0;\n\n  for (const session of sessions) {\n    const sessionTime = new Date(session.createdAt).getTime();\n    const isTooOld = retentionConfig.maxAgeDays && sessionTime < cutoffTime;\n    const isOverLimit = retentionConfig.maxSessions && keptCount >= retentionConfig.maxSessions;\n    const isFailed = isFailedSession(session);\n\n    // Keep failed sessions if configured\n    if (isFailed && retentionConfig.keepFailed) {\n      kept.push(session.id);\n      keptFailed.push(session.id);\n      continue;\n    }\n\n    // Check if session should be deleted\n    if (isTooOld || isOverLimit) {\n      await deleteSession(outputDir, session.id);\n      deleted.push(session.id);\n    } else {\n      kept.push(session.id);\n      keptCount++;\n    }\n  }\n\n  return {\n    deleted,\n    kept,\n    keptFailed,\n    totalBefore,\n    totalAfter: kept.length,\n  };\n}\n\n/**\n * Run auto-cleanup if enabled in config\n * Call this after creating new sessions\n */\nexport async function maybeAutoClean(outputDir: string): Promise<RetentionResult | null> {\n  const config = await loadRetentionConfig(outputDir);\n\n  if (!config.autoClean) {\n    return null;\n  }\n\n  return enforceRetentionPolicy(outputDir, config);\n}\n\n/**\n * Get retention status summary\n */\nexport async function getRetentionStatus(outputDir: string): Promise<{\n  config: RetentionConfig;\n  currentSessions: number;\n  oldestSession: Date | null;\n  newestSession: Date | null;\n  wouldDelete: number;\n}> {\n  const config = await loadRetentionConfig(outputDir);\n  const sessions = await listSessions(outputDir);\n\n  // Calculate how many would be deleted\n  let wouldDelete = 0;\n  const cutoffTime = config.maxAgeDays\n    ? Date.now() - (config.maxAgeDays * 24 * 60 * 60 * 1000)\n    : 0;\n\n  let keptCount = 0;\n  for (const session of sessions) {\n    const sessionTime = new Date(session.createdAt).getTime();\n    const isTooOld = config.maxAgeDays && sessionTime < cutoffTime;\n    const isOverLimit = config.maxSessions && keptCount >= config.maxSessions;\n    const isFailed = isFailedSession(session);\n\n    if (isFailed && config.keepFailed) {\n      continue;\n    }\n\n    if (isTooOld || isOverLimit) {\n      wouldDelete++;\n    } else {\n      keptCount++;\n    }\n  }\n\n  return {\n    config,\n    currentSessions: sessions.length,\n    oldestSession: sessions.length > 0\n      ? new Date(sessions[sessions.length - 1].createdAt)\n      : null,\n    newestSession: sessions.length > 0\n      ? new Date(sessions[0].createdAt)\n      : null,\n    wouldDelete,\n  };\n}\n\n/**\n * Format retention status for display\n */\nexport function formatRetentionStatus(status: Awaited<ReturnType<typeof getRetentionStatus>>): string {\n  const lines: string[] = [];\n\n  lines.push('Session Retention Status');\n  lines.push('========================');\n  lines.push('');\n  lines.push(`Current sessions: ${status.currentSessions}`);\n\n  if (status.oldestSession) {\n    lines.push(`Oldest: ${status.oldestSession.toISOString()}`);\n  }\n  if (status.newestSession) {\n    lines.push(`Newest: ${status.newestSession.toISOString()}`);\n  }\n\n  lines.push('');\n  lines.push('Retention Policy:');\n\n  if (status.config.maxSessions) {\n    lines.push(`  Max sessions: ${status.config.maxSessions}`);\n  } else {\n    lines.push('  Max sessions: unlimited');\n  }\n\n  if (status.config.maxAgeDays) {\n    lines.push(`  Max age: ${status.config.maxAgeDays} days`);\n  } else {\n    lines.push('  Max age: unlimited');\n  }\n\n  lines.push(`  Keep failed: ${status.config.keepFailed ? 'yes' : 'no'}`);\n  lines.push(`  Auto-clean: ${status.config.autoClean ? 'enabled' : 'disabled'}`);\n\n  if (status.wouldDelete > 0) {\n    lines.push('');\n    lines.push(`‚ö†Ô∏è  ${status.wouldDelete} session(s) would be deleted if cleanup runs`);\n  } else {\n    lines.push('');\n    lines.push('‚úì All sessions within retention policy');\n  }\n\n  return lines.join('\\n');\n}\n","import { nanoid } from 'nanoid';\nimport { readFile, writeFile, mkdir } from 'fs/promises';\nimport { join, dirname } from 'path';\n\nconst OPERATION_PREFIX = 'op_';\n\n/**\n * Pending operation types\n */\nexport type OperationType = 'screenshot' | 'type' | 'click' | 'navigate' | 'evaluate' | 'fill' | 'hover' | 'wait';\n\n/**\n * A pending operation that's currently running\n */\nexport interface PendingOperation {\n  id: string;\n  type: OperationType;\n  sessionId: string;\n  startedAt: string;\n  pid: number;\n  command?: string;\n}\n\n/**\n * State file structure\n */\nexport interface OperationState {\n  pending: PendingOperation[];\n  lastUpdated: string;\n}\n\n/**\n * Get the path to the operations state file\n */\nfunction getOperationsPath(outputDir: string): string {\n  return join(outputDir, 'operations.json');\n}\n\n/**\n * Read the current operation state\n */\nasync function readState(outputDir: string): Promise<OperationState> {\n  const path = getOperationsPath(outputDir);\n  try {\n    const content = await readFile(path, 'utf-8');\n    return JSON.parse(content) as OperationState;\n  } catch {\n    return { pending: [], lastUpdated: new Date().toISOString() };\n  }\n}\n\n/**\n * Write the operation state\n */\nasync function writeState(outputDir: string, state: OperationState): Promise<void> {\n  const path = getOperationsPath(outputDir);\n  await mkdir(dirname(path), { recursive: true });\n  state.lastUpdated = new Date().toISOString();\n  await writeFile(path, JSON.stringify(state, null, 2));\n}\n\n/**\n * Register a new pending operation\n * Returns the operation ID\n */\nexport async function registerOperation(\n  outputDir: string,\n  options: {\n    type: OperationType;\n    sessionId: string;\n    command?: string;\n  }\n): Promise<string> {\n  const state = await readState(outputDir);\n\n  // Clean up stale operations from dead processes\n  state.pending = await cleanupStaleOperations(state.pending);\n\n  const operation: PendingOperation = {\n    id: `${OPERATION_PREFIX}${nanoid(8)}`,\n    type: options.type,\n    sessionId: options.sessionId,\n    startedAt: new Date().toISOString(),\n    pid: process.pid,\n    command: options.command,\n  };\n\n  state.pending.push(operation);\n  await writeState(outputDir, state);\n\n  return operation.id;\n}\n\n/**\n * Mark an operation as complete (remove from pending)\n */\nexport async function completeOperation(\n  outputDir: string,\n  operationId: string\n): Promise<void> {\n  const state = await readState(outputDir);\n  state.pending = state.pending.filter(op => op.id !== operationId);\n  await writeState(outputDir, state);\n}\n\n/**\n * Get all pending operations\n */\nexport async function getPendingOperations(\n  outputDir: string\n): Promise<PendingOperation[]> {\n  const state = await readState(outputDir);\n  // Clean up stale operations before returning\n  const activeOps = await cleanupStaleOperations(state.pending);\n\n  // Update state if we cleaned up anything\n  if (activeOps.length !== state.pending.length) {\n    state.pending = activeOps;\n    await writeState(outputDir, state);\n  }\n\n  return activeOps;\n}\n\n/**\n * Check if a process is still running\n */\nfunction isProcessAlive(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Remove operations from dead processes\n */\nasync function cleanupStaleOperations(\n  operations: PendingOperation[]\n): Promise<PendingOperation[]> {\n  return operations.filter(op => isProcessAlive(op.pid));\n}\n\n/**\n * Wait for all pending operations to complete\n * Returns true if all completed, false if timeout reached\n */\nexport async function waitForCompletion(\n  outputDir: string,\n  options: {\n    timeout?: number;\n    pollInterval?: number;\n    onProgress?: (remaining: number) => void;\n  } = {}\n): Promise<boolean> {\n  const timeout = options.timeout ?? 30000;\n  const pollInterval = options.pollInterval ?? 500;\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeout) {\n    const pending = await getPendingOperations(outputDir);\n\n    if (pending.length === 0) {\n      return true;\n    }\n\n    if (options.onProgress) {\n      options.onProgress(pending.length);\n    }\n\n    await new Promise(resolve => setTimeout(resolve, pollInterval));\n  }\n\n  return false;\n}\n\n/**\n * Format pending operations for display\n */\nexport function formatPendingOperations(operations: PendingOperation[]): string {\n  if (operations.length === 0) {\n    return 'No pending operations';\n  }\n\n  const lines = operations.map(op => {\n    const age = Math.round((Date.now() - new Date(op.startedAt).getTime()) / 1000);\n    return `  ${op.id.slice(0, 11)} | ${op.type.padEnd(10)} | ${op.sessionId.slice(0, 12)} | ${age}s`;\n  });\n\n  return [\n    '  ID          | Type       | Session      | Age',\n    '  ----------- | ---------- | ------------ | ---',\n    ...lines,\n  ].join('\\n');\n}\n\n/**\n * Higher-order function to wrap an async operation with tracking\n */\nexport function withOperationTracking<T>(\n  outputDir: string,\n  options: {\n    type: OperationType;\n    sessionId: string;\n    command?: string;\n  }\n) {\n  return async (fn: () => Promise<T>): Promise<T> => {\n    const opId = await registerOperation(outputDir, options);\n    try {\n      return await fn();\n    } finally {\n      await completeOperation(outputDir, opId);\n    }\n  };\n}\n","import { chromium, type Page, type Browser } from 'playwright';\nimport { VIEWPORTS, type Viewport } from './schemas.js';\n\n/**\n * Layout issue detected during responsive testing\n */\nexport interface LayoutIssue {\n  element: string;\n  issue: 'overflow' | 'hidden' | 'truncated' | 'overlap' | 'too-small' | 'off-screen';\n  description: string;\n  bounds: { x: number; y: number; width: number; height: number };\n}\n\n/**\n * Touch target analysis\n */\nexport interface TouchTargetIssue {\n  element: string;\n  selector: string;\n  size: { width: number; height: number };\n  minimumSize: number;\n  isTooSmall: boolean;\n}\n\n/**\n * Text readability issue\n */\nexport interface TextIssue {\n  element: string;\n  issue: 'too-small' | 'low-contrast';\n  fontSize?: number;\n  contrastRatio?: number;\n}\n\n/**\n * Single viewport test result\n */\nexport interface ViewportResult {\n  viewport: Viewport;\n  viewportName: string;\n  layoutIssues: LayoutIssue[];\n  touchTargets: TouchTargetIssue[];\n  textIssues: TextIssue[];\n  screenshot?: string;\n}\n\n/**\n * Full responsive test result\n */\nexport interface ResponsiveResult {\n  url: string;\n  results: ViewportResult[];\n  summary: {\n    totalIssues: number;\n    viewportsWithIssues: number;\n    criticalIssues: number;\n  };\n}\n\n/**\n * Responsive test options\n */\nexport interface ResponsiveTestOptions {\n  /** Viewports to test. Defaults to desktop, tablet, mobile */\n  viewports?: Array<'desktop' | 'tablet' | 'mobile' | Viewport>;\n  /** Capture screenshots for each viewport */\n  captureScreenshots?: boolean;\n  /** Output directory for screenshots */\n  outputDir?: string;\n  /** Minimum touch target size (default: 44px per WCAG) */\n  minTouchTarget?: number;\n  /** Minimum font size (default: 12px) */\n  minFontSize?: number;\n  /** Timeout for page load */\n  timeout?: number;\n}\n\n/**\n * Test responsive behavior across multiple viewports\n */\nexport async function testResponsive(\n  url: string,\n  options: ResponsiveTestOptions = {}\n): Promise<ResponsiveResult> {\n  const {\n    viewports = ['desktop', 'tablet', 'mobile'],\n    captureScreenshots = false,\n    outputDir = './.ibr/responsive',\n    minTouchTarget = 44,\n    minFontSize = 12,\n    timeout = 30000,\n  } = options;\n\n  const results: ViewportResult[] = [];\n  let browser: Browser | null = null;\n\n  try {\n    browser = await chromium.launch({ headless: true });\n\n    for (const viewportSpec of viewports) {\n      // Resolve viewport\n      let viewport: Viewport;\n      let viewportName: string;\n\n      if (typeof viewportSpec === 'string') {\n        viewport = VIEWPORTS[viewportSpec];\n        viewportName = viewportSpec;\n      } else {\n        viewport = viewportSpec;\n        viewportName = `${viewportSpec.width}x${viewportSpec.height}`;\n      }\n\n      const context = await browser.newContext({\n        viewport: { width: viewport.width, height: viewport.height },\n        reducedMotion: 'reduce',\n      });\n\n      const page = await context.newPage();\n\n      try {\n        await page.goto(url, {\n          waitUntil: 'networkidle',\n          timeout,\n        });\n\n        // Wait for animations\n        await page.waitForTimeout(500);\n\n        // Run viewport-specific tests\n        const result = await analyzeViewport(page, viewport, viewportName, {\n          minTouchTarget,\n          minFontSize,\n        });\n\n        // Capture screenshot if requested\n        if (captureScreenshots) {\n          const { mkdir } = await import('fs/promises');\n          await mkdir(outputDir, { recursive: true });\n          const screenshotPath = `${outputDir}/${viewportName}.png`;\n          await page.screenshot({ path: screenshotPath, fullPage: true });\n          result.screenshot = screenshotPath;\n        }\n\n        results.push(result);\n      } finally {\n        await context.close();\n      }\n    }\n  } finally {\n    if (browser) {\n      await browser.close();\n    }\n  }\n\n  // Calculate summary\n  const totalIssues = results.reduce(\n    (sum, r) => sum + r.layoutIssues.length + r.touchTargets.filter(t => t.isTooSmall).length + r.textIssues.length,\n    0\n  );\n  const viewportsWithIssues = results.filter(\n    r => r.layoutIssues.length > 0 || r.touchTargets.some(t => t.isTooSmall) || r.textIssues.length > 0\n  ).length;\n  const criticalIssues = results.reduce(\n    (sum, r) => sum + r.layoutIssues.filter(i => i.issue === 'overflow' || i.issue === 'hidden').length,\n    0\n  );\n\n  return {\n    url,\n    results,\n    summary: {\n      totalIssues,\n      viewportsWithIssues,\n      criticalIssues,\n    },\n  };\n}\n\n/**\n * Analyze a single viewport for responsive issues\n */\nasync function analyzeViewport(\n  page: Page,\n  viewport: Viewport,\n  viewportName: string,\n  options: { minTouchTarget: number; minFontSize: number }\n): Promise<ViewportResult> {\n  const isMobile = viewport.width < 768;\n\n  const analysisResult = await page.evaluate(({ viewportWidth, minTouchTarget, minFontSize, isMobile }) => {\n    const layoutIssues: LayoutIssue[] = [];\n    const touchTargets: TouchTargetIssue[] = [];\n    const textIssues: TextIssue[] = [];\n\n    // Helper to get unique selector\n    function getSelector(el: Element): string {\n      if ((el as HTMLElement).id) return `#${(el as HTMLElement).id}`;\n      const classes = Array.from(el.classList).slice(0, 2).join('.');\n      const tag = el.tagName.toLowerCase();\n      if (classes) return `${tag}.${classes}`;\n      return tag;\n    }\n\n    // Check for horizontal overflow\n    const bodyWidth = document.body.scrollWidth;\n    if (bodyWidth > viewportWidth) {\n      layoutIssues.push({\n        element: 'body',\n        issue: 'overflow',\n        description: `Page has horizontal overflow (${bodyWidth}px > ${viewportWidth}px viewport)`,\n        bounds: { x: 0, y: 0, width: bodyWidth, height: document.body.scrollHeight },\n      });\n    }\n\n    // Check all elements for layout issues\n    const allElements = Array.from(document.querySelectorAll('*'));\n    for (const el of allElements) {\n      const rect = el.getBoundingClientRect();\n      const style = window.getComputedStyle(el);\n\n      // Skip invisible elements\n      if (style.display === 'none' || style.visibility === 'hidden' || rect.width === 0 || rect.height === 0) {\n        continue;\n      }\n\n      // Check for elements extending beyond viewport\n      if (rect.right > viewportWidth + 10) { // 10px tolerance\n        layoutIssues.push({\n          element: getSelector(el),\n          issue: 'overflow',\n          description: `Element extends ${Math.round(rect.right - viewportWidth)}px beyond viewport`,\n          bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n        });\n      }\n\n      // Check for truncated text (text-overflow: ellipsis with overflow)\n      if (style.textOverflow === 'ellipsis' && style.overflow === 'hidden') {\n        const scrollWidth = (el as HTMLElement).scrollWidth;\n        const clientWidth = (el as HTMLElement).clientWidth;\n        if (scrollWidth > clientWidth) {\n          layoutIssues.push({\n            element: getSelector(el),\n            issue: 'truncated',\n            description: 'Text is truncated with ellipsis',\n            bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n          });\n        }\n      }\n    }\n\n    // Check touch targets (only on mobile-sized viewports)\n    if (isMobile) {\n      const interactiveElements = Array.from(document.querySelectorAll(\n        'a, button, [role=\"button\"], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n      ));\n\n      for (const el of interactiveElements) {\n        const rect = el.getBoundingClientRect();\n        const style = window.getComputedStyle(el);\n\n        if (style.display === 'none' || style.visibility === 'hidden') {\n          continue;\n        }\n\n        const width = rect.width;\n        const height = rect.height;\n        const isTooSmall = width < minTouchTarget || height < minTouchTarget;\n\n        touchTargets.push({\n          element: el.textContent?.trim().slice(0, 30) || getSelector(el),\n          selector: getSelector(el),\n          size: { width: Math.round(width), height: Math.round(height) },\n          minimumSize: minTouchTarget,\n          isTooSmall,\n        });\n      }\n    }\n\n    // Check text sizes\n    const textElements = Array.from(document.querySelectorAll('p, span, a, li, td, th, label, h1, h2, h3, h4, h5, h6'));\n    for (const el of textElements) {\n      const style = window.getComputedStyle(el);\n      const fontSize = parseFloat(style.fontSize);\n\n      if (fontSize < minFontSize && el.textContent?.trim()) {\n        textIssues.push({\n          element: getSelector(el),\n          issue: 'too-small',\n          fontSize: Math.round(fontSize),\n        });\n      }\n    }\n\n    return { layoutIssues, touchTargets, textIssues };\n  }, {\n    viewportWidth: viewport.width,\n    minTouchTarget: options.minTouchTarget,\n    minFontSize: options.minFontSize,\n    isMobile,\n  });\n\n  return {\n    viewport,\n    viewportName,\n    ...analysisResult,\n  };\n}\n\n/**\n * Format responsive test result for console output\n */\nexport function formatResponsiveResult(result: ResponsiveResult): string {\n  const lines: string[] = [];\n\n  lines.push('Responsive Test Results');\n  lines.push('=======================');\n  lines.push('');\n  lines.push(`URL: ${result.url}`);\n  lines.push(`Viewports tested: ${result.results.length}`);\n  lines.push('');\n\n  // Summary\n  const icon = result.summary.criticalIssues > 0 ? '\\x1b[31m‚úó\\x1b[0m' :\n               result.summary.totalIssues > 0 ? '\\x1b[33m!\\x1b[0m' : '\\x1b[32m‚úì\\x1b[0m';\n  lines.push(`${icon} Total issues: ${result.summary.totalIssues}`);\n  lines.push(`   Critical: ${result.summary.criticalIssues}`);\n  lines.push(`   Viewports with issues: ${result.summary.viewportsWithIssues}/${result.results.length}`);\n  lines.push('');\n\n  // Per-viewport results\n  for (const vr of result.results) {\n    const issueCount = vr.layoutIssues.length +\n                       vr.touchTargets.filter(t => t.isTooSmall).length +\n                       vr.textIssues.length;\n\n    const vpIcon = issueCount === 0 ? '\\x1b[32m‚úì\\x1b[0m' : '\\x1b[33m!\\x1b[0m';\n    lines.push(`${vpIcon} ${vr.viewportName} (${vr.viewport.width}x${vr.viewport.height})`);\n\n    if (issueCount === 0) {\n      lines.push('   No issues detected');\n    } else {\n      // Layout issues\n      if (vr.layoutIssues.length > 0) {\n        lines.push('   Layout issues:');\n        for (const issue of vr.layoutIssues.slice(0, 5)) {\n          lines.push(`     ! ${issue.issue}: ${issue.description}`);\n        }\n        if (vr.layoutIssues.length > 5) {\n          lines.push(`     ... and ${vr.layoutIssues.length - 5} more`);\n        }\n      }\n\n      // Touch targets\n      const smallTargets = vr.touchTargets.filter(t => t.isTooSmall);\n      if (smallTargets.length > 0) {\n        lines.push('   Small touch targets:');\n        for (const target of smallTargets.slice(0, 5)) {\n          lines.push(`     ! \"${target.element}\" is ${target.size.width}x${target.size.height}px (min: ${target.minimumSize}px)`);\n        }\n        if (smallTargets.length > 5) {\n          lines.push(`     ... and ${smallTargets.length - 5} more`);\n        }\n      }\n\n      // Text issues\n      if (vr.textIssues.length > 0) {\n        lines.push('   Text issues:');\n        for (const issue of vr.textIssues.slice(0, 5)) {\n          lines.push(`     ! ${issue.element}: ${issue.issue} (${issue.fontSize}px)`);\n        }\n        if (vr.textIssues.length > 5) {\n          lines.push(`     ... and ${vr.textIssues.length - 5} more`);\n        }\n      }\n    }\n\n    if (vr.screenshot) {\n      lines.push(`   Screenshot: ${vr.screenshot}`);\n    }\n\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n","import { nanoid } from 'nanoid';\nimport { mkdir, readFile, appendFile, readdir, stat } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\nimport {\n  DecisionEntrySchema,\n  type DecisionEntry,\n  type DecisionType,\n  type DecisionState,\n} from './context/types.js';\n\nconst CONTEXT_DIR = 'context';\nconst DECISIONS_DIR = 'decisions';\n\n/**\n * Options for recording a UI decision\n */\nexport interface RecordDecisionOptions {\n  route: string;\n  type: DecisionType;\n  description: string;\n  component?: string;\n  rationale?: string;\n  before?: DecisionState;\n  after?: DecisionState;\n  files_changed: string[];\n  session_id?: string;\n}\n\n/**\n * Options for querying decisions\n */\nexport interface QueryDecisionsOptions {\n  route?: string;\n  component?: string;\n  type?: DecisionType;\n  since?: string; // ISO 8601 timestamp\n  limit?: number;\n}\n\n/**\n * Get the decisions directory path\n */\nfunction getDecisionsDir(outputDir: string): string {\n  return join(outputDir, CONTEXT_DIR, DECISIONS_DIR);\n}\n\n/**\n * Sanitize a route path into a safe filename\n */\nfunction routeToFilename(route: string): string {\n  return route\n    .replace(/^\\/+/, '')\n    .replace(/\\//g, '_')\n    .replace(/[^a-zA-Z0-9_-]/g, '')\n    || '_root';\n}\n\n/**\n * Get the JSONL file path for a route\n */\nfunction getRouteLogPath(outputDir: string, route: string): string {\n  const filename = `${routeToFilename(route)}.jsonl`;\n  return join(getDecisionsDir(outputDir), filename);\n}\n\n/**\n * Ensure the context directories exist\n */\nasync function ensureContextDirs(outputDir: string): Promise<void> {\n  await mkdir(getDecisionsDir(outputDir), { recursive: true });\n}\n\n/**\n * Record a UI decision to the JSONL log for its route\n */\nexport async function recordDecision(\n  outputDir: string,\n  options: RecordDecisionOptions\n): Promise<DecisionEntry> {\n  await ensureContextDirs(outputDir);\n\n  const entry: DecisionEntry = {\n    id: `dec_${nanoid(10)}`,\n    timestamp: new Date().toISOString(),\n    route: options.route,\n    component: options.component,\n    type: options.type,\n    description: options.description,\n    rationale: options.rationale,\n    before: options.before,\n    after: options.after,\n    files_changed: options.files_changed,\n    session_id: options.session_id,\n  };\n\n  // Validate the entry\n  DecisionEntrySchema.parse(entry);\n\n  // Append to route-specific JSONL file\n  const logPath = getRouteLogPath(outputDir, options.route);\n  await appendFile(logPath, JSON.stringify(entry) + '\\n');\n\n  return entry;\n}\n\n/**\n * Read all decisions from a route's JSONL log\n */\nexport async function getDecisionsByRoute(\n  outputDir: string,\n  route: string\n): Promise<DecisionEntry[]> {\n  const logPath = getRouteLogPath(outputDir, route);\n\n  if (!existsSync(logPath)) {\n    return [];\n  }\n\n  const content = await readFile(logPath, 'utf-8');\n  const lines = content.trim().split('\\n').filter(Boolean);\n\n  return lines.map(line => DecisionEntrySchema.parse(JSON.parse(line)));\n}\n\n/**\n * Query decisions across all routes with filtering\n */\nexport async function queryDecisions(\n  outputDir: string,\n  options: QueryDecisionsOptions = {}\n): Promise<DecisionEntry[]> {\n  const { route, component, type, since, limit = 50 } = options;\n\n  let decisions: DecisionEntry[] = [];\n\n  if (route) {\n    // Query specific route\n    decisions = await getDecisionsByRoute(outputDir, route);\n  } else {\n    // Query all routes\n    const decisionsDir = getDecisionsDir(outputDir);\n    if (!existsSync(decisionsDir)) {\n      return [];\n    }\n\n    const files = await readdir(decisionsDir);\n    for (const file of files) {\n      if (!file.endsWith('.jsonl')) continue;\n\n      const filePath = join(decisionsDir, file);\n      const content = await readFile(filePath, 'utf-8');\n      const lines = content.trim().split('\\n').filter(Boolean);\n\n      for (const line of lines) {\n        decisions.push(DecisionEntrySchema.parse(JSON.parse(line)));\n      }\n    }\n  }\n\n  // Apply filters\n  if (component) {\n    decisions = decisions.filter(d => d.component === component);\n  }\n  if (type) {\n    decisions = decisions.filter(d => d.type === type);\n  }\n  if (since) {\n    const sinceTime = new Date(since).getTime();\n    decisions = decisions.filter(d => new Date(d.timestamp).getTime() >= sinceTime);\n  }\n\n  // Sort by timestamp descending (newest first)\n  decisions.sort((a, b) =>\n    new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n  );\n\n  return decisions.slice(0, limit);\n}\n\n/**\n * Get a single decision by ID (searches all route logs)\n */\nexport async function getDecision(\n  outputDir: string,\n  decisionId: string\n): Promise<DecisionEntry | null> {\n  const decisionsDir = getDecisionsDir(outputDir);\n  if (!existsSync(decisionsDir)) {\n    return null;\n  }\n\n  const files = await readdir(decisionsDir);\n  for (const file of files) {\n    if (!file.endsWith('.jsonl')) continue;\n\n    const filePath = join(decisionsDir, file);\n    const content = await readFile(filePath, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n\n    for (const line of lines) {\n      const entry = DecisionEntrySchema.parse(JSON.parse(line));\n      if (entry.id === decisionId) {\n        return entry;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get list of routes that have decision logs\n */\nexport async function getTrackedRoutes(outputDir: string): Promise<string[]> {\n  const decisionsDir = getDecisionsDir(outputDir);\n  if (!existsSync(decisionsDir)) {\n    return [];\n  }\n\n  const files = await readdir(decisionsDir);\n  return files\n    .filter(f => f.endsWith('.jsonl'))\n    .map(f => f.replace('.jsonl', '').replace(/_/g, '/').replace(/^\\/?/, '/'));\n}\n\n/**\n * Get decision counts by route\n */\nexport async function getDecisionStats(outputDir: string): Promise<{\n  total: number;\n  byRoute: Record<string, number>;\n  byType: Record<string, number>;\n}> {\n  const all = await queryDecisions(outputDir, { limit: 10000 });\n\n  const byRoute: Record<string, number> = {};\n  const byType: Record<string, number> = {};\n\n  for (const d of all) {\n    byRoute[d.route] = (byRoute[d.route] || 0) + 1;\n    byType[d.type] = (byType[d.type] || 0) + 1;\n  }\n\n  return { total: all.length, byRoute, byType };\n}\n\n/**\n * Get the size of the decisions directory in bytes\n */\nexport async function getDecisionsSize(outputDir: string): Promise<number> {\n  const decisionsDir = getDecisionsDir(outputDir);\n  if (!existsSync(decisionsDir)) {\n    return 0;\n  }\n\n  const files = await readdir(decisionsDir);\n  let total = 0;\n\n  for (const file of files) {\n    if (!file.endsWith('.jsonl')) continue;\n    const s = await stat(join(decisionsDir, file));\n    total += s.size;\n  }\n\n  return total;\n}\n","import { z } from 'zod';\n\n/**\n * Types of UI decisions that can be tracked\n */\nexport const DecisionTypeSchema = z.enum([\n  'css_change',\n  'layout_change',\n  'color_change',\n  'spacing_change',\n  'component_add',\n  'component_remove',\n  'component_modify',\n  'content_change',\n]);\n\n/**\n * Before/after state snapshot for a decision\n */\nexport const DecisionStateSchema = z.object({\n  css: z.record(z.string(), z.string()).optional(),\n  html_snippet: z.string().optional(),\n  screenshot_ref: z.string().optional(),\n});\n\n/**\n * A single UI decision entry stored in JSONL logs\n */\nexport const DecisionEntrySchema = z.object({\n  id: z.string(),\n  timestamp: z.string().datetime(),\n  route: z.string(),\n  component: z.string().optional(),\n  type: DecisionTypeSchema,\n  description: z.string(),\n  rationale: z.string().optional(),\n  before: DecisionStateSchema.optional(),\n  after: DecisionStateSchema.optional(),\n  files_changed: z.array(z.string()),\n  session_id: z.string().optional(),\n});\n\n/**\n * Route-level decision summary for compact context\n */\nexport const DecisionSummarySchema = z.object({\n  route: z.string(),\n  component: z.string().optional(),\n  latest_change: z.string(),\n  decision_count: z.number(),\n  full_log_ref: z.string(),\n});\n\n/**\n * Current UI state tracking in compact context\n */\nexport const CurrentUIStateSchema = z.object({\n  last_snapshot_ref: z.string().optional(),\n  pending_verifications: z.number(),\n  known_issues: z.array(z.string()),\n});\n\n/**\n * Compact context ‚Äî always-loaded LLM-friendly summary (<4KB target)\n */\nexport const CompactContextSchema = z.object({\n  version: z.literal(1),\n  session_id: z.string(),\n  updated_at: z.string().datetime(),\n  active_route: z.string().optional(),\n  decisions_summary: z.array(DecisionSummarySchema),\n  current_ui_state: CurrentUIStateSchema,\n  preferences_active: z.number(),\n});\n\n/**\n * Request to compact current context\n */\nexport const CompactionRequestSchema = z.object({\n  reason: z.enum(['session_ending', 'context_limit', 'manual']),\n  preserve_decisions: z.array(z.string()).optional(),\n});\n\n/**\n * Result of context compaction\n */\nexport const CompactionResultSchema = z.object({\n  compact_context: CompactContextSchema,\n  archived_to: z.string(),\n  decisions_compacted: z.number(),\n  decisions_preserved: z.number(),\n});\n\n// Type exports\nexport type DecisionType = z.infer<typeof DecisionTypeSchema>;\nexport type DecisionState = z.infer<typeof DecisionStateSchema>;\nexport type DecisionEntry = z.infer<typeof DecisionEntrySchema>;\nexport type DecisionSummary = z.infer<typeof DecisionSummarySchema>;\nexport type CurrentUIState = z.infer<typeof CurrentUIStateSchema>;\nexport type CompactContext = z.infer<typeof CompactContextSchema>;\nexport type CompactionRequest = z.infer<typeof CompactionRequestSchema>;\nexport type CompactionResult = z.infer<typeof CompactionResultSchema>;\n","import { mkdir, readFile, writeFile } from 'fs/promises';\nimport { join } from 'path';\nimport { existsSync } from 'fs';\nimport { nanoid } from 'nanoid';\nimport {\n  CompactContextSchema,\n  type CompactContext,\n  type CompactionRequest,\n  type CompactionResult,\n  type DecisionSummary,\n} from './types.js';\nimport { queryDecisions, getTrackedRoutes } from '../decision-tracker.js';\n\nconst CONTEXT_DIR = 'context';\nconst COMPACT_FILE = 'compact.json';\nconst ARCHIVE_DIR = 'archive';\n\n/**\n * Get path to compact context file\n */\nfunction getCompactPath(outputDir: string): string {\n  return join(outputDir, CONTEXT_DIR, COMPACT_FILE);\n}\n\n/**\n * Get path to archive directory\n */\nfunction getArchiveDir(outputDir: string): string {\n  return join(outputDir, CONTEXT_DIR, ARCHIVE_DIR);\n}\n\n/**\n * Load the current compact context, or create a default one\n */\nexport async function loadCompactContext(\n  outputDir: string,\n  sessionId?: string\n): Promise<CompactContext> {\n  const compactPath = getCompactPath(outputDir);\n\n  if (existsSync(compactPath)) {\n    const content = await readFile(compactPath, 'utf-8');\n    return CompactContextSchema.parse(JSON.parse(content));\n  }\n\n  // Return empty default\n  return {\n    version: 1,\n    session_id: sessionId || `ctx_${nanoid(8)}`,\n    updated_at: new Date().toISOString(),\n    active_route: undefined,\n    decisions_summary: [],\n    current_ui_state: {\n      last_snapshot_ref: undefined,\n      pending_verifications: 0,\n      known_issues: [],\n    },\n    preferences_active: 0,\n  };\n}\n\n/**\n * Save compact context to disk\n */\nexport async function saveCompactContext(\n  outputDir: string,\n  context: CompactContext\n): Promise<void> {\n  const contextDir = join(outputDir, CONTEXT_DIR);\n  await mkdir(contextDir, { recursive: true });\n\n  const compactPath = getCompactPath(outputDir);\n  await writeFile(compactPath, JSON.stringify(context, null, 2));\n}\n\n/**\n * Update compact context with latest decisions from logs\n * Rebuilds the decisions_summary from the JSONL decision logs\n */\nexport async function updateCompactContext(\n  outputDir: string,\n  sessionId?: string\n): Promise<CompactContext> {\n  const current = await loadCompactContext(outputDir, sessionId);\n  const routes = await getTrackedRoutes(outputDir);\n\n  const summaries: DecisionSummary[] = [];\n\n  for (const route of routes) {\n    const decisions = await queryDecisions(outputDir, { route, limit: 100 });\n\n    if (decisions.length === 0) continue;\n\n    // Group by component\n    const byComponent = new Map<string, typeof decisions>();\n    for (const d of decisions) {\n      const key = d.component || '_page';\n      if (!byComponent.has(key)) {\n        byComponent.set(key, []);\n      }\n      byComponent.get(key)!.push(d);\n    }\n\n    for (const [component, componentDecisions] of byComponent) {\n      const latest = componentDecisions[0]; // Already sorted newest first\n      const routeFilename = route\n        .replace(/^\\/+/, '')\n        .replace(/\\//g, '_')\n        .replace(/[^a-zA-Z0-9_-]/g, '')\n        || '_root';\n\n      summaries.push({\n        route,\n        component: component === '_page' ? undefined : component,\n        latest_change: latest.description,\n        decision_count: componentDecisions.length,\n        full_log_ref: `.ibr/context/decisions/${routeFilename}.jsonl`,\n      });\n    }\n  }\n\n  const updated: CompactContext = {\n    ...current,\n    session_id: sessionId || current.session_id,\n    updated_at: new Date().toISOString(),\n    decisions_summary: summaries,\n  };\n\n  await saveCompactContext(outputDir, updated);\n  return updated;\n}\n\n/**\n * Compact and archive current context\n */\nexport async function compactContext(\n  outputDir: string,\n  request: CompactionRequest\n): Promise<CompactionResult> {\n  const current = await loadCompactContext(outputDir);\n  const archiveDir = getArchiveDir(outputDir);\n  await mkdir(archiveDir, { recursive: true });\n\n  // Archive current compact context\n  const archiveFilename = `compact_${Date.now()}.json`;\n  const archivePath = join(archiveDir, archiveFilename);\n  await writeFile(archivePath, JSON.stringify(current, null, 2));\n\n  // Count decisions being compacted\n  const decisionsCompacted = current.decisions_summary.reduce(\n    (sum, s) => sum + s.decision_count,\n    0\n  );\n\n  // Rebuild compact context (preserving route summaries when preserve list is provided)\n  const hasPreserves = (request.preserve_decisions || []).length > 0;\n  const preserved = hasPreserves ? current.decisions_summary : [];\n\n  const newContext: CompactContext = {\n    version: 1,\n    session_id: current.session_id,\n    updated_at: new Date().toISOString(),\n    active_route: current.active_route,\n    decisions_summary: preserved,\n    current_ui_state: {\n      last_snapshot_ref: current.current_ui_state.last_snapshot_ref,\n      pending_verifications: 0,\n      known_issues: [],\n    },\n    preferences_active: current.preferences_active,\n  };\n\n  await saveCompactContext(outputDir, newContext);\n\n  return {\n    compact_context: newContext,\n    archived_to: archivePath,\n    decisions_compacted: decisionsCompacted,\n    decisions_preserved: preserved.length,\n  };\n}\n\n/**\n * Set the active route being worked on\n */\nexport async function setActiveRoute(\n  outputDir: string,\n  route: string\n): Promise<CompactContext> {\n  const current = await loadCompactContext(outputDir);\n  const updated: CompactContext = {\n    ...current,\n    active_route: route,\n    updated_at: new Date().toISOString(),\n  };\n  await saveCompactContext(outputDir, updated);\n  return updated;\n}\n\n/**\n * Add a known issue to the UI state\n */\nexport async function addKnownIssue(\n  outputDir: string,\n  issue: string\n): Promise<CompactContext> {\n  const current = await loadCompactContext(outputDir);\n  const issues = [...current.current_ui_state.known_issues, issue];\n  const updated: CompactContext = {\n    ...current,\n    current_ui_state: {\n      ...current.current_ui_state,\n      known_issues: issues,\n    },\n    updated_at: new Date().toISOString(),\n  };\n  await saveCompactContext(outputDir, updated);\n  return updated;\n}\n\n/**\n * Check if compact context exceeds the 4KB target\n */\nexport async function isCompactContextOversize(\n  outputDir: string\n): Promise<boolean> {\n  const compactPath = getCompactPath(outputDir);\n  if (!existsSync(compactPath)) return false;\n\n  const content = await readFile(compactPath, 'utf-8');\n  return Buffer.byteLength(content, 'utf-8') > 4096;\n}\n"],"mappings":"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","names":["browser","resolve","patterns","placeholder","import_playwright","import_promises","import_path","pixelmatch","import_promises","import_path","import_promises","import_path","import_promises","import_path","init_types","path","selector","import_promises","import_path","init_types","path","browser","import_playwright","browser","path","page","import_playwright","stat","resolve","resolve","path","rules","import_promises","import_fs","import_path","import_nanoid","rules","loadSummary","createMemoryPreset","import_promises","import_fs","import_path","closeBrowser","getBrowser","browser","path","rules","result","import_playwright","import_promises","import_fs","import_path","principles","rules","import_fs","import_promises","import_path","import_os","rules","browser","readdir","import_playwright","import_promises","import_fs","import_path","import_nanoid","position","import_playwright","import_promises","import_fs","import_path","import_nanoid","browser","formatBytes","import_promises","import_fs","import_path","path","import_promises","import_path","import_fs","init_types","init_types","init_types","import_playwright","import_promises","import_path","sessions","import_nanoid","import_promises","import_path","path","resolve","import_playwright","import_nanoid","import_zod","import_nanoid","path","browser","createApiTracker","resolve","discoverPages","getNavigationLinks","loadRulesConfig","runRules","createAuditResult","formatAuditResult","registerPreset","register","extractInteractiveElements","chromium","discoverUserContext","formatContextSummary","generateRulesFromFramework","createPresetFromFramework","browser","compareImages","analyzeComparison","listSessions","getSessionPaths","getMostRecentSession","mkdir","access","join","getSemanticOutput","detectLandmarks","compareLandmarks","getExpectedLandmarksForIntent","getExpectedLandmarksFromContext","LANDMARK_SELECTORS","readFile","scanDirectoryForApiCalls","discoverApiRoutes","findOrphanEndpoints","getAppContext","performLogin","clearAuthState","startBrowserServer","isServerRunning","PersistentSession","getSession","path","listActiveSessions","stopBrowserServer","liveSessionManager","ScreenshotManager","formatBytes","formatAge","aiSearchFlow","generateValidationContext","generateValidationPrompt","analyzeForObviousIssues","checkConsistency","formatConsistencyReport","result","captureWithDiagnostics","closeBrowser","writeFile","addPreference","formatPreference","listPreferences","removePreference","getPreference","loadSummary","formatMemorySummary","rebuildSummary","listLearned","promoteToPreference"]}